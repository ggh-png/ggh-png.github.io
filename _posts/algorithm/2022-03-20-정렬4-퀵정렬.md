---
title: 정렬 알고리즘(퀵 정렬)
author: ggh-png
date: 2022-03-20 10:10:00 +0800
categories: [C++, algorithm, 정렬]
tags: [algorithm]
render_with_liquid: false
---



# 퀵 정렬(Quick Sort)

### 개yo

---

앞선 포스팅에서는  `선택정렬` , `버블정렬` , `삽입정렬`에 대해 알아보았다. 3개의, 정렬 알고리즘의 시간 복잡도는 주어진 데이터에 따라 달라지지만 보통 `O(N^2)` 의 형태를 띄고 있다. 하지만 이번 포스팅에서 설명할 `퀵 정렬`  의 시간복잡도는 `O(N^2)`가 아닌 `O(N * log N)` 를 가지고 있다. 이런 특징 때문에 여러 언어의 정렬 알고리즘의 기반이 되는 알고리즘으로 쓰이고 있다. ex) C++의  sort() 등등

### 문제

---

> 문제 : 다음 숫자들을 오름차순으로 정렬하는 프로그램을 작성 하여라
> 
> 
> 1 10 5 8 7 6 4 3 2 9 
> 

#### SOL  

문제를 해결하기 위해 퀵정렬을 쓴다면 ***“특정한 값을 기준으로 큰 숫자와 작은 숫자를 나누어 배치하기”***  를 생각해 볼 수 있다. 

위와 같은 방법을 `퀵정렬` 이라고 부른다.

   

> 특징
> 
> 1. 평균 시간 복잡도는 O(N * log N)이다.   
> 2. 최악(데이터가 거의 정렬되어 있는)의 경우의 시간 복잡도는 O(N^2)이다. 
> 3. 효율성이 좋아  각 언어의 sort lib의 기반이 되는 알고리즘으로 사용된다. 

### 구현

---

```cpp
#include <iostream>

using namespace std; 

void QuickSort(int *arr, int begin, int end)
{
    if(begin >= end) return;
    int pivot = begin;
    int left = begin + 1;
    int right = end;
    while (left <= right)
    {
        // Left값이 Pivot값 보다 작은경우 
        while (left <= end && arr[left] <= arr[pivot]) left++;
        // Right값이 Pivot값 보다 큰경우 
        while (right >= begin && arr[right] >= arr[pivot]) right++; 
        // Left, Right의 인덱스 즉 순서가 엇갈리면, Pivot, Right swap
        if(left > right) swap(arr[pivot], arr[right]);
        // Pivot값보다 L, R의 조건이 모두 맞지 않는 경우 swap(L, R)
        else swap(arr[left], arr[right]);
    }
    // 재귀적 호출 
    // pivot 보다 작은 값들의 리스트 (pivot 포함 O)
    QuickSort(arr, begin, right-1); 
    // pivot 보다 큰 값들의 리스트   (picot 포함 X)
    QuickSort(arr, right+1, end);
}

int main()
{
    int arr[10] = {7, 5, 9, 0, 3, 1, 6, 2, 4, 8};
    int n = 10;
    QuickSort(arr, 0, n-1);
    for(auto el : arr)
        cout << el << " ";
    cout << endl;
    return 0;
}
```

```cpp
#include <iostream>

using namespace std;

int n = 10;
int arr[10] = {7, 5, 9, 0, 3, 1, 6, 2, 4, 8};

void quickSort(int* arr, int start, int end) {
    if (start >= end) return; // 원소가 1개인 경우 종료
    int pivot = start; // 피벗은 첫 번째 원소
    int left = start + 1;
    int right = end;
    while (left <= right) {
        // 피벗보다 큰 데이터를 찾을 때까지 반복
        while (left <= end && arr[left] <= arr[pivot]) left++;
        // 피벗보다 작은 데이터를 찾을 때까지 반복
        while (right > start && arr[right] >= arr[pivot]) right--;
        // 엇갈렸다면 작은 데이터와 피벗을 교체
        if (left > right) swap(arr[pivot], arr[right]);
        // 엇갈리지 않았다면 작은 데이터와 큰 데이터를 교체
        else swap(arr[left], arr[right]);
    }
    // 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행
    quickSort(arr, start, right - 1);
    quickSort(arr, right + 1, end);
}

int main(void) {
    quickSort(arr, 0, n - 1);
    for (int i = 0; i < n; i++) {
        cout << arr[i] << ' ';
    }
}
```

#### 출력 값

```cpp
1 2 3 4 5 6 7 8 9 10
```

### 해설

---

위 코드를 실행하면 오름차순으로 배열이 정리된 모습을 확인 할 수 있다. 

1. 리스트 안의 요소 한개를 선택한다. - 기준값(Pibot) 설정 
2. 설정한 기준값(Pibot)을 기준으로 보다 작은 요소드은 왼쪽 보다 큰 요소들은 모두 오른쪽으로 옮긴다. 
3. 피벗을 제외한 왼쪽, 오른쪽 리스트를 정렬한다. 
4. 분할된 부분의 리스트를 다시 호출 - 정렬한다. 
5. 분할 된 리스트도 마찬가지고 기준값(Pibot)을 기준으로 2개의 리스트로 나누는 과정을 재귀적으로 반복한다.
6. 언재까지?? ~~> 리스트의 크기가 0이나 1이 될때까지 

 

---

```cpp
**< 예시 입력 >

10
26 5 37 1 61 11 59 15 48 19

< 예시 출력 >

26 
5 26 
5 26 37 
1 5 26 37 
1 5 26 37 61 
1 5 11 26 37 61 
1 5 11 26 37 59 61 
1 5 11 15 26 37 59 61 
1 5 11 15 26 37 48 59 61 
1 5 11 15 19 26 37 48 59 61

< 정답 소스코드 >**
```

위와 같은 삽입정렬의 과정을 출력하는 코드를 살펴 본다면 

```cpp
#include <stdio.h>

int n;
int array[101];

int main(void) {
	int i, j, temp, n;
	scanf("%d", &n);
	for(i = 0; i < n; i++) {
		scanf("%d", &array[i]);
	}
	for(i = 0; i < n; i++) {
		j = i;
		while(j > 0 && array[j - 1] > array[j]) {
			temp = array[j - 1];
			array[j - 1] = array[j];
			array[j] = temp;
			j--;
		}
		for(j = 0; j <= i; j++) {
			printf("%d ", array[j]);
		}
		printf("\n");
	}
	return 0;
}
```

위 코드는 시작부터 특정 위치에서 시작하여 왼쪽으로 이동하여 자신보다 작은 것을 만날 때 그 위치에 원소를 삽입하는 과정을 따른다. 

> 본 포스팅은 동빈나님의 블로그를 참고하여 작성하였습니다.
>