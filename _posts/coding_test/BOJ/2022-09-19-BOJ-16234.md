---
title: BOJ - 16234 - 인구 이동
author: ggh-png
date: 2022-09-19 10:10:00 +0800
categories: [PS, BOJ]
tags: [C++, PS, BOJ, dfs, graph]
render_with_liquid: false
---
# BOJ - 16234 - 인구이동

### 문제

---

[16234번: 인구 이동](https://www.acmicpc.net/problem/16234)

---

문제

N×N크기의 땅이 있고, 땅은 1×1개의 칸으로 나누어져 있다. 각각의 땅에는 나라가 하나씩 존재하며, r행 c열에 있는 나라에는 A[r][c]명이 살고 있다. 인접한 나라 사이에는 국경선이 존재한다. 모든 나라는 1×1 크기이기 때문에, 모든 국경선은 정사각형 형태이다.

오늘부터 인구 이동이 시작되는 날이다.

인구 이동은 하루 동안 다음과 같이 진행되고, 더 이상 아래 방법에 의해 인구 이동이 없을 때까지 지속된다.

- 국경선을 공유하는 두 나라의 인구 차이가 L명 이상, R명 이하라면, 두 나라가 공유하는 국경선을 오늘 하루 동안 연다.
- 위의 조건에 의해 열어야하는 국경선이 모두 열렸다면, 인구 이동을 시작한다.
- 국경선이 열려있어 인접한 칸만을 이용해 이동할 수 있으면, 그 나라를 오늘 하루 동안은 연합이라고 한다.
- 연합을 이루고 있는 각 칸의 인구수는 (연합의 인구수) / (연합을 이루고 있는 칸의 개수)가 된다. 편의상 소수점은 버린다.
- 연합을 해체하고, 모든 국경선을 닫는다.

각 나라의 인구수가 주어졌을 때, 인구 이동이 며칠 동안 발생하는지 구하는 프로그램을 작성하시오.

입력

첫째 줄에 N, L, R이 주어진다. (1 ≤ N ≤ 50, 1 ≤ L ≤ R ≤ 100)

둘째 줄부터 N개의 줄에 각 나라의 인구수가 주어진다. r행 c열에 주어지는 정수는 A[r][c]의 값이다. (0 ≤ A[r][c] ≤ 100)

인구 이동이 발생하는 일수가 2,000번 보다 작거나 같은 입력만 주어진다.

출력

인구 이동이 며칠 동안 발생하는지 첫째 줄에 출력한다.

### 구현

---

```cpp
#include <iostream>
#include <vector>

using namespace std;

// map
int N;
int map[55][55];
int tmpmap[55][55];
int visited[55][55];

// joy
int dy[] = {-1, 0, 1, 0};
int dx[] = {0, 1, 0, -1};
int y, x;

// 국경이 열려있는 곳의 좌표 벡터
vector<pair<int, int>> v;
// 인구 차 기준 
int mn, mx;
int sub;
// 열린 국가들의 인구 합
int sum; 
int num=1;
// ans 
int ans  = 0;
int answer = 0;
bool flag = 0;

void dfs(int y, int x)
{
    visited[y][x] = 1;
    sum += map[y][x];
    num++;
    // 국경이 열린 죄표 저장 
    v.push_back({y, x});
    for(int i=0; i < 4; i++)
    {
        int ny = y + dy[i];
        int nx = x + dx[i];
        if(ny < 0 || nx < 0 || ny >= N || nx >= N)
            continue;
        // 인구차 
        sub = abs(map[y][x] - map[ny][nx]);
        // 방문하지 않고, 국경이 열리는 조건일 경우 
        if(!visited[ny][nx] && sub >= mn && sub <= mx)
        {
            flag = 1;
            dfs(ny, nx);
        }
    }
    return;
}

int main()
{
    cin >> N >> mn >> mx;
    for(int i=0; i < N; i++)
        for(int j=0; j < N; j++)
            cin >> map[i][j];

    while(1)
    {
        flag = 0;
        for(int i=0; i < N; i++)
        {
            for(int j=0; j < N; j++)
            {
                tmpmap[i][j] = map[i][j];
                sum = 0;
                num = 0;
                if(!visited[i][j])
                {
                    dfs(i, j);
                    int tmp = sum / num;
                    // 인구 이동을 해야하는 경우 
                    if(v.size())
                    {
                        ans++;
                        for(auto &el : v)
                            map[el.first][el.second] = tmp;
                    }
                    v.clear();
                }
            }
        }
        fill(&visited[0][0], &visited[N][N], 0);
        
        // 인구이동이 있었는가 확인
        if(flag == 1)
            answer++;
        // 없었다면 종료
        if(!flag)
            break;
    }
    cout << answer << endl;    
    return 0;
}
```

#### SOL

---

1. 인구 이동을 해야하는 경우 
    1. 벡터에 좌표저장 
2. 방문하지 않고, 인구 이동이 있을 경우 dfs 호출 및 flag 온 
3. 보든 루프를 돌았을 때 flag즉 인구이동이 없다면 종료 및 결과 출력

### Reference & 다른 PS 모음집

---

[GitHub - ggh-png/PS: 2021.01.11 start](https://github.com/ggh-png/PS)

[DFS 깊이 우선 탐색](https://ggh-png.github.io/posts/dfs/)