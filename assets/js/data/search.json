[ { "title": "face_tracking 2 dynamixel", "url": "/posts/robot-emotibot/", "categories": "robot, emotibot", "tags": "robot, emotibot, gpt, dynamixel, ros", "date": "2023-04-15 11:10:00 +0900", "snippet": "목표 사람의 얼굴 인식 및 인식 범위를 이용해 얼굴 위치를 추정한 camera_tracking node의 degree 값을 pub sub 한 degree 값을 통한 dynamixel 포지션 제어이론적 배경이 프로젝트에서는 얼굴 인식 기술을 사용하여 얻은 각도(degree) 값을 이용해 다이나믹셀(Dynamixel)의 움직임을 제어한다.1. 얼굴 인식 - camera_tracking_node.pyrosrun camera_tracking camera_tracking_node.py프로젝트에서는 얼굴 인식 노드를 사용하여 사람의 얼굴 각도를 감지하고, 이 값을 degree로 변환한다.2. 다이나믹셀 단위 변환 - neck_control_service.pyroslaunch neck_control neck_control_service.launch convert_to_value(degree) position (0 ~ 360 → 0 ~ 4096)입력받은 degree 값을 다이나믹셀이 이해할 수 있는 단위로 변경한다.3. 서비스 클라이언트 요청 - neck_control_service.py변환된 값을 다이나믹셀 워크벤치 서비스 서버에 클라이언트 요청으로 보낸다.4. 다이나믹셀 제어 - Dynamixel Workbench controllers pkg서버는 클라이언트의 요청을 받고, 미리 지정한 매개변수(param) 값(속도, 가속도)이 적용된 PID 제어 알고리즘을 실행한다. PID 제어 알고리즘은 로봇 제어에서 널리 사용되는 피드백 제어 방법으로, 시스템의 정확성과 안정성을 높이기 위해 사용된다.이로써 PID 제어 알고리즘을 통해 부드럽고 정확한 다이나믹셀 움직임이 가능해진다.code solcamera_tracking_node#!/usr/bin/env pythonimport rospyimport cv2import mathfrom std_msgs.msg import Int32rospy.init_node(&#39;camera_traking&#39;)pub = rospy.Publisher(&#39;EMOTIBOT/neck_position&#39;, Int32, queue_size=10)# 얼굴을 감지하기 위한 미리 학습된 Haar Cascade 분류기(대상 분류 알고리즘) 로드face_cascade = cv2.CascadeClassifier(&#39;./haarcascade_frontalface_default.xml&#39;)# 기본 카메라로부터 비디오 캡처를 시작cap = cv2.VideoCapture(0)# degree 값을 저장할 배열 선언degree_array = []# 비디오 스트림의 각 프레임을 반복 처리while True: # 비디오 스트림으로부터 프레임을 읽어오기 ret, frame = cap.read() # 화면 중앙 픽셀값 960 540 height, width = frame.shape[:2] center_x = int(width / 2) center_y = int(height / 2) # 프레임을 회색조 이미지로 변환 gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) # 회색조 이미지에서 얼굴을 감지 faces = face_cascade.detectMultiScale(gray, scaleFactor=1.1, minNeighbors=8, minSize=(30, 30)) # 감지된 얼굴의 크기를 계산하여 큰 얼굴에는 1, 작은 얼굴에는 2를 표시하고 초록색 사각형으로 표시 faces_sorted_by_size = sorted(faces, key=lambda f: f[2] * f[3], reverse=True) for idx, (x, y, w, h) in enumerate(faces_sorted_by_size, 1): cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 255, 0), 2) # 얼굴 사각형 내의 영역을 ROI(관심 영역 지정)로 정의 roi_gray = gray[y:y + h, x:x + w] roi_color = frame[y:y + h, x:x + w] # 오른쪽 끝은 1700, 왼쪽 끝은 300(맥북 카메라기준) cv2_rectangle_center = [int(x + w / 2), int(y + h / 2)] # 픽셀값과 실제 가로, 세로 길이 비율 proportion_x = 40 / 700 proportion_y = 50 / 150000 # 비율 적용한 가로 길이(화면상의 정가운데 픽셀값 - 이동한거리에 따른 픽셀값 * 비율) real_x = (center_x - cv2_rectangle_center[0]) * proportion_x # 비율 적용한 세로 길이(화면에 인식되는 얼굴의 사각형의 넓이 * 비율) real_y = w * h * proportion_y # 빗변 길이(피타고라스 사용) real_r = (real_x ** 2 + real_y ** 2) ** 0.5 # 높이/빗변으로 sin값 받아오기 sin_x = real_x / real_r # sin값이 -1에서 1사이가 아닐 경우 예외 처리 if not -1 &amp;lt;= sin_x &amp;lt;= 1: continue # 아크사인값으로 각도값 받아오기 및 디그리 변환 rad = math.asin(sin_x) degree = round(math.degrees(rad), -1) text = str(1) if idx == 1 else str(2) font = cv2.FONT_HERSHEY_SIMPLEX font_scale = 1 thickness = 2 text_size, _ = cv2.getTextSize(text, font, font_scale, thickness) text_x = x + w + 10 text_y = y + int(h / 2) + int(text_size[1] / 2) cv2.putText(frame, text, (text_x, text_y), font, font_scale, (0, 255, 0), thickness, cv2.LINE_AA) # degree값의 평균필터 5개의 값마다 degree 평균출력 degree_average = 0 count = 0 if idx == 1: degree_array.append(degree) if idx == 1 and len(degree_array) &amp;gt; 5: degree_average = sum(degree_array) / len(degree_array) pub.publish(int(round(degree_average, -1)) + 180) degree_array.clear() # 감지된 얼굴과 ROIs가 포함된 프레임을 표시 cv2.imshow(&#39;Video&#39;, frame) # &#39;q&#39; 키가 눌리면 반복문을 종료합니다 if cv2.waitKey(1) &amp;amp; 0xFF == ord(&#39;q&#39;): break# 비디오 캡처를 해제 및 윈도우 종료cap.release()cv2.destroyAllWindows()face tracking 에 대한 자세한 설명 사람의 얼굴을 인식하고 얼굴의 위치를 추정한 degree값을 아래의 타입으로 pub Publisher(‘EMOTIROBOT/neck_position’, Int32, queue_size=10)EMOTIROBOT/neck_position 토픽에 Int32 타입의 데이터를 발행하며, 큐 사이즈는 10으로 설정한다.**pub.publish(int(round(degree_average, -1)) + 180)**pub할 degree의 범위가 0~360이기에 + 180 후 pubneck_controller nodeneck_control_service.py#!/usr/bin/env pythonimport rospyfrom dynamixel_workbench_msgs.srv import DynamixelCommand, DynamixelCommandRequestfrom std_msgs.msg import Int32import subprocessdef convert_to_value(degree): &quot;&quot;&quot; Converts a degree value to a value in the range of 0-4096. &quot;&quot;&quot; degree_range = 360.0 # 0~360도 범위 내에서 제어하고 있다고 가정 value_range = 4096 # 0~4096 범위 내의 출력값 # 범위를 0~1 사이의 값으로 정규화하고 value_range를 곱해서 출력값으로 변환 value = int((degree / degree_range) * value_range) return valuedef dynamixel_controller_callback(data): try: # 서비스 클라이언트 생성 rospy.wait_for_service(&#39;/dynamixel_workbench/dynamixel_command&#39;) dynamixel_command_client = rospy.ServiceProxy(&#39;/dynamixel_workbench /dynamixel_command&#39;, DynamixelCommand) # 요청 메시지 생성 command = &#39;goal_position&#39; id = 1 addr_name = &#39;Goal_Position&#39; value = convert_to_value(data.data) request = DynamixelCommandRequest() request.command = command request.id = id request.addr_name = addr_name request.value = value # 서비스 요청 response = dynamixel_command_client(request) rospy.loginfo(response) except rospy.ServiceException as e: rospy.logerr(&quot;Service call failed: %s&quot;%e)if __name__ == &#39;__main__&#39;: rospy.init_node(&#39;neck_controller&#39;) rospy.Subscriber(&#39;EMOTIROBOT/neck_position&#39;, Int32, dynamixel_controller_callback) rospy.spin()다이나믹셀 단위 변환camera_tracking node에서 보낸 pub를 아래와 같은 타입으로 sub**Subscriber(&#39;EMOTIROBOT/neck_position&#39;, Int32, dynamixel_controller_callback)**sub EMOTIROBOT/neck_position의 degree값을 convert_to_value(degree)를 통해변환서비스 클라이언트 요청 - neck_control_service.py**response = dynamixel_command_client(request)****rospy.loginfo(response)**변환된 값을 dynamixel_workbench 서비스 서버에 클라이언트 요청한다.dynamixel_workbench_controllers pkgparam EMOTIROBOT_head.yamlpan: ID: 1 Return_Delay_Time: 0 Operating_Mode: 3 Profile_Acceleration: 5 Profile_Velocity: 70dynamixel에 대한 설정값이다. 아래와 같다. ID: 모터의 ID 번호를 나타낸다. Return_Delay_Time: 명령을 전송한 후 응답을 기다리는 시간을 나타낸다. (단위 2us) Operating_Mode: 모터의 동작 모드를 나타내며. 값이 3인 경우 위치 제어 모드가 된다. Profile_Acceleration: 모터의 가속도 프로파일을 설정한다. Profile_Velocity: 모터의 속도 프로파일을 설정한다.위 설정 값을 토대로 PID 제어 알고리즘이 작동 된다.사용된 수식camera_tracking_node**int(round(degree_average, -1)) + 180** float 의 자료형에서 할 부분을 반올림 후 int형으로 변환 180을 더해 단위변환 (-180 ~ 180 → 0 ~ 360)neck_controller nodeconvert_to_value(degree)sub EMOTIROBOT/neck_position의 degree값을 다음 단계를 거쳐 변환: degree_range = 360.0 → 0~360 카메라 제어범위 value_range = 4096 → 0~4096 dynamixel 제어범위 value = int((degree / degree_range) * value_range) → degree to dynamixel position 범위를 0~1 사이의 값으로 정규화하고 value_range를 곱해서 출력값으로 변환 install &amp;amp;&amp;amp; launchinstallgit clone https://github.com/ggh-png/EMOTIROBOT.gitgit clone https://github.com/ROBOTIS-GIT/DynamixelSDK.gitcd ~/catkin_ws &amp;amp;&amp;amp; catkin_makeneck_control_service launchroslaunch neck_control neck_control_service.launchcamera_tracking launchrosrun camera_tracking camera_tracking_node.pyDemo 일부공개함 좀 느리긴 한데 부드러워짐https://youtu.be/4qaEupD6s5EReference &amp;amp; codeROBOTIS e-Manualhttps://github.com/ggh-png/EMOTIBOT" }, { "title": "BOJ - 1182 - 부분수열의 합", "url": "/posts/BOJ-1182/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, bruteforce, graph", "date": "2023-02-14 11:10:00 +0900", "snippet": "BOJ - 1182 - 부분수열의 합문제1182번: 부분수열의 합문제N개의 정수로 이루어진 수열이 있을 때, 크기가 양수인 부분수열 중에서 그 수열의 원소를 다 더한 값이 S가 되는 경우의 수를 구하는 프로그램을 작성하시오.입력 첫째 줄에 정수의 개수를 나타내는 N과 정수 S가 주어진다. (1 ≤ N ≤ 20, S ≤ 1,000,000) 둘째 줄에 N개의 정수가 빈 칸을 사이에 두고 주어진다. 주어지는 정수의 절댓값은 100,000을 넘지 않는다. 출력첫째 줄에 합이 S가 되는 부분수열의 개수를 출력한다.예제 입력 15 0-7 -3 -2 5 8예제 출력 11구현#include &amp;lt;iostream&amp;gt;using namespace std;int n, m;int cnt = 0;int arr[22];void sol(int sum, int idx){ if(idx == n) return; // 만약 합의 값과 일치하면 if(sum + arr[idx] == m) cnt++; // 배열을 검사하고 적용하지 않았을 경우 sol(sum, idx+1); sol(sum + arr[idx], idx+1);}int main(){ cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; for(int i=0; i &amp;lt; n; i++) cin &amp;gt;&amp;gt; arr[i]; sol(0, 0); cout &amp;lt;&amp;lt; cnt &amp;lt;&amp;lt; endl; return 0;}SOL 부분 수열을 더한 경우와 더하지 않았을 경우를 모두 확인해 본다.Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startCombination and Permutation" }, { "title": "BOJ - 2146 - 다리 만들기", "url": "/posts/BOJ-2146/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, bfs, graph", "date": "2023-01-13 11:10:00 +0900", "snippet": "BOJ - 2146 - 다리 만들기문제2146번: 다리 만들기문제여러 섬으로 이루어진 나라가 있다. 이 나라의 대통령은 섬을 잇는 다리를 만들겠다는 공약으로 인기몰이를 해 당선될 수 있었다. 하지만 막상 대통령에 취임하자, 다리를 놓는다는 것이 아깝다는 생각을 하게 되었다. 그래서 그는, 생색내는 식으로 한 섬과 다른 섬을 잇는 다리 하나만을 만들기로 하였고, 그 또한 다리를 가장 짧게 하여 돈을 아끼려 하였다.이 나라는 N×N크기의 이차원 평면상에 존재한다. 이 나라는 여러 섬으로 이루어져 있으며, 섬이란 동서남북으로 육지가 붙어있는 덩어리를 말한다. 다음은 세 개의 섬으로 이루어진 나라의 지도이다.위의 그림에서 색이 있는 부분이 육지이고, 색이 없는 부분이 바다이다. 이 바다에 가장 짧은 다리를 놓아 두 대륙을 연결하고자 한다. 가장 짧은 다리란, 다리가 격자에서 차지하는 칸의 수가 가장 작은 다리를 말한다. 다음 그림에서 두 대륙을 연결하는 다리를 볼 수 있다.물론 위의 방법 외에도 다리를 놓는 방법이 여러 가지 있으나, 위의 경우가 놓는 다리의 길이가 3으로 가장 짧다(물론 길이가 3인 다른 다리를 놓을 수 있는 방법도 몇 가지 있다).지도가 주어질 때, 가장 짧은 다리 하나를 놓아 두 대륙을 연결하는 방법을 찾으시오.입력첫 줄에는 지도의 크기 N(100이하의 자연수)가 주어진다. 그 다음 N줄에는 N개의 숫자가 빈칸을 사이에 두고 주어지며, 0은 바다, 1은 육지를 나타낸다. 항상 두 개 이상의 섬이 있는 데이터만 입력으로 주어진다.출력첫째 줄에 가장 짧은 다리의 길이를 출력한다.예제 입력 1101 1 1 0 0 0 0 1 1 11 1 1 1 0 0 0 0 1 11 0 1 1 0 0 0 0 1 10 0 1 1 1 0 0 0 0 10 0 0 1 0 0 0 0 0 10 0 0 0 0 0 0 0 0 10 0 0 0 0 0 0 0 0 00 0 0 0 1 1 0 0 0 00 0 0 0 1 1 1 0 0 00 0 0 0 0 0 0 0 0 0예제 출력 13출처구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std;// map int n, m;int map[304][304];// 섬 번호 visitedint cvisited[304][304];int visited[304][304];// joyint dy[] = {-1, 0, 1, 0};int dx[] = {0, 1, 0, -1};//int y, x;// ansint ans = 987654321;// 각 섬의 시작 좌표를 담는 큐 queue&amp;lt;pair&amp;lt;pair&amp;lt;int, int&amp;gt;, int&amp;gt;&amp;gt; q;// cnt는 각 섬에 부여된 번호를 뜻합니다. void bfs(int sy, int sx, int scnt){ queue&amp;lt;pair&amp;lt;pair&amp;lt;int, int&amp;gt;, int&amp;gt;&amp;gt; qqq; qqq.push({{sy, sx}, scnt}); while(qqq.size()) { int y = qqq.front().first.first; int x = qqq.front().first.second; int cnt = qqq.front().second; qqq.pop(); for(int i=0; i &amp;lt; 4; i++) { int ny = y + dy[i]; int nx = x + dx[i]; if(ny &amp;lt; 0 || nx &amp;lt; 0 || ny &amp;gt;= n || nx &amp;gt;= m) continue; // 방문하지 않고, 같은 섬일 경우 if(!visited[ny][nx] &amp;amp;&amp;amp; map[ny][nx] == cnt) { visited[ny][nx] = 1; qqq.push({{ny, nx}, cnt}); } // 방문하지 않고, 바다일 경우 if(!visited[ny][nx] &amp;amp;&amp;amp; !map[ny][nx]) { visited[ny][nx] = visited[y][x] + 1; qqq.push({{ny, nx}, cnt}); } // 다른 섬일 경우 == 다른 섬에 도착 하였을 경우 if(map[ny][nx] &amp;amp;&amp;amp; map[ny][nx] != cnt) { visited[ny][nx] = 1; ans = min(visited[y][x], ans); return; } } }}// 섬 번호 부여 bfs void color(int sy, int sx, int scnt){ queue&amp;lt;pair&amp;lt;pair&amp;lt;int, int&amp;gt;, int&amp;gt;&amp;gt; qq; qq.push({{sy, sx}, scnt}); while(qq.size()) { int y = qq.front().first.first; int x = qq.front().first.second; int cnt = qq.front().second; qq.pop(); for(int i=0; i &amp;lt; 4; i++) { int ny = y + dy[i]; int nx = x + dx[i]; if(ny &amp;lt; 0 || nx &amp;lt; 0 || ny &amp;gt;= n || nx &amp;gt;= m) continue; if(!map[ny][nx]) q.push({{y, x}, cnt}); if(!cvisited[ny][nx] &amp;amp;&amp;amp; map[ny][nx]) { cvisited[ny][nx] = 1; map[ny][nx] = cnt; qq.push({{ny, nx}, cnt}); } } }}int main(){ cin &amp;gt;&amp;gt; n; m = n; for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; m; j++) cin &amp;gt;&amp;gt; map[i][j]; // 섬 번호 부여 int cnt = 0; for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; m; j++) if(!cvisited[i][j] &amp;amp;&amp;amp; map[i][j]) { cnt++; map[i][j] = cnt; color(i, j, cnt); } while(q.size()) { bfs(q.front().first.first, q.front().first.second, q.front().second); fill(&amp;amp;visited[0][0], &amp;amp;visited[n][n], 0); q.pop(); } cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl; return 0;}SOL 각 섬의 번호 부여 각 섬의 모서리 좌표를 큐에 저장 (y, x, land number) 다리 bfs 탐색Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startBFS 너비 우선 탐색" }, { "title": "BOJ - 1759 - 암호 만들기", "url": "/posts/BOJ-1759/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, combination, bruteforce", "date": "2022-12-15 11:10:00 +0900", "snippet": "BOJ - 1759 - 암호 만들기문제1759번: 암호 만들기문제문제바로 어제 최백준 조교가 방 열쇠를 주머니에 넣은 채 깜빡하고 서울로 가 버리는 황당한 상황에 직면한 조교들은, 702호에 새로운 보안 시스템을 설치하기로 하였다. 이 보안 시스템은 열쇠가 아닌 암호로 동작하게 되어 있는 시스템이다.암호는 서로 다른 L개의 알파벳 소문자들로 구성되며 최소 한 개의 모음(a, e, i, o, u)과 최소 두 개의 자음으로 구성되어 있다고 알려져 있다. 또한 정렬된 문자열을 선호하는 조교들의 성향으로 미루어 보아 암호를 이루는 알파벳이 암호에서 증가하는 순서로 배열되었을 것이라고 추측된다. 즉, abc는 가능성이 있는 암호이지만 bac는 그렇지 않다.새 보안 시스템에서 조교들이 암호로 사용했을 법한 문자의 종류는 C가지가 있다고 한다. 이 알파벳을 입수한 민식, 영식 형제는 조교들의 방에 침투하기 위해 암호를 추측해 보려고 한다. C개의 문자들이 모두 주어졌을 때, 가능성 있는 암호들을 모두 구하는 프로그램을 작성하시오.입력첫째 줄에 두 정수 L, C가 주어진다. (3 ≤ L ≤ C ≤ 15) 다음 줄에는 C개의 문자들이 공백으로 구분되어 주어진다. 주어지는 문자들은 알파벳 소문자이며, 중복되는 것은 없다.출력각 줄에 하나씩, 사전식으로 가능성 있는 암호를 모두 출력한다.예제 입력 14 6a t c i s w예제 출력 1acisacitaciwacstacswactwaistaiswaitwastwcistciswcitwistw구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;// 주어진 알파벳에서 모음 2개 이상 추출 int n, r;string mo = &quot;aeiou&quot;;// 조합 vector&amp;lt;char&amp;gt; v;vector&amp;lt;char&amp;gt; vv;void combi(int idx){ // 조건을 만족할 경우 if(v.size() == n) { int ja_cnt = 0; int mo_cnt = 0; for (auto &amp;amp;el : v) { bool flag = 1; for(int i=0; i &amp;lt; mo.size(); i++) if(el == mo[i]) { mo_cnt++; flag = 0; break; } if(flag) ja_cnt++; } if(mo_cnt &amp;gt;= 1 &amp;amp;&amp;amp; ja_cnt &amp;gt;= 2) { for(auto &amp;amp;el : v) cout &amp;lt;&amp;lt; el; cout &amp;lt;&amp;lt; endl; //return; } } // 조건을 만족하지 못한 경우 for(int i=idx+1; i &amp;lt; r; i++) { v.push_back(vv[i]); combi(i); v.pop_back(); } return;}int main(){ cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; r; for(int i=0; i &amp;lt; r; i++) { char tmp; cin &amp;gt;&amp;gt; tmp; vv.push_back(tmp); } sort(vv.begin(), vv.end()); combi(-1); return 0;}SOL n, r 에 따라 조합을 생성한다. 조건 (모음 1개이상, 자음 2개이상)에 만족하면 출력한다.Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startCombination and Permutation" }, { "title": "BOJ - 1707 - 이분 그래프", "url": "/posts/BOJ-1707/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, dfs, graph", "date": "2022-12-12 11:10:00 +0900", "snippet": "BOJ - 1707 - 이분 그래프문제1707번: 이분 그래프문제그래프의 정점의 집합을 둘로 분할하여, 각 집합에 속한 정점끼리는 서로 인접하지 않도록 분할할 수 있을 때, 그러한 그래프를 특별히 이분 그래프 (Bipartite Graph) 라 부른다.그래프가 입력으로 주어졌을 때, 이 그래프가 이분 그래프인지 아닌지 판별하는 프로그램을 작성하시오.입력입력은 여러 개의 테스트 케이스로 구성되어 있는데, 첫째 줄에 테스트 케이스의 개수 K가 주어진다. 각 테스트 케이스의 첫째 줄에는 그래프의 정점의 개수 V와 간선의 개수 E가 빈 칸을 사이에 두고 순서대로 주어진다. 각 정점에는 1부터 V까지 차례로 번호가 붙어 있다. 이어서 둘째 줄부터 E개의 줄에 걸쳐 간선에 대한 정보가 주어지는데, 각 줄에 인접한 두 정점의 번호 u, v (u ≠ v)가 빈 칸을 사이에 두고 주어진다.출력K개의 줄에 걸쳐 입력으로 주어진 그래프가 이분 그래프이면 YES, 아니면 NO를 순서대로 출력한다.제한 2 ≤ K ≤ 5 1 ≤ V ≤ 20,000 1 ≤ E ≤ 200,000예제 입력 123 21 32 34 41 22 33 44 2예제 출력 1YESNO구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;// 테케, 정점, 간선int k, v, e;int visited[20004];// dfs void dfs(int start, vector&amp;lt;int&amp;gt; v[]){ // 방문하지 않았더라면 색 1 부여 if(!visited[start]) visited[start] = 1; // 색 1을 부여한 접한 접점들 조사 for(int i=0; i &amp;lt; v[start].size(); i++) { int idx = v[start][i]; // 방문을 하지 않았더라면 if(!visited[idx]) { // 이전 방문 요소가 1번 색이라면 if(visited[start] == 1) visited[idx] = 2; // 이전 방문 요소가 2번 색이라면 else if(visited[start] == 2) visited[idx] = 1; // 다음 요소 방문 dfs(idx, v); } }}string check(int V, vector&amp;lt;int&amp;gt; v[]){ for(int j=1; j &amp;lt;= V; j++) for(int a=0; a &amp;lt; v[j].size(); a++) { int idx = v[j][a]; if(visited[j] == visited[idx]) return &quot;NO&quot;; } return &quot;YES&quot;;}// 2분 그래프 ... 두 색으로 표현 하되 int main(){ cin &amp;gt;&amp;gt; k; for(int i=0; i &amp;lt; k; i++) { cin &amp;gt;&amp;gt; v &amp;gt;&amp;gt; e; int V, E; vector&amp;lt;int&amp;gt; v[200004]; // graph 생성 for(int j=0; j &amp;lt; e; j++) { cin &amp;gt;&amp;gt; V &amp;gt;&amp;gt; E; v[V].push_back(E); v[E].push_back(V); } for (int i = 1; i &amp;lt;= V; i++) if (!visited[i]) dfs(i, v); cout &amp;lt;&amp;lt; check(V, v) &amp;lt;&amp;lt; endl; // 초기화 fill(visited, visited + 20004, 0); } return 0;}SOL 양 방향 그래프 생성 dfs를 통해 visited 컬러 부여 check 를 이용하여 전 후 간선이 같다면 NO 출력Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startBFS 너비 우선 탐색" }, { "title": "BOJ - 11659 - 구간 합 구하기 4", "url": "/posts/BOJ-11659/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, prefixsum", "date": "2022-12-06 11:10:00 +0900", "snippet": "BOJ - 11659 - 구간 합 구하기 4문제11659번: 구간 합 구하기 4문제수 N개가 주어졌을 때, i번째 수부터 j번째 수까지 합을 구하는 프로그램을 작성하시오.입력첫째 줄에 수의 개수 N과 합을 구해야 하는 횟수 M이 주어진다. 둘째 줄에는 N개의 수가 주어진다. 수는 1,000보다 작거나 같은 자연수이다. 셋째 줄부터 M개의 줄에는 합을 구해야 하는 구간 i와 j가 주어진다.출력총 M개의 줄에 입력으로 주어진 i번째 수부터 j번째 수까지 합을 출력한다.제한 1 ≤ N ≤ 100,000 1 ≤ M ≤ 100,000 1 ≤ i ≤ j ≤ N예제 입력 15 35 4 3 2 11 32 45 5예제 출력 11291구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;int n, m;int arr[100005];int psum[100006];int main(){ ios_base :: sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; for(int i=1; i &amp;lt;= n; i++) { cin &amp;gt;&amp;gt; arr[i]; psum[i] = psum[i-1] + arr[i]; } for(int i=0; i &amp;lt; m; i++) { int a, b; cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; cout &amp;lt;&amp;lt; psum[b] - psum[a-1] &amp;lt;&amp;lt; &#39;\\n&#39;; } return 0;}SOLprefix sum 을 이용하여 해결Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 start" }, { "title": "BOJ - 19942 - 다이어트", "url": "/posts/BOJ-19942/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, combination, permutation, BitMasking", "date": "2022-12-01 11:10:00 +0900", "snippet": "BOJ - 19942 - 다이어트문제19942번: 다이어트문제식재료 N개 중에서 몇 개를 선택해서 이들의 영양분(단백질, 탄수화물, 지방, 비타민)이 일정 이상이 되어야 한다. 아래 표에 제시된 6가지의 식재료 중에서 몇 개를 선택해서 이들의 영양분의 각각 합이 최소 100, 70, 90, 10가 되도록 하는 경우를 생각해보자. 이 경우 모든 재료를 선택하면 쉽게 해결되지만, 우리는 조건을 만족시키면서도 비용이 최소가 되는 선택을 하려고 한다. 재료 단백질 지방 탄수화물 비타민 가격 1 30 55 10 8 100 2 60 10 10 2 70 3 10 80 50 0 50 4 40 30 30 8 60 5 60 10 70 2 120 6 20 70 50 4 40 예를 들어, 식재료 1, 3, 5를 선택하면 영양분은 100, 145, 130, 10으로 조건을 만족하지만 가격은 270이 된다. 대신 2, 3, 4를 선택하면 영양분의 합은 110, 130, 90, 10, 비용은 180이 되므로, 앞의 방법보다는 더 나은 선택이 된다.입력으로 식재료 표가 주어졌을 때, 최저 영양소 기준을 만족하는 최소 비용의 식재료 집합을 찾아야 한다.입력첫 줄에 식재료의 개수 N$N$이 주어진다.다음 줄에는 단백질, 지방, 탄수화물, 비타민의 최소 영양성분을 나타내는 정수 mp$mp$, mf$mf$, ms$ms$, mv$mv$가 주어진다.이어지는 N$N$개의 각 줄에는 i$i$번째 식재료의 단백질, 지방, 탄수화물, 비타민과 가격이 5개의 정수 pi$p_i$, fi$f_i$, si$s_i$, vi$v_i$, ci$c_i$와 같이 주어진다. 식재료의 번호는 1부터 시작한다.출력첫 번째 줄에 최소 비용을 출력하고, 두 번째 줄에 조건을 만족하는 최소 비용 식재료의 번호를 공백으로 구분해 오름차순으로 한 줄에 출력한다. 같은 비용의 집합이 하나 이상이면 사전 순으로 가장 빠른 것을 출력한다.조건을 만족하는 답이 없다면 -1을 출력하고, 둘째 줄에 아무것도 출력하지 않는다.제한 $3 \\le N \\le 15$ 3≤N≤15 $0 \\le mp, mf, ms, mv \\le 500$ 0≤mp,mf,ms,mv≤500 $mp + mf + ms + mv &amp;gt; 0$ mp+mf+ms+mv&amp;gt;0 $0 \\le p_i, f_i, s_i, v_i, c_i \\le 500$ 0≤pi,fi,si,vi,ci≤500 예제 입력 16100 70 90 1030 55 10 8 10060 10 10 2 7010 80 50 0 5040 30 30 8 6060 10 70 2 12020 70 50 4 4예제 출력 11342 4 6구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;class vita{public: int a=0, b=0, c=0, d=0, e=0;};class result{public: int a, b, c, d, e; string f;};int num;vector&amp;lt;vita&amp;gt; v;int q, w, e, r, t;int limA, limB, limC, limD;string ans = &quot;&quot;;vector&amp;lt;result&amp;gt; answer;bool comapre(result a , result b){ // 금액이 같으면 사전순으로 정렬 if(a.e == b.e) return a.f &amp;gt; b.f; return a.e &amp;gt; b.e;}int main(){ cin &amp;gt;&amp;gt; num; cin &amp;gt;&amp;gt; limA &amp;gt;&amp;gt; limB &amp;gt;&amp;gt; limC &amp;gt;&amp;gt; limD; for(int i=0; i &amp;lt; num; i++) { cin &amp;gt;&amp;gt; q &amp;gt;&amp;gt; w &amp;gt;&amp;gt; e &amp;gt;&amp;gt; r &amp;gt;&amp;gt; t; v.push_back({q, w, e, r, t}); } // 모든 경우의 수 // 6 64 for(int i=0; i &amp;lt; (1 &amp;lt;&amp;lt; num); i++) { vita lim; vector&amp;lt;int&amp;gt; N; for(int j=0; j &amp;lt; num; j++) if(i &amp;amp; (1 &amp;lt;&amp;lt; j)) { lim.a += v[j].a; lim.b += v[j].b; lim.c += v[j].c; lim.d += v[j].d; lim.e += v[j].e; // 비타민 번호 index N.push_back(j+1); // limit 조건에 충족 하면 if(lim.a &amp;gt;= limA &amp;amp;&amp;amp; lim.b &amp;gt;= limB &amp;amp;&amp;amp; lim.c &amp;gt;= limC &amp;amp;&amp;amp; lim.d &amp;gt;= limD) { ans = &quot;&quot;; for(auto &amp;amp;el : N) ans += to_string(el) + &quot; &quot;; result tmp; tmp.a = lim.a; tmp.b = lim.b; tmp.c = lim.c; tmp.d = lim.d; tmp.e = lim.e; tmp.f = ans; answer.push_back(tmp); } } } // 조건에 충족한 정답이 있다면 if(answer.size()) { sort(answer.rbegin(), answer.rend(), comapre); cout &amp;lt;&amp;lt; answer.front().e &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; answer.front().f &amp;lt;&amp;lt; endl; } else cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; endl; return 0;}SOL bitmasking을 이용하여 모든 경우의 수를 추출 조건에 맞을 시 result vector에 push cost를 기준으로 내림차순 정렬 내림차순 정렬 시 cost의 값이 같다면 사전순으로 정렬 Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startBitMasking" }, { "title": "BitMasking", "url": "/posts/bitmasking/", "categories": "algorithm, Bitmasking, Combination, Combi, permu", "tags": "algorithm, combination, permutation, BitMasking", "date": "2022-12-01 11:10:00 +0900", "snippet": "C++ 비트 마스킹개yo이번 포스팅에선 기본적인 비트 연산을 알아보고 직접 구현해 보고, 이를 이용한 조합Combination을 함께 알아보도록 하겠다.비트 연산먼저 비트연산에 대하여 알아 보도록 하겠다.우선 왼쪽 시프트 연산자 « 는 수를 왼쪽으로 이동한다는 의미다.비트마스킹에서 보통 (1 « x)이 꼴로 많이 쓰인다. int a = 8 → 0110예를 들어 (1 « 2)는 2의 2승, (1 « 0)은 2의 0승을 상징한다.| idx번째 비트끄기 | S &amp;amp;= ~(1 « idx) || — | — || idx번째에 대한 XOR 연산(0은 1로, 1은 0으로) | S ^= (1 « idx) || 최하위 켜져있는 idx 찾기 | idx = (S &amp;amp; -S) || n인 집합의 모든 비트를 켜기 | (1 « n) - 1 || idx번째 비트를 켜기 | S |= (1 « idx) || idx번째 비트가 있는지 확인하기 | if(S &amp;amp; (1 « idx)) | 최하위 비트찾기 idx = (S &amp;amp; -S)자 저 -1이 뭔지를 보자.예를 들어 x = 0110 이라고 해보자. ~x = 1001이된다. (사실 그 위의 있는 비트도 뒤집히긴 하나 생략.)여기서 ~ x + 1을 하게 되면 1010이 되고이 ~x +1 &amp;amp; x를 하게 되면 가장 끝자리에 있는 켜져있는 비트를 뽑아낼 수 있다. x = (~x + 1) 의 특징을 가지므로 x &amp;amp; x로 놓을 수 있다.ex code#include &amp;lt;iostream&amp;gt;using namespace std; void t1(){ int n = 15; // 1111 int idx = 2; n &amp;amp;= ~(1 &amp;lt;&amp;lt; idx); // 1&#39;1&#39;11 -&amp;gt; 1&#39;0&#39;11 == 11 cout &amp;lt;&amp;lt; &quot;1. idx번째 비트 끄기 : &quot; &amp;lt;&amp;lt; n &amp;lt;&amp;lt; &quot;\\n&quot;;}void t2(){ int n = 11; // 1011 int idx = 2; n ^= (1 &amp;lt;&amp;lt; idx); // 1&#39;0&#39;11 -&amp;gt; 1&#39;1&#39;11 == 15 cout &amp;lt;&amp;lt; &quot;2. 0은 1로, 1은 0으로 XOR T2 : &quot; &amp;lt;&amp;lt; n &amp;lt;&amp;lt; &quot;\\n&quot;;}void t3(){ int n = 6; // 0110 int idx = (n &amp;amp; -n); // 0110 &amp;amp; 1110 == 0110 cout &amp;lt;&amp;lt; &quot;3. 최하위 켜져있는 인덱스 T3: &quot; &amp;lt;&amp;lt; idx &amp;lt;&amp;lt; &quot;\\n&quot;;}void t4(){ int n = 3; // 000 - 100 cout &amp;lt;&amp;lt; &quot;4. 크기가 n인 모든 집합의 모든 비트 켜기 T4 : &quot; &amp;lt;&amp;lt; (1 &amp;lt;&amp;lt; n) - 1 &amp;lt;&amp;lt; &quot;\\n&quot;;}void t5(){ int n = 5; int idx = 1; // 0101 =&amp;gt; 0111 7 n |= (1 &amp;lt;&amp;lt; idx); cout &amp;lt;&amp;lt; &quot;5. idx번째 불켜기 T5 : &quot; &amp;lt;&amp;lt; n &amp;lt;&amp;lt; &quot;\\n&quot;;}void t6(){ int n = 5; // 0101 int idx = 1; string a = n &amp;amp; (1 &amp;lt;&amp;lt; idx) ? &quot;yes&quot; : &quot;no&quot;; cout &amp;lt;&amp;lt; &quot;6. idx번째 비트가 있는지 확인하기 T6 : &quot; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &quot;\\n&quot;;}int main() { t1(); t2(); t3(); t4(); t5(); t6(); return 0;}/*1. idx번째 비트 끄기 : 112. 0은 1로, 1은 0으로 XOR T2 : 153. 최하위 켜져있는 인덱스 T3: 24. 크기가 n인 모든 집합의 모든 비트 켜기 T4 : 75. idx번째 불켜기 T5 : 76. idx번째 비트가 있는지 확인하기 T6 : no*/비트마스킹어떠한 특정원소를 찾을 때 어느정도의 시간복잡도는 자료구조 마다 다르다. 배열의 어떤 요소를 찾을 때 선형적인 시간 : O(N) sorted array에서 이분탐색으로 찾을 때는 O(logN) 해싱테이블에서는 O(1) 그렇다면 불리언 배열에서 무언가를 찾는 등의 연산은 어떻게 될까? 보통 불리언배열은 vector, bitset, set 로 표현해서 처리하곤 한다. 여기서 find메서드를 쓰는 등을 통해 연산을 한다. 하지만 이러한 것들보다 비트연산을 쓰면 좀 더 가볍고 빠르게 된다.이렇게 불리언배열의 역할을 하는 “하나의 숫자”를 만들어서 “비트 연산자”를 통해 탐색, 수정 등의 작업을 하는 것을 비트마스킹이라고 한다.101은 1(0 0 1)과 4(1 0 0)의 합집합이며 이는 {0, 2}로 표현이 가능하고,111은? {0, 1, 2}로 표현이 가능하다.즉, 불리언배열을 만들어서 {0, 1, 0, 1} 이렇게 만들지 않고 0101 이라는 하나의 수, 5 등을 이용해 하나의 숫자로 불리언 배열같은 역할을 할 수 있다. 또한 앞서 배운 비트연산자를 통해 해당 요소가 포함되어있는지 안되어있는지 등을 쉽게 알 수 있다.참고 : 왜 비트마스킹이라고 할까?컴퓨터의 저장 공간인 메모리에는 0이나 1이 저장된다. 이러한 메모리의 용량을 표현하는 단위는 여러가지가 있는데 그 중 최소 단위를 비트(Bit)라고 하며 이 비트는 0 또는 1이라는 값을 가진다. 이를 기반으로 해당 비트를 켜거나(1로 만들거나) 끄거나(0으로 만들거나) 하는 “마스킹”하기 때문에 비트마스킹이라고 한다.참고로 비트는 이진수의 약어다. 비트나 이진수나 똑같은 개념이라고 보면 된다. (BIT = Binary Digit)비스마스킹을 이용한 경우의 수비스마스킹은 경우의 수를 표현하는데도 잘 쓰이는데 예를 들어 {사과, 딸기, 포도, 배}의 모든 경우의 수는 어떻게 될까?{사과}{딸기, 사과}..총 16가지수가 나오게 되는데, 사과를 포함하거나 포함하지 않거나 해서 각각의 요소는 2개의 상태값을 가지기 때문에 2^4 = 16이 되는 것이다..#include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; const int n = 4;int main() { string a[n] = {&quot;사과&quot;, &quot;딸기&quot;, &quot;포도&quot;, &quot;배&quot;}; for(int i = 0; i &amp;lt; (1 &amp;lt;&amp;lt; n); i++){ string ret = &quot;&quot;; for(int j = 0; j &amp;lt; n; j++){ if(i &amp;amp; (1 &amp;lt;&amp;lt; j)){ ret += (a[j] + &quot; &quot;); } } cout &amp;lt;&amp;lt; ret &amp;lt;&amp;lt; &#39;\\n&#39;; } return 0;} /*사과 딸기 사과 딸기 포도 사과 포도 딸기 포도 사과 딸기 포도 배 사과 배 딸기 배 사과 딸기 배 포도 배 사과 포도 배 딸기 포도 배 사과 딸기 포도 배 */이렇게 모든 집합을 표현한 것을 볼 수 있다.i는 0000, 0001, 0010을 상징한다.j는 0, 1, 2, 3을 기반으로 (1 « 0), (1 « 1) 등으로 해당 번째의 비트가 켜져있냐 켜져있지 않냐를 통해 집합을 확인 한다.즉 이러한 것을 통해 4C1, 4C2 … 이러한 조합들의 모든 경우의 수를 한번의 for문 만으로 표현이 가능한 셈이다.문제에서 4C1, 4C2 여러가지 조합 등 모든 경우의 수를 기반으로 로직을 짜야 하는 경우 유용하다.비트마스킹을 이용한 매개변수 전달사과라는 매개변수가 포함이 되어있고 이어서 사과 + 포도, 사과 + 배 이런식의 매개변수를 더하는 것을 구현하고 싶다면 이렇게 하면 된다.#include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; const int n = 4;string a[4] = {&quot;사과&quot;, &quot;딸기&quot;, &quot;포도&quot;, &quot;배&quot;};void go(int num){ string ret = &quot;&quot;; for(int i = 0; i &amp;lt; 4; i++){ if(num &amp;amp; (1 &amp;lt;&amp;lt; i)) ret += a[i] + &quot; &quot;; } cout &amp;lt;&amp;lt; ret &amp;lt;&amp;lt; &#39;\\n&#39;; return;}int main() { for(int i = 1; i &amp;lt; n; i++){ go(1 | (1 &amp;lt;&amp;lt; i)); } return 0;} /*사과 딸기 사과 포도 사과 배*/이처럼 « 또는 &amp;amp; 등 비트연산자 등으로 불리언배열의 역할을 하는 비트마스킹을 알아보았다.하지만 비트마스킹은 한계가 있습니다. 바로 31까지 가능하다. int형 숫자의 한계까지인 셈이다. long long은 어떠냐 하는 의견도 있는데 보통 2^ 30승정도만 해도… 10억이 되기 때문에 그 이후의 경우의 수를 센다는 것 자체가 이미 시간복잡도를 많이 초과하기 때문에 보통은 30 ~ 31 까지의 경우의 수만을 표현할 수 있다고 볼 수 있다.Reference9. C++ STL sort() 함수 다루기 ②[알고리즘 강의] 4주차. 비트마스킹" }, { "title": "BOJ - 11724 - 연결 요소의 개수", "url": "/posts/BOJ-11724/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, dfs, graph, tree", "date": "2022-11-29 11:10:00 +0900", "snippet": "BOJ - 11724 - 연결 요소의 개수문제11724번: 연결 요소의 개수문제방향 없는 그래프가 주어졌을 때, 연결 요소 (Connected Component)의 개수를 구하는 프로그램을 작성하시오.입력첫째 줄에 정점의 개수 N과 간선의 개수 M이 주어진다. (1 ≤ N ≤ 1,000, 0 ≤ M ≤ N×(N-1)/2) 둘째 줄부터 M개의 줄에 간선의 양 끝점 u와 v가 주어진다. (1 ≤ u, v ≤ N, u ≠ v) 같은 간선은 한 번만 주어진다.출력첫째 줄에 연결 요소의 개수를 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;// mapvector&amp;lt;int&amp;gt; map[1004];int visited[1004];int n, m;int cnt = 0;void dfs(int idx){ visited[idx] = 1; for(auto &amp;amp;el : map[idx]) { int index = el; if(!visited[index]) dfs(el); }}int main(){ cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; int u, v; // 연결 리스트 생성 for(int i=0; i &amp;lt; m; i++) { cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v; map[u].push_back(v); map[v].push_back(u); } // 완전 탐색, 방문하지 않았더라면 == 간선++ for (int i = 1; i &amp;lt;= n; i++) if (!visited[i]) { cnt++; dfs(i); } cout &amp;lt;&amp;lt; cnt; return 0;}SOL 연결 리스트 생성 탐색 후 방문하지 않았더라면 cnt++Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startBFS 너비 우선 탐색DFS 깊이 우선 탐색" }, { "title": "BOJ - 18405 - 경쟁적 전염", "url": "/posts/BOJ-18405/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, dfs, graph", "date": "2022-11-24 11:10:00 +0900", "snippet": "BOJ - 18405 - 경쟁적 전염문제18405번: 경쟁적 전염문제NxN 크기의 시험관이 있다. 시험관은 1x1 크기의 칸으로 나누어지며, 특정한 위치에는 바이러스가 존재할 수 있다. 모든 바이러스는 1번부터 K번까지의 바이러스 종류 중 하나에 속한다.시험관에 존재하는 모든 바이러스는 1초마다 상, 하, 좌, 우의 방향으로 증식해 나간다. 단, 매 초마다 번호가 낮은 종류의 바이러스부터 먼저 증식한다. 또한 증식 과정에서 특정한 칸에 이미 어떠한 바이러스가 존재한다면, 그 곳에는 다른 바이러스가 들어갈 수 없다.시험관의 크기와 바이러스의 위치 정보가 주어졌을 때, S초가 지난 후에 (X,Y)에 존재하는 바이러스의 종류를 출력하는 프로그램을 작성하시오. 만약 S초가 지난 후에 해당 위치에 바이러스가 존재하지 않는다면, 0을 출력한다. 이 때 X와 Y는 각각 행과 열의 위치를 의미하며, 시험관의 가장 왼쪽 위에 해당하는 곳은 (1,1)에 해당한다.예를 들어 다음과 같이 3x3 크기의 시험관이 있다고 하자. 서로 다른 1번, 2번, 3번 바이러스가 각각 (1,1), (1,3), (3,1)에 위치해 있다. 이 때 2초가 지난 뒤에 (3,2)에 존재하는 바이러스의 종류를 계산해보자.1초가 지난 후에 시험관의 상태는 다음과 같다.2초가 지난 후에 시험관의 상태는 다음과 같다.결과적으로 2초가 지난 뒤에 (3,2)에 존재하는 바이러스의 종류는 3번 바이러스다. 따라서 3을 출력하면 정답이다.입력첫째 줄에 자연수 N, K가 공백을 기준으로 구분되어 주어진다. (1 ≤ N ≤ 200, 1 ≤ K ≤ 1,000) 둘째 줄부터 N개의 줄에 걸쳐서 시험관의 정보가 주어진다. 각 행은 N개의 원소로 구성되며, 해당 위치에 존재하는 바이러스의 번호가 공백을 기준으로 구분되어 주어진다. 단, 해당 위치에 바이러스가 존재하지 않는 경우 0이 주어진다. 또한 모든 바이러스의 번호는 K이하의 자연수로만 주어진다. N+2번째 줄에는 S, X, Y가 공백을 기준으로 구분되어 주어진다. (0 ≤ S ≤ 10,000, 1 ≤ X, Y ≤ N)출력S초 뒤에 (X,Y)에 존재하는 바이러스의 종류를 출력한다. 만약 S초 뒤에 해당 위치에 바이러스가 존재하지 않는다면, 0을 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;// map int n, m, k;int map[204][204];int visited[204][204];int sy, sx, ss;// joyint dy[] = {-1, 0, 1, 0};int dx[] = {0, 1, 0, -1};vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; v[1004];vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; tmp[1004];void spread(int y, int x, int color){ for(int i=0; i &amp;lt; 4; i++) { int ny = y + dy[i]; int nx = x + dx[i]; if(ny &amp;gt;= n || nx &amp;gt;= m || ny &amp;lt; 0 || nx &amp;lt; 0) continue; if(!map[ny][nx]) { map[ny][nx] = color; tmp[color].push_back({ny, nx}); } }}int main(){ cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k; m = n; int mx=0; for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; m; j++) { cin &amp;gt;&amp;gt; map[i][j]; if(map[i][j]) v[map[i][j]].push_back({i, j}); mx = max(mx, map[i][j]); } cin &amp;gt;&amp;gt; ss &amp;gt;&amp;gt; sy &amp;gt;&amp;gt; sx; for(int j=0; j &amp;lt; ss; j++) for(int i=0; i &amp;lt;= mx; i++) { while(v[i].size()) { spread(v[i].front().first, v[i].front().second , i); v[i].erase(v[i].begin()); } while(tmp[i].size()) { v[i].push_back({tmp[i].front().first, tmp[i].front().second}); tmp[i].erase(tmp[i].begin()); } } cout &amp;lt;&amp;lt; map[sy-1][sx-1] &amp;lt;&amp;lt; endl; return 0;}SOL 1초당 1회만 전염시킬 것 void spread(int y, int x, int color) { for(int i=0; i &amp;lt; 4; i++) { int ny = y + dy[i]; int nx = x + dx[i]; if(ny &amp;gt;= n || nx &amp;gt;= m || ny &amp;lt; 0 || nx &amp;lt; 0) continue; if(!map[ny][nx]) { map[ny][nx] = color; // 감염 확산 tmp[color].push_back({ny, nx}); } } } 우선순위로 숫자가 낮은 감염요소부터 감염될 것 // 주어진 시간동안 for(int j=0; j &amp;lt; ss; j++) // 우선순위가 낮은 감염요소부터 for(int i=0; i &amp;lt;= mx; i++) { // 감염 시작 while(v[i].size()) { spread(v[i].front().first, v[i].front().second , i); v[i].erase(v[i].begin()); } // 새로운 감염좌표 입력 while(tmp[i].size()) { v[i].push_back({tmp[i].front().first, tmp[i].front().second}); tmp[i].erase(tmp[i].begin()); } } Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startDFS 깊이 우선 탐색" }, { "title": "BOJ - 2665 - 미로 만들기", "url": "/posts/BOJ-2665/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, bfs, graph", "date": "2022-11-14 11:10:00 +0900", "snippet": "BOJ - 2665 - 미로만들기문제2665번: 미로만들기문제n×n 바둑판 모양으로 총 n2개의 방이 있다. 일부분은 검은 방이고 나머지는 모두 흰 방이다. 검은 방은 사면이 벽으로 싸여 있어 들어갈 수 없다. 서로 붙어 있는 두 개의 흰 방 사이에는 문이 있어서 지나다닐 수 있다. 윗줄 맨 왼쪽 방은 시작방으로서 항상 흰 방이고, 아랫줄 맨 오른쪽 방은 끝방으로서 역시 흰 방이다.시작방에서 출발하여 길을 찾아서 끝방으로 가는 것이 목적인데, 아래 그림의 경우에는 시작방에서 끝 방으로 갈 수가 없다. 부득이 검은 방 몇 개를 흰 방으로 바꾸어야 하는데 되도록 적은 수의 방의 색을 바꾸고 싶다.아래 그림은 n=8인 경우의 한 예이다.위 그림에서는 두 개의 검은 방(예를 들어 (4,4)의 방과 (7,8)의 방)을 흰 방으로 바꾸면, 시작방에서 끝방으로 갈 수 있지만, 어느 검은 방 하나만을 흰 방으로 바꾸어서는 불가능하다. 검은 방에서 흰 방으로 바꾸어야 할 최소의 수를 구하는 프로그램을 작성하시오.단, 검은 방을 하나도 흰방으로 바꾸지 않아도 되는 경우는 0이 답이다.입력첫 줄에는 한 줄에 들어가는 방의 수 n(1 ≤ n ≤ 50)이 주어지고, 다음 n개의 줄의 각 줄마다 0과 1이 이루어진 길이가 n인 수열이 주어진다. 0은 검은 방, 1은 흰 방을 나타낸다.출력첫 줄에 흰 방으로 바꾸어야 할 최소의 검은 방의 수를 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std;// mapint n, m;int map[55][55];int visited[55][55][255];// joy int dy[] = {-1, 0, 1, 0};int dx[] = {0, 1, 0, -1};vector&amp;lt;int&amp;gt; v;void bfs(int sy, int sx, int sbk){ queue&amp;lt;pair&amp;lt;pair&amp;lt;int, int&amp;gt;, int&amp;gt;&amp;gt; q; q.push({{sy, sx}, sbk}); while(q.size()) { int y = q.front().first.first; int x = q.front().first.second; int bk = q.front().second; if(y == n-1 &amp;amp;&amp;amp; x == m-1) v.push_back(bk); q.pop(); for(int i=0; i &amp;lt; 4; i++) { int ny = y + dy[i]; int nx = x + dx[i]; if(ny &amp;lt; 0 || ny &amp;gt;= n || nx &amp;lt; 0 || nx &amp;gt;= m) continue; if(map[ny][nx] &amp;amp;&amp;amp; !visited[ny][nx][bk]) { visited[ny][nx][bk] = visited[y][x][bk] + 1; q.push({{ny, nx}, bk}); } if(!map[ny][nx] &amp;amp;&amp;amp; !visited[ny][nx][bk+1]) { visited[ny][nx][bk+1] = visited[y][x][bk] + 1; q.push({{ny, nx}, bk+1}); } } }}int main(){ cin &amp;gt;&amp;gt; n; m = n; for(int i=0; i &amp;lt; n; i++) { string str; cin &amp;gt;&amp;gt; str; for(int j=0; j &amp;lt; m; j++) map[i][j] = str[j] - 48; } bfs(0, 0, 0); sort(v.begin(), v.end()); cout &amp;lt;&amp;lt; v[0] &amp;lt;&amp;lt; endl; return 0;}SOL visited[ y ][ x ][ bk ] y, x == 좌표 bk == 벽을 뚫고간 횟수 bfs를 실행시켜 목적지에 도착하게 되면 벽을 뚫고 간 횟수흫 vector 에 저장 저장된 vector를 내림차순 정렬 후 정답 출력 Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startBFS 너비 우선 탐색" }, { "title": "Combination and Permutation", "url": "/posts/permuandcombi/", "categories": "algorithm, Combination, Combi, permu", "tags": "algorithm, combination, permutation", "date": "2022-10-24 11:10:00 +0900", "snippet": "C++ 순열과 조합개요12명이 서로(2명씩) 인사하면 66가지의 경우에 수가 나오게 된다. 이 경우의 수는 순열과 조합으로 구할 수 있는데이번 포스팅에선 이 순열과 조합에 대해 알아 보고, 코드로 구현까지 해보도록 하겠다.순열 먼저 순열, permutation이란 순서가 정해진 임의의 집합을 다른 순서로 섞는 연산을 말한다. 즉 예를들어 { 1, 2, 3 } 의 요소가 있을 때 { 1, 3, 2 } 이런식으로 다른 순서로 섞는것을 연산 순열이라 한다. 만약 n 개의 집합 중 n개를 고르는 순열의 개수를 구할 때 중복을 허용한다면 n!이 된다.위의 예를 들어 보자면 3개의 자연수{ 1, 2, 3 }를 이용해 만들 수 있는 3자리 자연수는 몇개 일까? [ 123,132, 213, 231, 312, 321 ] 6개의 순열이 나오게 된다. 또 만약 3개의 자연수{ 1, 2, 3 }를 이용해 만들 수 있는 1자리 자연수는 3개다. 전자는 3개중 3개를 뽑는 것이기에 3!이 되고 후자는 3개중 1개를 뽑는 것이라 3이되게 된다. nPr = n! / (n - r)! n : 요소의 개수 r : 요소에서 필요로하는 개수 위와 같은 문제는 위 공식에 따라 몇개인지 결정이 됩니다. 예를 들어 3개 중 3개를 뽑는다면 3!/(3 -3)! 이 되고 3개 중 1개를 뽑는다면 3! / (3 - 1)! 이 되는 것이다. 이를 코드로 구현을 하면 비트 마스킹, next_permutation과 perv _permutation, 재귀 각각 세가지의 방법이 존재한다.next_permutation, perv_permutation - Permutation#include &amp;lt;cstdio&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;using namespace std;void printV(vector&amp;lt;int&amp;gt; &amp;amp;v){ for(int i = 0; i &amp;lt; v.size(); i++) cout &amp;lt;&amp;lt; v[i] &amp;lt;&amp;lt; &quot; &quot;; cout &amp;lt;&amp;lt; &quot;\\n&quot;;}int main(){ int a[3] = {1, 2, 3}; vector&amp;lt;int&amp;gt; v; for(int i = 0; i &amp;lt; 3; i++) v.push_back(a[i]); //1, 2, 3부터 오름차순으로 순열을 뽑습니다. do printV(v); while(next_permutation(v.begin(), v.end())); cout &amp;lt;&amp;lt; &quot;-------------&quot; &amp;lt;&amp;lt; &#39;\\n&#39;; v.clear(); for(int i = 2; i &amp;gt;= 0; i--) v.push_back(a[i]); //3, 2, 1부터 내림차순으로 순열을 뽑습니다. do printV(v); while(prev_permutation(v.begin(), v.end())); return 0;}출력1 2 31 3 22 1 32 3 13 1 23 2 1-------------3 2 13 1 22 3 12 1 31 3 21 2 3사용법 오름차순 do printV(v); while(next_permutation(v.begin(), v.end())); 내림차순 do printV(v); while(prev_permutation(v.begin(), v.end()));재귀함수 - Permutation#include &amp;lt;cstdio&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;using namespace std;int a[3] = {1, 2, 3};vector&amp;lt;int&amp;gt; v;void printV(vector&amp;lt;int&amp;gt; &amp;amp;v){ for(int i = 0; i &amp;lt; v.size(); i++) cout &amp;lt;&amp;lt; v[i] &amp;lt;&amp;lt; &quot; &quot;; cout &amp;lt;&amp;lt; &quot;\\n&quot;;}void makePermutation(int n, int r, int depth){ if(r == depth) { printV(v); return; } for(int i = depth; i &amp;lt; n; i++) { swap(v[i], v[depth]); makePermutation(n, r, depth + 1); swap(v[i], v[depth]); } return;}int main(){ for(int i = 0; i &amp;lt; 3; i++) v.push_back(a[i]); makePermutation(3, 3, 0); return 0;}출력1 2 31 3 22 1 32 3 13 1 23 2 1재귀 - Permutation sol 순열을 만들고, 다시 돌려 놓는다. 완전탐색 이용 void makePermutation(int n, int r, int depth){ if(r == depth) { printV(v); return; } for(int i = depth; i &amp;lt; n; i++) { swap(v[i], v[depth]); makePermutation(n, r, depth + 1); swap(v[i], v[depth]); } return;}조합 - Combination 순열, permutation이 순서가 정해진 임의의 집합을 다른 순서로 섞는 연산이라면, 조합 Combination 은 순서가 정해지지 않은 집합들의 모음을 뜻한다. nCr = n! / r!(n-r)! n : 요소의 개수 r : 요소에서 필요로하는 개수 공식은 위와 같으며 예를들어 서로 다른 5개의 구슬 중 3개의 구슬을 뽑는 상황에서의 조합의 결과는 다음과 같다. 5C3 = 5! / 3!(5 - 3)! = 10재귀함수 - Combination#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;// 서로다른 5개의 구슬이 들어있는 구슬망에서 3개의 구슬을// 뽑는 조합 구현 // nCr = 5C3int n = 5;int r = 3;int arr[] = {1, 2, 3, 4, 5};vector&amp;lt;int&amp;gt; v;void CombiPrint(vector&amp;lt;int&amp;gt; v){ for(auto &amp;amp;el : v) cout &amp;lt;&amp;lt; el &amp;lt;&amp;lt; &quot; &quot;; cout &amp;lt;&amp;lt; endl;}void combi(int start, vector&amp;lt;int&amp;gt; v){ // 3개의 구슬이 뽑아지면 if(v.size() == r) { CombiPrint(v); return; } for(int i=start+1; i &amp;lt; n; i++) { v.push_back(arr[i]); combi(i, v); v.pop_back(); } return;}int main(){ combi(-1, v); return 0;}출력1 2 3 1 2 4 1 2 5 1 3 4 1 3 5 1 4 5 2 3 4 2 3 5 2 4 5 3 4 5재귀 - Combination 완전 탐색void combi(int start, vector&amp;lt;int&amp;gt; v){ // 3개의 구슬이 뽑아지면 if(v.size() == r) { CombiPrint(v); return; } for(int i=start+1; i &amp;lt; n; i++) { v.push_back(arr[i]); combi(i, v); v.pop_back(); } return;}벡터에 요소를 넣고 3개의 구슬을 뽑게되면 리턴하여 함수를 종료 하게 한다.1차적으로 종료된 함수는 처음으로 뽑은 구슬을 다시 빼게 되면서 완전탐색을 할 수 있도록 구현 한다.다중 for문 - r 값이 작을 경우 (3이하)#include &amp;lt;iostream&amp;gt;using namespace std;int main(){ int a[] = {1, 2, 3, 4, 5, 6}; for(int i = 0; i &amp;lt; 6; i++) for(int j = 0; j &amp;lt; i; j++) for(int k = 0; k &amp;lt; j; k++) cout &amp;lt;&amp;lt; a[i] &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; a[j] &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; a[k] &amp;lt;&amp;lt; endl; return 0;}SOLr 값 즉, 집합에서 요소를 뽑아야 되는 개수가 3이하로 작다면 위와 같이 다중 for문으로 구할 수 있다.다중 for문의 장점은 재귀를 이용한 조합을 구현하는 것 보다 더 쉽게 구현 할 수 있다는 장점이 있다.Reference큰돌의 터전 : 네이버 블로그" }, { "title": "BOJ - 1431 - 시리얼 번호", "url": "/posts/BOJ-1431/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, sort, 정렬", "date": "2022-10-20 11:10:00 +0900", "snippet": "BOJ - 1431 - 시리얼 번호문제1431번: 시리얼 번호문제문제다솜이는 기타를 많이 가지고 있다. 그리고 각각의 기타는 모두 다른 시리얼 번호를 가지고 있다. 다솜이는 기타를 빨리 찾아서 빨리 사람들에게 연주해주기 위해서 기타를 시리얼 번호 순서대로 정렬하고자 한다.모든 시리얼 번호는 알파벳 대문자 (A-Z)와 숫자 (0-9)로 이루어져 있다.시리얼번호 A가 시리얼번호 B의 앞에 오는 경우는 다음과 같다. A와 B의 길이가 다르면, 짧은 것이 먼저 온다. 만약 서로 길이가 같다면, A의 모든 자리수의 합과 B의 모든 자리수의 합을 비교해서 작은 합을 가지는 것이 먼저온다. (숫자인 것만 더한다) 만약 1,2번 둘 조건으로도 비교할 수 없으면, 사전순으로 비교한다. 숫자가 알파벳보다 사전순으로 작다.시리얼이 주어졌을 때, 정렬해서 출력하는 프로그램을 작성하시오.입력첫째 줄에 기타의 개수 N이 주어진다. N은 50보다 작거나 같다. 둘째 줄부터 N개의 줄에 시리얼 번호가 하나씩 주어진다. 시리얼 번호의 길이는 최대 50이고, 알파벳 대문자 또는 숫자로만 이루어져 있다. 시리얼 번호는 중복되지 않는다.출력첫째 줄부터 차례대로 N개의 줄에 한줄에 하나씩 시리얼 번호를 정렬한 결과를 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;bool compare(string a, string b){ if(a.size() == b.size()) { int sizea = 0; int sizeb = 0; for(auto &amp;amp;el : a) if(el &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; el &amp;lt;= &#39;9&#39;) sizea += int(el) - 48; for(auto &amp;amp;el : b) if(el &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; el &amp;lt;= &#39;9&#39;) sizeb += int(el) - 48; if(sizea == sizeb) return a &amp;lt; b; return sizea &amp;lt; sizeb; } return a.size() &amp;lt; b.size();}int main(){ vector&amp;lt;string&amp;gt; v; int num; cin &amp;gt;&amp;gt; num; for(int i=0; i &amp;lt; num; i++) { string str; cin &amp;gt;&amp;gt; str; v.push_back(str); } sort(v.begin(), v.end(), compare); for(auto &amp;amp;el : v) cout &amp;lt;&amp;lt; el &amp;lt;&amp;lt; endl; return 0;}SOL string 사이즈로 정렬 각각의 string 내에 포함되어 있는 숫자들의 합으로 정렬 사전순으로 정렬Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 start" }, { "title": "BOJ - 1245 - 농장 관리", "url": "/posts/BOJ-1245/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, graph, dfs", "date": "2022-10-17 11:10:00 +0900", "snippet": "BOJ - 1245 - 농장 관리문제1245번: 농장 관리문제농부 민식이가 관리하는 농장은 N×M 격자로 이루어져 있다. 민식이는 농장을 관리하기 위해 산봉우리마다 경비원를 배치하려 한다. 이를 위해 농장에 산봉우리가 총 몇 개 있는지를 세는 것이 문제다.산봉우리의 정의는 다음과 같다. 산봉우리는 같은 높이를 가지는 하나의 격자 혹은 인접한 격자들의 집합으로 이루어져 있다. (여기서 “인접하다”의 정의는 X좌표 차이와 Y좌표 차이 모두 1 이하일 경우로 정의된다.) 또한 산봉우리와 인접한 격자는 모두 산봉우리의 높이보다 작아야한다.문제는 격자 내에 산봉우리의 개수가 총 몇 개인지 구하는 것이다.입력첫째 줄에 정수 N(1 &amp;lt; N ≤ 100), M(1 &amp;lt; M ≤ 70)이 주어진다. 둘째 줄부터 N+1번째 줄까지 각 줄마다 격자의 높이를 의미하는 M개의 정수가 입력된다. 격자의 높이는 500보다 작거나 같은 음이 아닌 정수이다.출력첫째 줄에 산봉우리의 개수를 출력한다.구현#include &amp;lt;iostream&amp;gt;using namespace std;// mapint n, m;int map[104][104];bool visited[104][104];// joyint dy[] = {-1, 0, 1, 0, 1, 1, -1, -1};int dx[] = {0, 1, 0, -1, 1, -1, -1, 1};// ansint ans = 0;bool peak;void dfs(int y, int x){ visited[y][x] = 1; for(int i=0; i &amp;lt; 8; i++) { int ny = y + dy[i]; int nx = x + dx[i]; if(ny &amp;lt; 0 || nx &amp;lt; 0 || ny &amp;gt;= n || nx &amp;gt;= m) continue; if(map[ny][nx] &amp;gt; map[y][x]) peak = 0; if(map[ny][nx] == map[y][x] &amp;amp;&amp;amp; !visited[ny][nx]) dfs(ny, nx); }}int main(){ cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; m; j++) cin &amp;gt;&amp;gt; map[i][j]; for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; m; j++) if(!visited[i][j] &amp;amp;&amp;amp; map[i][j]) { peak = 1; dfs(i, j); if(peak) ans++; } cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl; return 0;}SOL// 봉우리가 아닐 경우 if(map[ny][nx] &amp;gt; map[y][x]) peak = 0;// 같은 높이고, 방문하지 않았을 경우 if(map[ny][nx] == map[y][x] &amp;amp;&amp;amp; !visited[ny][nx]) dfs(ny, nx);Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startDFS 깊이 우선 탐색" }, { "title": "BOJ - 3055 - 탈출", "url": "/posts/BOJ-14923/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, graph, bfs", "date": "2022-10-16 11:10:00 +0900", "snippet": "BOJ - 14923 - 미로탈출문제14923번: 미로 탈출문제홍익이는 사악한 마법사의 꾐에 속아 N x M 미로 (Hx, Hy) 위치에 떨어졌다. 다행히도 홍익이는 마법사가 만든 미로의 탈출 위치(Ex, Ey)를 알고 있다. 하지만 미로에는 곳곳에 마법사가 설치한 벽이 있어 홍익이가 탈출하기 어렵게 하고 있다.홍익이는 마법사의 연구실에서 훔친 지팡이가 있어, 벽을 길로 만들 수 있다. 그렇지만, 안타깝게도 마법의 지팡이는 단 한 번만 사용할 수 있다.이때, 홍익이를 도와 미로에서 탈출할 수 있는지 알아보고, 할 수 있다면 가장 빠른 경로의 거리 D는 얼마인지 알아보자.인접한 칸으로 이동하는데 똑같은 시간이 들고, 벽을 부수는 데 시간이 걸리지 않는다.입력N MHx HyEx EyN X M 행렬 2 ≤ N ≤ 1000, 2 ≤ M ≤ 1000 1 ≤ Hx, Hy, Ex, Ey ≤ 1000 (Hx, Hy)≠ (Ex, Ey) 행렬은 0과 1로만 이루어져 있고, 0이 빈 칸, 1이 벽이다.출력D (탈출 할 수 없다면, -1을 출력한다.)구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std;// mapbool map[1004][1004];int visited[1004][1004][2];int n, m;// xy int hy, hx;int ey, ex;// joyint dy[] = {-1, 1, 0, 0};int dx[] = {0, 0, 1, -1};// ansint ans = -1;void bfs(int sy, int sx, bool sbk){ queue&amp;lt;pair&amp;lt;pair&amp;lt;int, int&amp;gt;, bool&amp;gt;&amp;gt; q; q.push({{sy, sx}, sbk}); while(q.size()) { int y = q.front().first.first; int x = q.front().first.second; bool bk = q.front().second; q.pop(); if(y == ey-1 &amp;amp;&amp;amp; x == ex-1) { ans = visited[y][x][bk]; break; } for(int i=0; i &amp;lt; 4; i++) { int ny = y + dy[i]; int nx = x + dx[i]; if(ny &amp;lt; 0 || nx &amp;lt; 0 || ny &amp;gt;= n || nx &amp;gt;= m) continue; if(!map[ny][nx] &amp;amp;&amp;amp; !visited[ny][nx][bk]) { visited[ny][nx][bk] = visited[y][x][bk] + 1; q.push({{ny, nx}, bk}); } if(map[ny][nx] &amp;amp;&amp;amp; !bk &amp;amp;&amp;amp; !visited[ny][nx][bk+1]) { visited[ny][nx][bk+1] = visited[y][x][bk] + 1; q.push({{ny, nx}, bk+1}); } } }}int main(){ cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; cin &amp;gt;&amp;gt; hy &amp;gt;&amp;gt; hx; cin &amp;gt;&amp;gt; ey &amp;gt;&amp;gt; ex; for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; m; j++) cin &amp;gt;&amp;gt; map[i][j]; bfs(hy-1, hx-1, 0); cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;}SOL 벽을 넘어간 경우와 그렇지 못한 경우를 2가지로 나누어 bfs를 구현한다. visited[][][] 3차원 배열 생성 Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startBFS 너비 우선 탐색" }, { "title": "BOJ - 3055 - 탈출", "url": "/posts/BOJ-3055/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, graph, bfs", "date": "2022-10-15 11:10:00 +0900", "snippet": "BOJ - 3055 - 탈출문제3055번: 탈출문제사악한 암흑의 군주 이민혁은 드디어 마법 구슬을 손에 넣었고, 그 능력을 실험해보기 위해 근처의 티떱숲에 홍수를 일으키려고 한다. 이 숲에는 고슴도치가 한 마리 살고 있다. 고슴도치는 제일 친한 친구인 비버의 굴로 가능한 빨리 도망가 홍수를 피하려고 한다.티떱숲의 지도는 R행 C열로 이루어져 있다. 비어있는 곳은 ‘.’로 표시되어 있고, 물이 차있는 지역은 ‘*’, 돌은 ‘X’로 표시되어 있다. 비버의 굴은 ‘D’로, 고슴도치의 위치는 ‘S’로 나타내어져 있다.매 분마다 고슴도치는 현재 있는 칸과 인접한 네 칸 중 하나로 이동할 수 있다. (위, 아래, 오른쪽, 왼쪽) 물도 매 분마다 비어있는 칸으로 확장한다. 물이 있는 칸과 인접해있는 비어있는 칸(적어도 한 변을 공유)은 물이 차게 된다. 물과 고슴도치는 돌을 통과할 수 없다. 또, 고슴도치는 물로 차있는 구역으로 이동할 수 없고, 물도 비버의 소굴로 이동할 수 없다.티떱숲의 지도가 주어졌을 때, 고슴도치가 안전하게 비버의 굴로 이동하기 위해 필요한 최소 시간을 구하는 프로그램을 작성하시오.고슴도치는 물이 찰 예정인 칸으로 이동할 수 없다. 즉, 다음 시간에 물이 찰 예정인 칸으로 고슴도치는 이동할 수 없다. 이동할 수 있으면 고슴도치가 물에 빠지기 때문이다.입력첫째 줄에 50보다 작거나 같은 자연수 R과 C가 주어진다.다음 R개 줄에는 티떱숲의 지도가 주어지며, 문제에서 설명한 문자만 주어진다. ‘D’와 ‘S’는 하나씩만 주어진다.출력첫째 줄에 고슴도치가 비버의 굴로 이동할 수 있는 가장 빠른 시간을 출력한다. 만약, 안전하게 비버의 굴로 이동할 수 없다면, “KAKTUS”를 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;// mapint n, m;char map[55][55];int fvisited[55][55];int evisited[55][55];// joy int dy[] = {1, -1, 0, 0};int dx[] = {0, 0, 1, -1};// 도치, 비버 굴int Sy, Sx;int Dy, Dx;// 홍수 위치queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; wq;// 홍수 bfs void flood(){ while(wq.size()) { int y = wq.front().first; int x = wq.front().second; wq.pop(); for(int i=0; i &amp;lt; 4; i++) { int ny = y + dy[i]; int nx = x + dx[i]; if(ny &amp;lt; 0 || nx &amp;lt; 0 || ny &amp;gt;= n || nx &amp;gt;= m || fvisited[ny][nx]) continue; if(map[ny][nx] == &#39;.&#39;) { fvisited[ny][nx] = fvisited[y][x] + 1; wq.push({ny, nx}); } if(map[ny][nx] == &#39;D&#39;) fvisited[ny][nx] = fvisited[y][x]; } }}void escape(int sy, int sx){ queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; q; q.push({sy, sx}); while(q.size()) { int y = q.front().first; int x = q.front().second; q.pop(); for(int i=0; i &amp;lt; 4; i++) { int ny = y + dy[i]; int nx = x + dx[i]; if(ny &amp;lt; 0 || nx &amp;lt; 0 || ny &amp;gt;= n || nx &amp;gt;= m || evisited[ny][nx]) continue; if(map[ny][nx] == &#39;D&#39; || map[ny][nx] == &#39;.&#39; &amp;amp;&amp;amp; (!fvisited[ny][nx] || (fvisited[ny][nx] &amp;gt; evisited[y][x] + 1))) { evisited[ny][nx] = evisited[y][x] + 1; q.push({ny, nx}); } } }}int main(){ cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; m; j++) { cin &amp;gt;&amp;gt; map[i][j]; if(map[i][j] == &#39;*&#39;) wq.push({i, j}); if(map[i][j] == &#39;D&#39;) { Dy = i; Dx = j; } if(map[i][j] == &#39;S&#39;) { Sy = i; Sx = j; } } flood(); escape(Sy, Sx); if(!evisited[Dy][Dx]) cout &amp;lt;&amp;lt; &quot;KAKTUS&quot; &amp;lt;&amp;lt; endl; else cout &amp;lt;&amp;lt; evisited[Dy][Dx] &amp;lt;&amp;lt; endl; return 0;}SOL 홍수를 먼저 일으킨다. 탈출 경로를 구할 때 물이 들어오지 않거나, 탈출경로가 더 빠를 경우를 생각하여 bfs를 실행한다.Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startBFS 너비 우선 탐색" }, { "title": "BOJ - 2638 - 치즈", "url": "/posts/BOJ-2638/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, graph, dfs", "date": "2022-10-11 11:10:00 +0900", "snippet": "BOJ - 2638 - 치즈문제2638번: 치즈문제N×M의 모눈종이 위에 아주 얇은 치즈가 &amp;lt;그림 1&amp;gt;과 같이 표시되어 있다. 단, N 은 세로 격자의 수이고, M 은 가로 격자의 수이다. 이 치즈는 냉동 보관을 해야만 하는데 실내온도에 내어놓으면 공기와 접촉하여 천천히 녹는다. 그런데 이러한 모눈종이 모양의 치즈에서 각 치즈 격자(작 은 정사각형 모양)의 4변 중에서 적어도 2변 이상이 실내온도의 공기와 접촉한 것은 정확히 한시간만에 녹아 없어져 버린다. 따라서 아래 &amp;lt;그림 1&amp;gt; 모양과 같은 치즈(회색으로 표시된 부분)라면 C로 표시된 모든 치즈 격자는 한 시간 후에 사라진다.&amp;lt;그림 1&amp;gt;&amp;lt;그림 2&amp;gt;와 같이 치즈 내부에 있는 공간은 치즈 외부 공기와 접촉하지 않는 것으로 가정한다. 그러므 로 이 공간에 접촉한 치즈 격자는 녹지 않고 C로 표시된 치즈 격자만 사라진다. 그러나 한 시간 후, 이 공간으로 외부공기가 유입되면 &amp;lt;그림 3&amp;gt;에서와 같이 C로 표시된 치즈 격자들이 사라지게 된다.&amp;lt;그림 2&amp;gt;&amp;lt;그림 3&amp;gt;모눈종이의 맨 가장자리에는 치즈가 놓이지 않는 것으로 가정한다. 입력으로 주어진 치즈가 모두 녹아 없어지는데 걸리는 정확한 시간을 구하는 프로그램을 작성하시오.입력첫째 줄에는 모눈종이의 크기를 나타내는 두 개의 정수 N, M (5 ≤ N, M ≤ 100)이 주어진다. 그 다음 N개의 줄에는 모눈종이 위의 격자에 치즈가 있는 부분은 1로 표시되고, 치즈가 없는 부분은 0으로 표시된다. 또한, 각 0과 1은 하나의 공백으로 분리되어 있다.출력출력으로는 주어진 치즈가 모두 녹아 없어지는데 걸리는 정확한 시간을 정수로 첫 줄에 출력한다.구현#include &amp;lt;iostream&amp;gt;using namespace std;// mapint n, m;bool map[104][104];int visited[104][104];// joy int dy[] = {-1, 0, 1, 0};int dx[] = {0, 1, 0, -1};void dfs(int y, int x){ visited[y][x] = 1; for(int i=0; i &amp;lt; 4; i++) { int ny = dy[i] + y; int nx = dx[i] + x; if(ny &amp;lt; 0 || ny &amp;gt;= n || nx &amp;lt; 0 || nx &amp;gt;= m) continue; // 방문하지 않았고, 밖인 경우 if(!visited[ny][nx] &amp;amp;&amp;amp; !map[ny][nx]) { visited[ny][nx] = 1; dfs(ny, nx); } if(map[ny][nx]) visited[ny][nx]++; }}int main(){ cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; m; j++) cin &amp;gt;&amp;gt; map[i][j]; int cnt = 0; while(1) { bool flag = 1; cnt++; dfs(0, 0); for(int i=0; i &amp;lt; n; i++) { for(int j=0; j &amp;lt; m; j++) { if(visited[i][j] &amp;gt;= 2) map[i][j] = 0; if(map[i][j] == 1) flag = 0; } } fill(&amp;amp;visited[0][0], &amp;amp;visited[n][m], 0); if(flag == 1) break; } cout &amp;lt;&amp;lt; cnt &amp;lt;&amp;lt; endl; return 0;}SOLdfs 실행하되 빈 치즈인 부분에 인접하면 증산값++한번 실행시 증산값이 2보다 크면 해당 좌표에 있는 치즈 제거Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startDFS 깊이 우선 탐색" }, { "title": "BOJ - 17142 - 연구소 3", "url": "/posts/BOJ-171412/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, graph, bfs, bruteforce", "date": "2022-10-11 11:10:00 +0900", "snippet": "BOJ - 17142 - 연구소 3문제17142번: 연구소 3문제인체에 치명적인 바이러스를 연구하던 연구소에 승원이가 침입했고, 바이러스를 유출하려고 한다. 바이러스는 활성 상태와 비활성 상태가 있다. 가장 처음에 모든 바이러스는 비활성 상태이고, 활성 상태인 바이러스는 상하좌우로 인접한 모든 빈 칸으로 동시에 복제되며, 1초가 걸린다. 승원이는 연구소의 바이러스 M개를 활성 상태로 변경하려고 한다.연구소는 크기가 N×N인 정사각형으로 나타낼 수 있으며, 정사각형은 1×1 크기의 정사각형으로 나누어져 있다. 연구소는 빈 칸, 벽, 바이러스로 이루어져 있으며, 벽은 칸 하나를 가득 차지한다. 활성 바이러스가 비활성 바이러스가 있는 칸으로 가면 비활성 바이러스가 활성으로 변한다.예를 들어, 아래와 같이 연구소가 생긴 경우를 살펴보자. 0은 빈 칸, 1은 벽, 2는 바이러스의 위치이다.2 0 0 0 1 1 00 0 1 0 1 2 00 1 1 0 1 0 00 1 0 0 0 0 00 0 0 2 0 1 10 1 0 0 0 0 02 1 0 0 0 0 2M = 3이고, 바이러스를 아래와 같이 활성 상태로 변경한 경우 6초면 모든 칸에 바이러스를 퍼뜨릴 수 있다. 벽은 -, 비활성 바이러스는 *, 활성 바이러스는 0, 빈 칸은 바이러스가 퍼지는 시간으로 표시했다.* 6 5 4 - - 25 6 - 3 - 0 14 - - 2 - 1 23 - 2 1 2 2 32 2 1 0 1 - -1 - 2 1 2 3 40 - 3 2 3 4 *시간이 최소가 되는 방법은 아래와 같고, 4초만에 모든 칸에 바이러스를 퍼뜨릴 수 있다.0 1 2 3 - - 21 2 - 3 - 0 12 - - 2 - 1 23 - 2 1 2 2 33 2 1 0 1 - -4 - 2 1 2 3 4* - 3 2 3 4 *연구소의 상태가 주어졌을 때, 모든 빈 칸에 바이러스를 퍼뜨리는 최소 시간을 구해보자.입력첫째 줄에 연구소의 크기 N(4 ≤ N ≤ 50), 놓을 수 있는 바이러스의 개수 M(1 ≤ M ≤ 10)이 주어진다.둘째 줄부터 N개의 줄에 연구소의 상태가 주어진다. 0은 빈 칸, 1은 벽, 2는 바이러스를 놓을 수 있는 위치이다. 2의 개수는 M보다 크거나 같고, 10보다 작거나 같은 자연수이다.출력연구소의 모든 빈 칸에 바이러스가 있게 되는 최소 시간을 출력한다. 바이러스를 어떻게 놓아도 모든 빈 칸에 바이러스를 퍼뜨릴 수 없는 경우에는 -1을 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std;// mapint n, m;int map[55][55];int visited[55][55];// joyint dy[] = {-1, 0, 1, 0};int dx[] = {0, 1, 0, -1};// combinationbool combi[11];// bfs queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; q;vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; buff;// virus vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; virusXY;// 감염 가능구역 vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; possibleXY;// ans int ans = 987654321;void virus(){ fill(&amp;amp;visited[0][0], &amp;amp;visited[n][n], -1); for(auto &amp;amp;el : buff) { visited[el.first][el.second] = 0; q.push({el.first, el.second}); } while(q.size()) { int y = q.front().first; int x = q.front().second; q.pop(); for(int i=0; i &amp;lt; 4; i++) { int ny = y + dy[i]; int nx = x + dx[i]; if(ny &amp;lt; 0 || nx &amp;lt; 0 || ny &amp;gt;= n || nx &amp;gt;= n || visited[ny][nx] != -1 || map[ny][nx] == 1) continue; if(map[ny][nx] == 0 || map[ny][nx] == 2) { visited[ny][nx] = visited[y][x] + 1; q.push({ny , nx}); } } }}void combination(int idx, int cnt){ // 모든 활성 바이러스를 쓴다면 if(cnt == m) { bool flag = 1; int MAX = 0; virus(); for(auto &amp;amp;el : possibleXY) { int ff = el.first; int ss = el.second; if(visited[ff][ss] == -1) { flag = 0; break; } else MAX = max(MAX, visited[ff][ss]); } if(flag) ans = min(MAX, ans); return; } for(int i=idx; i &amp;lt; virusXY.size(); i++) { int ff = virusXY[i].first; int ss = virusXY[i].second; if(combi[i]) continue; else { combi[i] = 1; buff.push_back({ff, ss}); combination(i, cnt+1); buff.pop_back(); combi[i] = 0; } }}// 비활성 바이러스 : 바이러스에 감염은 되었지만, 전염은 활성화가 되어야 한다. int main(){ cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; n; j++) { cin &amp;gt;&amp;gt; map[i][j]; if(map[i][j] == 2) virusXY.push_back({i, j}); if(map[i][j] == 0) possibleXY.push_back({i, j}); } combination(0, 0); if(ans == 987654321) cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; endl; else cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl; return 0;}SOL문제를 풀기 전 경우의 수를 생각해 보아야 한다.만약 맵이 아래와 같이 이루어져 있다면,7 32 0 0 0 1 1 00 0 1 0 1 2 00 1 1 0 1 0 00 1 0 0 0 0 00 0 0 2 0 1 10 1 0 0 0 0 02 1 0 0 0 0 2비활성 바이러스는 총 5개 그리고 활성화 할 수 있는 바이러스의 개수는 3개라면 5Combination2 즉 10개의 경우가 있다는 것을 알 수 있다.따라서 코드를 통해 Combination을 구현 한다.void combination(int idx, int cnt){ // 모든 활성 바이러스를 쓴다면 if(cnt == m) { bool flag = 1; int MAX = 0; virus(); for(auto &amp;amp;el : possibleXY) { int ff = el.first; int ss = el.second; if(visited[ff][ss] == -1) { flag = 0; break; } else MAX = max(MAX, visited[ff][ss]); } if(flag) ans = min(MAX, ans); return; } for(int i=idx; i &amp;lt; virusXY.size(); i++) { int ff = virusXY[i].first; int ss = virusXY[i].second; if(combi[i]) continue; else { combi[i] = 1; buff.push_back({ff, ss}); combination(i, cnt+1); buff.pop_back(); combi[i] = 0; } }}다시한번 총 정리를 해보자면 combination 함수를 통해 시간복잡도를 보완 비활성 바이러스, 감염이 될 수 있는 공간을 따로 추출하여 비교Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startBFS 너비 우선 탐색" }, { "title": "BOJ - 17141 - 연구소 2", "url": "/posts/BOJ-17141/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, graph, bfs, bruteforce", "date": "2022-10-08 11:10:00 +0900", "snippet": "BOJ - 17141 - 연구소 2문제17141번: 연구소 2문제인체에 치명적인 바이러스를 연구하던 연구소에 승원이가 침입했고, 바이러스를 유출하려고 한다. 승원이는 연구소의 특정 위치에 바이러스 M개를 놓을 것이고, 승원이의 신호와 동시에 바이러스는 퍼지게 된다.연구소는 크기가 N×N인 정사각형으로 나타낼 수 있으며, 정사각형은 1×1 크기의 정사각형으로 나누어져 있다. 연구소는 빈 칸, 벽으로 이루어져 있으며, 벽은 칸 하나를 가득 차지한다.일부 빈 칸은 바이러스를 놓을 수 있는 칸이다. 바이러스는 상하좌우로 인접한 모든 빈 칸으로 동시에 복제되며, 1초가 걸린다.예를 들어, 아래와 같이 연구소가 생긴 경우를 살펴보자. 0은 빈 칸, 1은 벽, 2는 바이러스를 놓을 수 있는 칸이다.2 0 0 0 1 1 00 0 1 0 1 2 00 1 1 0 1 0 00 1 0 0 0 0 00 0 0 2 0 1 10 1 0 0 0 0 02 1 0 0 0 0 2M = 3이고, 바이러스를 아래와 같이 놓은 경우 6초면 모든 칸에 바이러스를 퍼뜨릴 수 있다. 벽은 -, 바이러스를 놓은 위치는 0, 빈 칸은 바이러스가 퍼지는 시간으로 표시했다.6 6 5 4 - - 25 6 - 3 - 0 14 - - 2 - 1 23 - 2 1 2 2 32 2 1 0 1 - -1 - 2 1 2 3 40 - 3 2 3 4 5시간이 최소가 되는 방법은 아래와 같고, 5초만에 모든 칸에 바이러스를 퍼뜨릴 수 있다.0 1 2 3 - - 21 2 - 3 - 0 12 - - 2 - 1 23 - 2 1 2 2 33 2 1 0 1 - -4 - 2 1 2 3 45 - 3 2 3 4 5연구소의 상태가 주어졌을 때, 모든 빈 칸에 바이러스를 퍼뜨리는 최소 시간을 구해보자.입력첫째 줄에 연구소의 크기 N(5 ≤ N ≤ 50), 놓을 수 있는 바이러스의 개수 M(1 ≤ M ≤ 10)이 주어진다.둘째 줄부터 N개의 줄에 연구소의 상태가 주어진다. 0은 빈 칸, 1은 벽, 2는 바이러스를 놓을 수 있는 칸이다. 2의 개수는 M보다 크거나 같고, 10보다 작거나 같은 자연수이다.출력연구소의 모든 빈 칸에 바이러스가 있게 되는 최소 시간을 출력한다. 바이러스를 어떻게 놓아도 모든 빈 칸에 바이러스를 퍼뜨릴 수 없는 경우에는 -1을 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;// mapint n, m;int map[55][55];int visited[55][55];bool combi[55];// joy int dy[] = {-1, 0, 1, 0};int dx[] = {0, 1, 0, -1};// ansint ans = 987654321;// virusvector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; buff;vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; VirusPos;vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; check;void virus(){ fill(&amp;amp;visited[0][0], &amp;amp;visited[n][n], 0); queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; q; for(int i=0; i &amp;lt; buff.size(); i++) { q.push({buff[i].first, buff[i].second}); visited[buff[i].first][buff[i].second] = 1; } while(q.size()) { int y = q.front().first; int x = q.front().second; q.pop(); for(int i=0; i &amp;lt; 4; i++) { int ny = y + dy[i]; int nx = x + dx[i]; if(ny &amp;lt; 0 || nx &amp;lt; 0 || ny &amp;gt;= n || nx &amp;gt;= n || map[ny][nx] == 1) continue; // 방문하지 않았고, 감염 가능한 경우 if(!visited[ny][nx]) { visited[ny][nx] = visited[y][x] + 1; q.push({ny, nx}); } } } return;}// virus add void virusadd(int idx, int cnt){ // 바이러스를 다 써버리면 if(cnt == m) { virus(); bool flag = 0; int tmp = 0; for(auto &amp;amp;el : check) { int ff = el.first; int ss = el.second; if(visited[ff][ss] == 0) { flag = 1; break; } else tmp = max(visited[ff][ss], tmp); } if(!flag) ans = min(ans, tmp); // cout &amp;lt;&amp;lt; &quot; ---- &quot; &amp;lt;&amp;lt; endl; // for(int i=0; i &amp;lt; n; i++) // { // for(int j=0; j &amp;lt; n; j++) // cout &amp;lt;&amp;lt; visited[i][j] &amp;lt;&amp;lt; &quot; &quot;; // cout &amp;lt;&amp;lt; endl; // } // cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl; return; } for(int i=idx; i &amp;lt; VirusPos.size(); i++) { if(combi[i]) continue; else { combi[i] = 1; buff.push_back({VirusPos[i].first, VirusPos[i].second}); virusadd(i, cnt+1); buff.pop_back(); combi[i] = 0; } }}int main(){ ios_base :: sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; n; j++) { cin &amp;gt;&amp;gt; map[i][j]; if(map[i][j] == 2) VirusPos.push_back({i, j}); if(map[i][j] == 0 || map[i][j] == 2) check.push_back({i, j}); } virusadd(0, 0); if(ans == 987654321) cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; &#39;\\n&#39;; else cout &amp;lt;&amp;lt; ans-1 &amp;lt;&amp;lt; &#39;\\n&#39;; return 0;}SOL문제를 풀기 전 경우의 수를 생각해 보아야 한다.만약 맵이 아래와 같이 이루어져 있다면,7 32 0 0 0 1 1 00 0 1 0 1 2 00 1 1 0 1 0 00 1 0 0 0 0 00 0 0 2 0 1 10 1 0 0 0 0 02 1 0 0 0 0 2바이러스를 심을 수 있는 공간은 총 5개 그리고 심을 수 있는 바이러스이 개수는 3개라고 할 수 있는데 이를 통해 우린 5Combination2 즉 10개의 경우가 있다는 것을 알 수 있다.따라서 코드를 통해 Combination을 구현 하여 해결 하였다. void virusadd(int idx, int cnt){ // 바이러스를 다 써버리면 if(cnt == m) { virus(); bool flag = 0; int tmp = 0; for(auto &amp;amp;el : check) { int ff = el.first; int ss = el.second; if(visited[ff][ss] == 0) { flag = 1; break; } else tmp = max(visited[ff][ss], tmp); } if(!flag) ans = min(ans, tmp); return; } for(int i=idx; i &amp;lt; VirusPos.size(); i++) { if(combi[i]) continue; else { combi[i] = 1; buff.push_back({VirusPos[i].first, VirusPos[i].second}); virusadd(i, cnt+1); buff.pop_back(); combi[i] = 0; } }}Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startBFS 너비 우선 탐색" }, { "title": "BOJ - 4963 - 섬의 개수", "url": "/posts/BOJ-4963/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, graph, dfs", "date": "2022-10-05 11:10:00 +0900", "snippet": "BOJ - 4963 - 섬의 개수문제4963번: 섬의 개수문제정사각형으로 이루어져 있는 섬과 바다 지도가 주어진다. 섬의 개수를 세는 프로그램을 작성하시오.한 정사각형과 가로, 세로 또는 대각선으로 연결되어 있는 사각형은 걸어갈 수 있는 사각형이다.두 정사각형이 같은 섬에 있으려면, 한 정사각형에서 다른 정사각형으로 걸어서 갈 수 있는 경로가 있어야 한다. 지도는 바다로 둘러싸여 있으며, 지도 밖으로 나갈 수 없다.입력입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스의 첫째 줄에는 지도의 너비 w와 높이 h가 주어진다. w와 h는 50보다 작거나 같은 양의 정수이다.둘째 줄부터 h개 줄에는 지도가 주어진다. 1은 땅, 0은 바다이다.입력의 마지막 줄에는 0이 두 개 주어진다.출력각 테스트 케이스에 대해서, 섬의 개수를 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;// mapint n, m;int map[55][55];bool visited[55][55];// joy 대각선 int dy[] = {-1, 0, 1, 0, -1, -1, 1, 1};int dx[] = {0, 1, 0, -1, 1, -1, -1, 1};// ans int ans;void dfs(int y, int x){ visited[y][x] = 1; for(int i=0; i &amp;lt; 8; i++) { int ny = y + dy[i]; int nx = x + dx[i]; if(ny &amp;lt; 0 || nx &amp;lt; 0 || ny &amp;gt;= n || nx &amp;gt;= m) continue; if(!visited[ny][nx] &amp;amp;&amp;amp; map[ny][nx]) dfs(ny, nx); } return;}int main(){ while(1) { cin &amp;gt;&amp;gt; m &amp;gt;&amp;gt; n; if(!n &amp;amp;&amp;amp; !m) break; else { ans = 0; for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; m; j++) cin &amp;gt;&amp;gt; map[i][j]; for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; m; j++) if(!visited[i][j] &amp;amp;&amp;amp; map[i][j]) { ans++; dfs(i, j); } cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl; fill(&amp;amp;visited[0][0], &amp;amp;visited[n][m], 0); fill(&amp;amp;map[0][0], &amp;amp;map[n][m], 0); } } return 0;}SOLdfs로 풀 수 있는 문제로 기존과 다르게 대각선 방향의 dy, dx를 추가하면 된다.Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startDFS 깊이 우선 탐색" }, { "title": "BOJ - 14620 - 꽃길", "url": "/posts/BOJ-14620/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, graph, bruteforce", "date": "2022-10-04 11:10:00 +0900", "snippet": "BOJ - 14620 - 꽃길문제14620번: 꽃길문제문제2017년 4월 5일 식목일을 맞이한 진아는 나무를 심는 대신 하이테크관 앞 화단에 꽃을 심어 등교할 때 마다 꽃길을 걷고 싶었다.진아가 가진 꽃의 씨앗은 꽃을 심고나면 정확히 1년후에 꽃이 피므로 진아는 다음해 식목일 부터 꽃길을 걸을 수 있다.하지만 진아에게는 꽃의 씨앗이 세개밖에 없었으므로 세 개의 꽃이 하나도 죽지 않고 1년후에 꽃잎이 만개하길 원한다.꽃밭은 N*N의 격자 모양이고 진아는 씨앗을 (1,1)~(N,N)의 지점 중 한곳에 심을 수 있다. 꽃의 씨앗은 그림 (a)처럼 심어지며 1년 후 꽃이 피면 그림 (b)모양이 된다.꽃을 심을 때는 주의할 점이있다. 어떤 씨앗이 꽃이 핀 뒤 다른 꽃잎(혹은 꽃술)과 닿게 될 경우 두 꽃 모두 죽어버린다. 또 화단 밖으로 꽃잎이 나가게 된다면 그 꽃은 죽어버리고 만다.그림(c)는 세 꽃이 정상적으로 핀 모양이고 그림(d)는 두 꽃이 죽어버린 모양이다.하이테크 앞 화단의 대여 가격은 격자의 한 점마다 다르기 때문에 진아는 서로 다른 세 씨앗을 모두 꽃이 피게하면서 가장 싼 가격에 화단을 대여하고 싶다.단 화단을 대여할 때는 꽃잎이 핀 모양을 기준으로 대여를 해야하므로 꽃 하나당 5평의 땅을 대여해야만 한다.돈이 많지 않은 진아를 위하여 진아가 꽃을 심기 위해 필요한 최소비용을 구해주자!입력입력의 첫째 줄에 화단의 한 변의 길이 N(6≤N≤10)이 들어온다.이후 N개의 줄에 N개씩 화단의 지점당 가격(0≤G≤200)이 주어진다.출력꽃을 심기 위한 최소 비용을 출력한다.구현#include &amp;lt;iostream&amp;gt;using namespace std;// mapint map[11][11];bool visited[11][11];int n;// joy int dy[] = {-1, 0, 1, 0};int dx[] = {0, 1, 0, -1};// ansint cnt;int ans = 999999999;// check bool check(int y, int x){ if(visited[y][x]) return 0; for(int i=0; i &amp;lt; 4; i++) { int ny = y + dy[i]; int nx = x + dx[i]; if(ny &amp;lt; 0 || ny &amp;gt;= n || nx &amp;lt; 0 || nx &amp;gt;= n) return 0; if(visited[ny][nx]) return 0; } return 1;}// seed int seed(int y, int x){ visited[y][x] = 1; int tmp = map[y][x]; for(int i=0; i &amp;lt; 4; i++) { int ny = y + dy[i]; int nx = x + dx[i]; visited[ny][nx] = 1; tmp += map[ny][nx]; } return tmp;}void delseed(int y, int x){ visited[y][x] = 0; for(int i=0; i &amp;lt; 4; i++) { int ny = y + dy[i]; int nx = x + dx[i]; visited[ny][nx] = 0; }}void solution(int cnt, int money){ if(cnt == 3) { ans = min(money, ans); return; } for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; n; j++) { if(check(i, j)) { solution(cnt+1, money + seed(i, j)); delseed(i, j); } }}int main(){ cin &amp;gt;&amp;gt; n; for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; n; j++) cin &amp;gt;&amp;gt; map[i][j]; solution(0, 0); cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl; return 0;}SOL 꽃을 심을 수 있는지 판단하고 심을 수 있다면 씨앗을 심고, 최솟 값을 구한 뒤 아님말고를 시전한다. (심었던 씨앗을 다시 뽑는다. ) for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; n; j++) { if(check(i, j)) { solution(cnt+1, money + seed(i, j)); delseed(i, j); } } Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 start" }, { "title": "BOJ - 9934 - 완전 이진 트리", "url": "/posts/BOJ-9934/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, graph, binarytree", "date": "2022-09-30 11:10:00 +0900", "snippet": "BOJ - 9934 - 완전 이진 트리문제9934번: 완전 이진 트리문제상근이는 슬로베니아의 도시 Donji Andrijevci를 여행하고 있다. 이 도시의 도로는 깊이가 K인 완전 이진 트리를 이루고 있다. 깊이가 K인 완전 이진 트리는 총 2K-1개의 노드로 이루어져 있다. (아래 그림) 각 노드에는 그 곳에 위치한 빌딩의 번호가 붙여져 있다. 또, 가장 마지막 레벨을 제외한 모든 집은 왼쪽 자식과 오른쪽 자식을 갖는다.깊이가 2와 3인 완전 이진 트리상근이는 도시에 있는 모든 빌딩에 들어갔고, 들어간 순서대로 번호를 종이에 적어 놓았다. 한국으로 돌아온 상근이는 도시가 어떻게 생겼는지 그림을 그려보려고 하였으나, 정확하게 기억이 나지 않아 실패했다. 하지만, 어떤 순서로 도시를 방문했는지 기억해냈다. 가장 처음에 상근이는 트리의 루트에 있는 빌딩 앞에 서있다. 현재 빌딩의 왼쪽 자식에 있는 빌딩에 아직 들어가지 않았다면, 왼쪽 자식으로 이동한다. 현재 있는 노드가 왼쪽 자식을 가지고 있지 않거나 왼쪽 자식에 있는 빌딩을 이미 들어갔다면, 현재 노드에 있는 빌딩을 들어가고 종이에 번호를 적는다. 현재 빌딩을 이미 들어갔다 온 상태이고, 오른쪽 자식을 가지고 있는 경우에는 오른쪽 자식으로 이동한다. 현재 빌딩과 왼쪽, 오른쪽 자식에 있는 빌딩을 모두 방문했다면, 부모 노드로 이동한다.왼쪽 그림에 나와있는 마을이라면, 상근이는 2-1-3 순서대로 빌딩을 들어갔을 것이고, 오른쪽 그림의 경우에는 1-6-4-3-5-2-7 순서로 들어갔을 것이다. 상근이가 종이에 적은 순서가 모두 주어졌을 때, 각 레벨에 있는 빌딩의 번호를 구하는 프로그램을 작성하시오.입력첫째 줄에 K (1 ≤ K ≤ 10)가 주어진다.둘째 줄에는 상근이가 방문한 빌딩의 번호가 들어간 순서대로 주어진다. 모든 빌딩의 번호는 중복되지 않으며, 구간 [1,2K)에 포함된다.출력총 K개의 줄에 걸쳐서 정답을 출력한다. i번째 줄에는 레벨이 i인 빌딩의 번호를 출력한다. 출력은 왼쪽에서부터 오른쪽 순서대로 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;math.h&amp;gt;using namespace std;// treeint num;int n;int arr[1040];vector&amp;lt;int&amp;gt; bytree[1040];// 이진트리 // 2 1 3// 1 // 2 3 void binarytree(int level, int r, int l){ if(r &amp;gt; l) return; // 최 하단 노드일 경우 if(r == l) { bytree[level].push_back(arr[r]); return; } int m = (r + l) / 2; bytree[level].push_back(arr[m]); binarytree(level+1, r, m-1); binarytree(level+1, m+1, l);}int main(){ cin &amp;gt;&amp;gt; num; n = pow(2,num)-1; for(int i=1; i &amp;lt;= n; i++) { int tmp; cin &amp;gt;&amp;gt; tmp; arr[i] = tmp; } binarytree(0, 1, n); for(int i=0; i &amp;lt; n; i++) { for(auto &amp;amp;el : bytree[i]) cout &amp;lt;&amp;lt; el &amp;lt;&amp;lt; &quot; &quot;; cout &amp;lt;&amp;lt; endl; } return 0;}SOL 이진탐색 기법을 이용하면 해결할 수 있다.Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 start" }, { "title": "BOJ - 3197 - 백조의 호수", "url": "/posts/BOJ-3197/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, bfs, graph, 플레티넘", "date": "2022-09-29 11:10:00 +0900", "snippet": "BOJ - 3197 - 백조의 호수문제3197번: 백조의 호수문제두 마리의 백조가 호수에서 살고 있었다. 그렇지만 두 마리는 호수를 덮고 있는 빙판으로 만나지 못한다.호수는 행이 R개, 열이 C개인 직사각형 모양이다. 어떤 칸은 얼음으로 덮여있다.호수는 차례로 녹는데, 매일 물 공간과 접촉한 모든 빙판 공간은 녹는다. 두 개의 공간이 접촉하려면 가로나 세로로 닿아 있는 것만 (대각선은 고려하지 않는다) 생각한다.아래에는 세 가지 예가 있다....XXXXXX..XX.XXX ....XXXX.......XX .....XX..............XXXXXXXXX.XXX .....XXXX..X..... ......X.............XXXXXXXXXXXX.. ....XXX..XXXX.... .....X.....X.......XXXXX..XXXXXX.. ...XXX....XXXX... ....X......XX.....XXXXXX..XXXXXX.. ..XXXX....XXXX... ...XX......XX....XXXXXXX...XXXX... ..XXXX.....XX.... ....X..............XXXXX...XXX.... ....XX.....X..... .....................XXXXX.XXX.... .....XX....X..... ................. 처음 첫째 날 둘째 날백조는 오직 물 공간에서 세로나 가로로만(대각선은 제외한다) 움직일 수 있다.며칠이 지나야 백조들이 만날 수 있는 지 계산하는 프로그램을 작성하시오.입력입력의 첫째 줄에는 R과 C가 주어진다. 단, 1 ≤ R, C ≤ 1500.다음 R개의 줄에는 각각 길이 C의 문자열이 하나씩 주어진다. ’.’은 물 공간, ‘X’는 빙판 공간, ‘L’은 백조가 있는 공간으로 나타낸다.출력첫째 줄에 문제에서 주어진 걸리는 날을 출력한다.구현 - 여러번의 bfs 실행#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;// 빙하부터 녹여보자 // map int n, m;char map[1505][1505];bool visited[1505][1505];bool movevisited[1505][1505];// joy int dy[] = {-1, 0, 1, 0};int dx[] = {0, 1, 0, -1};// ans bool flag = 1;vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; L;int ans = 0;void melt(int y, int x){ visited[y][x] = 1; for(int i=0; i &amp;lt; 4; i++) { int ny = y + dy[i]; int nx = x + dx[i]; if(ny &amp;lt; 0 || ny &amp;gt;= n || nx &amp;lt; 0 || nx &amp;gt;= m) continue; // 방문하지 않았고, 빙판인 경우 if(!visited[ny][nx] &amp;amp;&amp;amp; map[ny][nx] == &#39;X&#39;) melt(ny, nx); // 방문하지 않았고, 호수인 경우 else if(!visited[ny][nx] &amp;amp;&amp;amp; map[ny][nx] == &#39;.&#39;) { visited[ny][nx] = 1; map[y][x] = &#39;.&#39;; } }}void movedfs(int y, int x){ movevisited[y][x] = 1; if(y == L.back().first-1 &amp;amp;&amp;amp; x == L.back().second-1) { flag = 0; return; } for(int i=0; i &amp;lt; 4; i++) { int ny = y + dy[i]; int nx = x + dx[i]; if(ny &amp;lt; 0 || ny &amp;gt;= n || nx &amp;lt; 0 || nx &amp;gt;= m) continue; // 방문하지 않았고, 호수인 경우 if(!movevisited[ny][nx] &amp;amp;&amp;amp; map[ny][nx] == &#39;.&#39;) movedfs(ny, nx); }}int main(){ cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; m; j++) { cin &amp;gt;&amp;gt; map[i][j]; if(map[i][j] == &#39;L&#39;) L.push_back({i, j}); } while(1) { ans++; // 백조 움직이기 movedfs(L.front().first, L.front().second); if(!flag) break; // 빙하 녹이기 for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; m; j++) if(!visited[i][j] &amp;amp;&amp;amp; map[i][j] == &#39;X&#39;) melt(i, j); // map 출력 // for(int i=0; i &amp;lt; n; i++) // { // for(int j=0; j &amp;lt; m; j++) // cout &amp;lt;&amp;lt; map[i][j] &amp;lt;&amp;lt; &#39; &#39;; // cout &amp;lt;&amp;lt; endl; // } // 방문 초기화 fill(&amp;amp;visited[0][0], &amp;amp;visited[n][m], 0); fill(&amp;amp;movevisited[0][0], &amp;amp;movevisited[n][m], 0); } cout &amp;lt;&amp;lt; ans-1 &amp;lt;&amp;lt; endl; // for(int i=0; i &amp;lt; n; i++) // { // for(int j=0; j &amp;lt; m; j++) // cout &amp;lt;&amp;lt; map[i][j] &amp;lt;&amp;lt; &#39; &#39;; // cout &amp;lt;&amp;lt; endl; // } return 0;} 빙하를 녹이는 행위에서 다수의 dfs가 실행 되었는데 이 때문에 시간초과가 발생 하였다. 이를 해결하기 위해 초기화 하지 않고 1회만에 해결할 수 있는 방법이 필요했고 아래와 같이 구현 하였다.구현 - bfs 한번 실행#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std;// map int n, m;char map[1505][1505];bool meltvisited[1505][1505];bool movevisited[1505][1505];// joy int dy[] = {-1, 0, 1, 0};int dx[] = {0, 1, 0, -1};// ans bool flag = 1;int ly, lx;int ans = 0;// qqueue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; meltq;queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; moveq;queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; tmpmelt;queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; tmpmove;void clearQ(queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; &amp;amp;q){ queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; eq; swap(eq, q);}void melt(){ while(meltq.size()) { int y = meltq.front().first; int x = meltq.front().second; meltq.pop(); for(int i=0; i &amp;lt; 4; i++) { int ny = y + dy[i]; int nx = x + dx[i]; if(ny &amp;lt; 0 || ny &amp;gt;= n || nx &amp;lt; 0 || nx &amp;gt;= m) continue; // 방문하지 않았고, 빙판인 경우 else if(!meltvisited[ny][nx] &amp;amp;&amp;amp; map[ny][nx] == &#39;X&#39;) { meltvisited[ny][nx] = 1; map[ny][nx] = &#39;.&#39;; // 임시 큐에 저장 tmpmelt.push({ny, nx}); } } }}void movebfs(){ while(moveq.size()) { int y = moveq.front().first; int x = moveq.front().second; moveq.pop(); for(int i=0; i &amp;lt; 4; i++) { int ny = y + dy[i]; int nx = x + dx[i]; if(ny &amp;lt; 0 || ny &amp;gt;= n || nx &amp;lt; 0 || nx &amp;gt;= m) continue; // 방문하지 않았고, 호수인 경우 if(!movevisited[ny][nx] &amp;amp;&amp;amp; map[ny][nx] == &#39;.&#39;) moveq.push({ny, nx}); // 방문하지 않았고, 빙하인 경우 else if(!movevisited[ny][nx] &amp;amp;&amp;amp; map[ny][nx] == &#39;X&#39;) tmpmove.push({ny, nx}); // 방문하지 않았고, 백조를 만난경우 else if(!movevisited[ny][nx] &amp;amp;&amp;amp; map[ny][nx] == &#39;L&#39;) { flag = 0; return; } movevisited[ny][nx] = 1; } }}int main(){ ios_base :: sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; m; j++) { cin &amp;gt;&amp;gt; map[i][j]; // 백조인 경우 if(map[i][j] == &#39;L&#39;) { ly = i; lx = j; } // 물인 경우 || 백조인 경우 if(map[i][j] == &#39;L&#39; || map[i][j] == &#39;.&#39;) { meltq.push({i, j}); meltvisited[i][j] = 1; } } moveq.push({ly, lx}); movevisited[ly][lx] = 1; while(flag) { // 백조 움직이기 movebfs(); // 빙하 녹이기 melt(); // 버퍼에 담긴 큐 복사 moveq = tmpmove; meltq = tmpmelt; clearQ(tmpmelt); clearQ(tmpmove); ans++; } cout &amp;lt;&amp;lt; ans-1 &amp;lt;&amp;lt; &#39;\\n&#39;; return 0;}SOL 빙판을 녹이는 bfs 함수인 melt, 백조가 수영을 하는 movebfs를 생성 melt bfs : 맵을 입력 받을 때 빙하가 아닌 부분의 좌표를 모두 큐에 담아 넣는다. (( meltq 위에서 담은 큐를 실행 시키고 빙하인 부분을 접하게 되면 임시큐에 넣는다. (( tmpmelt movebfs : 두번째 백조의 위치를 큐에 담아 넣는다. (( moveq 위에 담긴 큐를 bfs 실행시키고 각 경우에 따른 조건문을 실행 시킨다. 물인 경우 - (( moveq push 빙하인 경우 - (( tmpmove push 백조인 경우 - (( 함수 끝내기 임시 큐와 버퍼를 만들어 해결해야 하는 문제다. 앞으로 분리 집합과 같은 문제는 위 개념을 이용하면 될듯 싶다.Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startBFS 너비 우선 탐색DFS 깊이 우선 탐색" }, { "title": "BOJ - 1987 - 알파벳", "url": "/posts/BOJ-1987/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, dfs, graph, 백트래킹", "date": "2022-09-29 11:10:00 +0900", "snippet": "BOJ - 1987 - 알파벳문제1987번: 알파벳문제세로 R칸, 가로 C칸으로 된 표 모양의 보드가 있다. 보드의 각 칸에는 대문자 알파벳이 하나씩 적혀 있고, 좌측 상단 칸 (1행 1열) 에는 말이 놓여 있다.말은 상하좌우로 인접한 네 칸 중의 한 칸으로 이동할 수 있는데, 새로 이동한 칸에 적혀 있는 알파벳은 지금까지 지나온 모든 칸에 적혀 있는 알파벳과는 달라야 한다. 즉, 같은 알파벳이 적힌 칸을 두 번 지날 수 없다.좌측 상단에서 시작해서, 말이 최대한 몇 칸을 지날 수 있는지를 구하는 프로그램을 작성하시오. 말이 지나는 칸은 좌측 상단의 칸도 포함된다.입력첫째 줄에 R과 C가 빈칸을 사이에 두고 주어진다. (1 ≤ R,C ≤ 20) 둘째 줄부터 R개의 줄에 걸쳐서 보드에 적혀 있는 C개의 대문자 알파벳들이 빈칸 없이 주어진다.출력첫째 줄에 말이 지날 수 있는 최대의 칸 수를 출력한다.구현#include &amp;lt;iostream&amp;gt;using namespace std;// mapchar map[22][22];// 알파뱃 방문 유무 bool alpa[26];int n, m;// joy int dy[] = {-1, 0, 1, 0};int dx[] = {0, 1, 0, -1};// ans int ans = 0;void dfs(int y, int x, int cnt){ ans = max(cnt, ans); for(int i=0; i &amp;lt; 4; i++) { int ny = y + dy[i]; int nx = x + dx[i]; if(ny &amp;lt; 0 || ny &amp;gt;= n || nx &amp;lt; 0 || nx &amp;gt;= m) continue; int next = int(map[ny][nx] - &#39;A&#39;); if(!alpa[next]) { alpa[next] = 1; dfs(ny, nx, cnt+1); alpa[next] = 0; } } return;}int main(){ cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; for(int i=0; i &amp;lt; n; i++) { string str; cin &amp;gt;&amp;gt; str; for(int j=0; j &amp;lt; m; j++) map[i][j] = str[j]; } int first = int(map[0][0] - &#39;A&#39;); alpa[first] = 1; dfs(0, 0, 1); cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl; return 0;}SOL 백트레킹 문제로 재귀로서의 호출이 끝나게 되면 과거의 노드로 돌아가 다른 방향으로 다시 실행 시켜 해결한다 if(!alpa[next]) { alpa[next] = 1; dfs(ny, nx, cnt+1); alpa[next] = 0; } Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startDFS 깊이 우선 탐색" }, { "title": "BOJ - 14497 - 주난의 난(難)", "url": "/posts/BOJ-14497/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, bfs, graph", "date": "2022-09-28 11:10:00 +0900", "snippet": "BOJ - 14497 - 주난의 난(難)문제14497번: 주난의 난(難)문제주난이는 크게 화가 났다. 책상 서랍 안에 몰래 먹으려고 숨겨둔 초코바가 사라졌기 때문이다. 주난이는 미쳐 날뛰기 시작했다. 사실, 진짜로 뛰기 시작했다.‘쿵… 쿵…’주난이는 점프의 파동으로 주변의 모든 친구들을 쓰러뜨리고(?) 누군가 훔쳐간 초코바를 찾으려고 한다. 주난이는 N×M크기의 학교 교실 어딘가에서 뛰기 시작했다. 주난이의 파동은 상하좌우 4방향으로 친구들을 쓰러뜨릴(?) 때 까지 계속해서 퍼져나간다. 다르게 표현해서, 한 번의 점프는 한 겹의 친구들을 쓰러뜨린다. 다음의 예를 보자.1 # 1 0 1 1 11 1 0 1 0 0 10 0 1 * 1 1 11 1 0 1 1 1 10 0 1 1 0 0 1주난이를 뜻하는 *은 (3, 4)에 있고, 초코바를 가진 학생 #는 (1, 2)에 있다. 0은 장애물이 없는 빈 공간임을 뜻하고, 1은 친구들이 서있음을 의미한다. 다음은 주난이의 점프에 따른 생존(?) 학생들의 변화이다.1 # 1 0 1 1 11 1 0 0 0 0 10 0 0 * 0 1 11 1 0 0 1 1 10 0 1 1 0 0 11 # 0 0 0 0 10 0 0 0 0 0 00 0 0 * 0 0 10 0 0 0 0 1 10 0 0 0 0 0 10 X 0 0 0 0 00 0 0 0 0 0 00 0 0 * 0 0 00 0 0 0 0 0 10 0 0 0 0 0 0위의 예시에서 주난이는 3번의 점프 만에 초코바를 훔쳐간 범인을 찾아낼 수 있다!주난이를 빨리 멈춰야 교실의 안녕을 도모할 수 있다. 주난이에게 최소 점프 횟수를 알려줘서 교실을 지키자.입력첫째 줄에 주난이가 위치한 교실의 크기 N, M이 주어진다. (1 ≤ N, M ≤ 300)둘째 줄에 주난이의 위치 x1, y1과 범인의 위치 x2, y2가 주어진다. (1 ≤ x1, x2 ≤ N, 1 ≤ y1, y2 ≤ M)이후 N×M 크기의 교실 정보가 주어진다. 0은 빈 공간, 1은 친구, *는 주난, #는 범인을 뜻한다.출력주난이가 범인을 잡기 위해 최소 몇 번의 점프를 해야 하는지 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std;// mapchar map[505][505];bool visited[505][505];int n, m;// 주난, 초콜릿 좌표int jx, jy;int cx, cy;// joyint dy[] = {-1, 0, 1, 0};int dx[] = {0, 1, 0, -1};// ansbool flag = 1;int ans = 0;void bfs(int sy, int sx){ visited[sy][sx] = 1; // 초콜릿에 도착하면 queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; q; q.push({sy, sx}); visited[sy][sx] = 1; while(q.size()) { int y = q.front().first; int x = q.front().second; q.pop(); for(int i=0; i &amp;lt; 4; i++) { int ny = y + dy[i]; int nx = x + dx[i]; if(ny &amp;lt; 0 || ny &amp;gt;= n || nx &amp;lt; 0 || nx &amp;gt;= m) continue; // 벽이 아니고, 방문하지 않았더라면 if(map[ny][nx] == &#39;0&#39; &amp;amp;&amp;amp; !visited[ny][nx]) { visited[ny][nx] = 1; q.push({ny, nx}); } // 벽이고, 방문하지 않았더라면 else if((map[ny][nx] == &#39;1&#39; || map[ny][nx] == &#39;#&#39;) &amp;amp;&amp;amp; !visited[ny][nx]) { map[ny][nx] = &#39;0&#39;; visited[ny][nx] = 1; continue; } } }}int main(){ cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; cin &amp;gt;&amp;gt; jy &amp;gt;&amp;gt; jx &amp;gt;&amp;gt; cy &amp;gt;&amp;gt; cx; for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; m; j++) cin &amp;gt;&amp;gt; map[i][j]; if(jy == cy &amp;amp;&amp;amp; jx == cx) cout &amp;lt;&amp;lt; 0 &amp;lt;&amp;lt; endl; else { while(1) { flag = 0; bfs(jy-1, jx-1); for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; m; j++) if(map[i][j] == &#39;#&#39;) flag = 1; fill(&amp;amp;visited[0][0], &amp;amp;visited[n][m], 0); // cout &amp;lt;&amp;lt; &quot; ---- &quot; &amp;lt;&amp;lt; endl; // for(int i=0; i &amp;lt; n; i++) // { // for(int j=0; j &amp;lt; m; j++) // cout &amp;lt;&amp;lt; map[i][j] &amp;lt;&amp;lt; &quot; &quot;; // cout &amp;lt;&amp;lt; endl; // } if(flag) ans++; else break; } cout &amp;lt;&amp;lt; ans+1 &amp;lt;&amp;lt; endl; } return 0;}SOL 주난이가 있는 곳에서 bfs 초콜릿이 사라졌는지 확인 방문 초기화Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startBFS 너비 우선 탐색" }, { "title": "BOJ - 13913 - 숨바꼭질 4", "url": "/posts/BOJ-13913/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, bfs, graph, dp", "date": "2022-09-23 11:10:00 +0900", "snippet": "BOJ - 13913 - 숨바꼭질 4문제13913번: 숨바꼭질 4문제수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다.수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.입력첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.출력첫째 줄에 수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.둘째 줄에 어떻게 이동해야 하는지 공백으로 구분해 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;// traceconst int MAX = 200005;int trace[MAX];int visited[MAX];int n, m;vector&amp;lt;int&amp;gt; v;void bfs(int idx){ queue&amp;lt;int&amp;gt; q; q.push(idx); visited[idx] = 1; trace[idx] = 1; while(q.size()) { int t = q.front(); q.pop(); if(t == m) { cout &amp;lt;&amp;lt; visited[t] - 1 &amp;lt;&amp;lt; endl; break; } for(auto &amp;amp;el : {t-1, t+1, t*2}) if(el &amp;gt;= 0 &amp;amp;&amp;amp; el &amp;lt; MAX) if(!visited[el]) { q.push(el); trace[el] = t; visited[el] = visited[t] + 1; } } for(int i=m; i != n; i = trace[i]) v.push_back(i); v.push_back(n); reverse(v.begin(), v.end());}int main(){ cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; bfs(n); for(auto &amp;amp;el : v) cout &amp;lt;&amp;lt; el &amp;lt;&amp;lt; &quot; &quot;; cout &amp;lt;&amp;lt; endl; return 0;}SOL map 즉, 그래프를 구현하되 조건을 방문하지 않고, 최댓값을 넘기지 않았을 경우 bfs 함수를 호출해 준다. trace 배열을 만들어 최단경로의 흔적을 표현한다. // 시작지점부터 도착지점이 아니면 반복 for(int i=m; i != n; i = trace[i]) v.push_back(i); v.push_back(n); Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startBFS 너비 우선 탐색" }, { "title": "BOJ - 13549 - 숨바꼭질 3", "url": "/posts/BOJ-13549/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, bfs, graph, dp", "date": "2022-09-23 11:10:00 +0900", "snippet": "BOJ - 13549 - 숨바꼭질 3문제13549번: 숨바꼭질 3문제수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 0초 후에 2*X의 위치로 이동하게 된다.수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.입력첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.출력수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;deque&amp;gt;using namespace std;// mapconst int MAX = 200004;int visited[MAX];int n, m, ans;void bfs(int idx){ deque&amp;lt;int&amp;gt; dq; dq.push_back(idx); visited[idx] = 1; while(dq.size()) { int t = dq.front(); dq.pop_front(); if(t == m) { ans = visited[t]; break; } if(!visited[t*2] &amp;amp;&amp;amp; t*2 &amp;gt;= 0 &amp;amp;&amp;amp; t*2 &amp;lt;= MAX) { visited[t*2] = visited[t]; dq.push_front(t*2); } for(auto &amp;amp;el : {t+1, t-1}) if(el &amp;gt;= 0 &amp;amp;&amp;amp; el &amp;lt;= MAX) if(!visited[el]) { visited[el] = visited[t] + 1; dq.push_back(el); } }}int main(){ cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; bfs(n); cout &amp;lt;&amp;lt; ans-1 &amp;lt;&amp;lt; endl; return 0;}SOL map 즉, 그래프를 구현하되 조건을 방문하지 않고, 최댓값을 넘기지 않았을 경우 bfs 함수를 호출해 준다. deque로 우선순위 큐를 만들어 주어 조건의 우선순위로 두어야 하는 순간이동 부분의 긴능을 우선시하게 한다.Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startBFS 너비 우선 탐색" }, { "title": "BOJ - 1697 - 숨바꼭질", "url": "/posts/BOJ-11697/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, bfs, graph, dp", "date": "2022-09-21 11:10:00 +0900", "snippet": "BOJ - 1697 - 숨바꼭질문제1697번: 숨바꼭질문제수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다.수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.입력첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.출력수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std;const int mx = 200004;// mapint map[mx];int visited[mx];// ansint n, m;int ans = 0;void bfs(int idx){ queue&amp;lt;int&amp;gt; q; q.push(idx); visited[idx] = 1; while(q.size()) { int t = q.front(); q.pop(); // 걷기 if(t == m) { ans = visited[t]; break; } int nt_under = t - 1; int nt_over = t + 1; // 순간이동 int nt_tel = t * 2; if(!visited[nt_under] &amp;amp;&amp;amp; nt_under &amp;lt; mx) { visited[nt_under] = visited[t] + 1; q.push(nt_under); } if(!visited[nt_over] &amp;amp;&amp;amp; nt_over &amp;lt; mx) { visited[nt_over] = visited[t] + 1; q.push(nt_over); } if(!visited[nt_tel] &amp;amp;&amp;amp; nt_tel &amp;lt; mx) { visited[nt_tel] = visited[t] + 1; q.push(nt_tel); } }}int main(){ cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; bfs(n); cout &amp;lt;&amp;lt; ans-1 &amp;lt;&amp;lt; endl; return 0;}SOL map 즉, 그래프를 구현하되 조건을 방문하지 않고, 최댓값을 넘기지 않았을 경우 bfs 함수를 호출해 준다.Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startBFS 너비 우선 탐색" }, { "title": "BOJ - 12851 - 숨바꼭질 2", "url": "/posts/BOJ-12851/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, bfs, graph, dp", "date": "2022-09-20 11:10:00 +0900", "snippet": "BOJ - 12851 - 숨바꼭질 2문제12851번: 숨바꼭질 2문제수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다.수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 그리고, 가장 빠른 시간으로 찾는 방법이 몇 가지 인지 구하는 프로그램을 작성하시오.입력첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.출력첫째 줄에 수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.둘째 줄에는 가장 빠른 시간으로 수빈이가 동생을 찾는 방법의 수를 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std;const int mx = 200004;// mapint map[mx];int visited[mx];// ansint n, m;int ans = 0;int cnt = 0;void bfs(int idx){ queue&amp;lt;int&amp;gt; q; q.push(idx); visited[idx] = 1; map[idx] = 1; while(q.size()) { int t = q.front(); q.pop(); // 걷기 if(t == m) { ans = visited[t]; cnt = map[t]; break; } for(auto &amp;amp;el : {t+1, t-1, t*2}) { // 범위에 충족하고 if(el &amp;gt;= 0 &amp;amp;&amp;amp; el &amp;lt; mx) { // 방문하지 않았더라면 if(!visited[el]) { q.push(el); // 가산 최단거리 visited[el] = visited[t] + 1; // 경로 횟수 map[el] += map[t]; } // 이미 방문을 한 상태에서 최단 거리는 같은데 경로가 다를 경우 else if(visited[el] == visited[t] + 1) map[el] += map[t]; } } }}int main(){ cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; bfs(n); cout &amp;lt;&amp;lt; ans-1 &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; cnt &amp;lt;&amp;lt; endl; return 0;}SOL map 즉, 그래프를 구현하되 조건을 방문하지 않고, 최댓값을 넘기지 않았을 경우 bfs 함수를 호출해 준다. 최단 거리의 경로수는 추가적인 조건문을 만들어 해결한다. 이미 방문을 한 상태에서 앞으로 갈 경로의 가산값과 지금 현재위치에서의 가산 값이 같을 경우 Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startBFS 너비 우선 탐색" }, { "title": "BOJ - 1463 - 1로 만들기", "url": "/posts/BOJ-1463/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, bfs, graph, dp", "date": "2022-09-20 11:10:00 +0900", "snippet": "BOJ - 1463 - 1로 만들기문제1463번: 1로 만들기문제정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다. X가 3으로 나누어 떨어지면, 3으로 나눈다. X가 2로 나누어 떨어지면, 2로 나눈다. 1을 뺀다.정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.입력첫째 줄에 1보다 크거나 같고, 106보다 작거나 같은 정수 N이 주어진다.출력첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std;// maplong long map[1000004];long long visited[1000004];// joyint t;int ans;// bfsvoid bfs(int sidx){ queue&amp;lt;int&amp;gt; q; q.push(sidx); visited[sidx] = 1; while(q.size()) { t = q.front(); q.pop(); if(t == 1) { ans = visited[t]; break; } int nt3 = (t%3 == 0) ? t/3 : t; int nt2 = (t%2 == 0) ? t/2 : t; int nt1 = t-1; if(!visited[nt3]) { visited[nt3] = visited[t] + 1; q.push(nt3); } if(!visited[nt2]) { visited[nt2] = visited[t] + 1; q.push(nt2); } if(!visited[nt1]) { visited[nt1] = visited[t] + 1; q.push(nt1); } }}int main(){ int tmp; cin &amp;gt;&amp;gt; tmp; bfs(tmp); cout &amp;lt;&amp;lt; ans-1 &amp;lt;&amp;lt; endl; return 0;}SOL 위 dp문제는 재귀로도 해결할 수 있지만 bfs를 통해서도 해결할 수 있다.Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startBFS 너비 우선 탐색" }, { "title": "BOJ - 16933 - 벽 부수고 이동하기 3", "url": "/posts/BOJ-16933/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, bfs, graph", "date": "2022-09-20 11:10:00 +0900", "snippet": "BOJ - 16933 - 벽 부수고 이동하기 3문제16933번: 벽 부수고 이동하기 3문제N×M의 행렬로 표현되는 맵이 있다. 맵에서 0은 이동할 수 있는 곳을 나타내고, 1은 이동할 수 없는 벽이 있는 곳을 나타낸다. 당신은 (1, 1)에서 (N, M)의 위치까지 이동하려 하는데, 이때 최단 경로로 이동하려 한다. 최단경로는 맵에서 가장 적은 개수의 칸을 지나는 경로를 말하는데, 이때 시작하는 칸과 끝나는 칸도 포함해서 센다. 이동하지 않고 같은 칸에 머물러있는 경우도 가능하다. 이 경우도 방문한 칸의 개수가 하나 늘어나는 것으로 생각해야 한다.이번 문제에서는 낮과 밤이 번갈아가면서 등장한다. 가장 처음에 이동할 때는 낮이고, 한 번 이동할 때마다 낮과 밤이 바뀌게 된다. 이동하지 않고 같은 칸에 머무르는 경우에도 낮과 밤이 바뀌게 된다.만약에 이동하는 도중에 벽을 부수고 이동하는 것이 좀 더 경로가 짧아진다면, 벽을 K개 까지 부수고 이동하여도 된다. 단, 벽은 낮에만 부술 수 있다.한 칸에서 이동할 수 있는 칸은 상하좌우로 인접한 칸이다.맵이 주어졌을 때, 최단 경로를 구해 내는 프로그램을 작성하시오.입력첫째 줄에 N(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 1,000), K(1 ≤ K ≤ 10)이 주어진다. 다음 N개의 줄에 M개의 숫자로 맵이 주어진다. (1, 1)과 (N, M)은 항상 0이라고 가정하자.출력첫째 줄에 최단 거리를 출력한다. 불가능할 때는 -1을 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;// mapint n, m, num;bool map[1004][1004];// y x bk 밤낮 int visited[1004][1004][11][2];// joy int dy[] = {-1, 0, 1, 0};int dx[] = {0, 1, 0, -1};// ansint ans = 0;void bfs(int sy, int sx, int sbk, int sbn){ queue&amp;lt;pair&amp;lt;pair&amp;lt;int, int&amp;gt;, pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt; q; q.push({{sy, sx},{sbk, sbn}}); visited[sy][sx][sbk][sbn] = 1; while(q.size()) { int y = q.front().first.first; int x = q.front().first.second; int bk = q.front().second.first; int bn = q.front().second.second; q.pop(); // 출구에 도착하면 if(y == n-1 &amp;amp;&amp;amp; x == m-1) { ans = visited[y][x][bk][bn]; break; } for(int i=0; i &amp;lt; 4; i++) { int ny = y + dy[i]; int nx = x + dx[i]; if(ny &amp;lt; 0 || nx &amp;lt; 0 || ny &amp;gt;= n || nx &amp;gt;= m) continue; // 낮인데 if(bn == 1) { // 방문하지 않았고, 길인 경우 if(!visited[ny][nx][bk][bn-1] &amp;amp;&amp;amp; !map[ny][nx]) { visited[ny][nx][bk][bn-1] = visited[y][x][bk][bn] + 1; q.push({{ny, nx}, {bk, bn-1}}); } // 방문하지 않았고, 벽인 경우 (단. 벽을 부술 수 있는 경우) else if(bk &amp;amp;&amp;amp; !visited[ny][nx][bk-1][bn-1] &amp;amp;&amp;amp; map[ny][nx]) { visited[ny][nx][bk-1][bn-1] = visited[y][x][bk][bn] + 1; q.push({{ny, nx}, {bk-1, bn-1}}); } } else { // 밤인데 if(!visited[ny][nx][bk][bn+1] &amp;amp;&amp;amp; !map[ny][nx]) { // 방문하지 않았고, 길인경우 visited[ny][nx][bk][bn+1] = visited[y][x][bk][bn] + 1; q.push({{ny, nx}, {bk, bn+1}}); } // 방문하지 않았고, 벽인 경우 (단. 벽을 부술 수 있는 경우) else if(bk &amp;amp;&amp;amp; !visited[ny][nx][bk-1][bn+1] &amp;amp;&amp;amp; map[ny][nx]) { visited[y][x][bk][bn+1] = visited[y][x][bk][bn]+1; q.push({{y, x}, {bk, bn+1}}); } } } }}int main(){ ios_base :: sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; num; for(int i=0; i &amp;lt; n; i++) { string str; cin &amp;gt;&amp;gt; str; for(int j=0; j &amp;lt; m; j++) if(str[j]==&#39;1&#39;) map[i][j] = 1; } bfs(0, 0, num, 1); if(ans) cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; &#39;\\n&#39;; else cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; &#39;\\n&#39;; return 0;}SOL visited를 4차원으로 만들어 bfs를 돌 때 벽을 몇번이나 부쉈는지, 밤인지 낮인지 측정 한다. bfs의 호출 조건을 근접해 있는 좌표가 밤인경우, 낮인 경우 두가지 경우로 조건을 만든다. 밤인경우 벽인경우 증감값을 더해주나 좌표값은 동일하게 길인경우 증감값을 더해주나 좌표값은 다르게 낮인경우 벽인경우 증감값은 더해주고 벽을 부신횟수를 측정 및 감소 증감값을 더해주고 좌표값은 다르게 맵의 도착점에 도달 하였을 때 answer값을 초기화 한다.Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startBFS 너비 우선 탐색" }, { "title": "BOJ - 12869 - 뮤탈리스크", "url": "/posts/BOJ-12869/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, bfs, graph, dp", "date": "2022-09-20 11:10:00 +0900", "snippet": "BOJ - 12869 - 뮤탈 리스크문제12869번: 뮤탈리스크문제수빈이는 강호와 함께 스타크래프트 게임을 하고 있다. 수빈이는 뮤탈리스크 1개가 남아있고, 강호는 SCV N개가 남아있다.각각의 SCV는 남아있는 체력이 주어져있으며, 뮤탈리스크를 공격할 수는 없다. 즉, 이 게임은 수빈이가 이겼다는 것이다.뮤탈리스크가 공격을 할 때, 한 번에 세 개의 SCV를 공격할 수 있다. 첫 번째로 공격받는 SCV는 체력 9를 잃는다. 두 번째로 공격받는 SCV는 체력 3을 잃는다. 세 번째로 공격받는 SCV는 체력 1을 잃는다.SCV의 체력이 0 또는 그 이하가 되어버리면, SCV는 그 즉시 파괴된다. 한 번의 공격에서 같은 SCV를 여러 번 공격할 수는 없다.남아있는 SCV의 체력이 주어졌을 때, 모든 SCV를 파괴하기 위해 공격해야 하는 횟수의 최솟값을 구하는 프로그램을 작성하시오.입력첫째 줄에 SCV의 수 N (1 ≤ N ≤ 3)이 주어진다. 둘째 줄에는 SCV N개의 체력이 주어진다. 체력은 60보다 작거나 같은 자연수이다.출력첫째 줄에 모든 SCV를 파괴하기 위한 공격 횟수의 최솟값을 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std;// mapint n, m, num;int map[64][64][64];int visited[64][64][64];//joyint dz[] = {9, 9, 3, 3, 1, 1};int dy[] = {3, 1, 1, 9, 9, 3};int dx[] = {1, 3, 9, 1, 3, 9};//unitint unit[3];void bfs(int sz, int sy, int sx){ queue&amp;lt;pair&amp;lt;pair&amp;lt;int, int&amp;gt;, int&amp;gt;&amp;gt; q; q.push({{sz, sy}, sx}); visited[sz][sy][sx] = 1; while(q.size()) { int z = q.front().first.first; int y = q.front().first.second; int x = q.front().second; q.pop(); if(visited[0][0][0]) break; for(int i=0; i &amp;lt; 6; i++) { // 0이되면 죽은것이기 때문 int nz = max(0, z - dz[i]); int ny = max(0, y - dy[i]); int nx = max(0, x - dx[i]); if(visited[nz][ny][nx]) continue; visited[nz][ny][nx] = visited[z][y][x] + 1; q.push({{nz, ny}, nx}); } }}int main(){ cin &amp;gt;&amp;gt; num; for(int i=0; i &amp;lt; num; i++) cin &amp;gt;&amp;gt; unit[i]; bfs(unit[0], unit[1], unit[2]); cout &amp;lt;&amp;lt; visited[0][0][0]-1 &amp;lt;&amp;lt; endl; return 0;}SOL 이런 dp문제는 이전의 dfs, bfs의 기본 문제인 map 형태의 변수의 개수를 생각해보면 된다. ex) x, y로 이루어진 map 의 변수의 개수는 2개 즉 위 문제의 변수의 개수는 scv의 개수인 3개 (x, y, z)인 것이다. Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startBFS 너비 우선 탐색" }, { "title": "BOJ - 16234 - 인구 이동", "url": "/posts/BOJ-16234/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, dfs, graph", "date": "2022-09-19 11:10:00 +0900", "snippet": "BOJ - 16234 - 인구이동문제16234번: 인구 이동문제N×N크기의 땅이 있고, 땅은 1×1개의 칸으로 나누어져 있다. 각각의 땅에는 나라가 하나씩 존재하며, r행 c열에 있는 나라에는 A[r][c]명이 살고 있다. 인접한 나라 사이에는 국경선이 존재한다. 모든 나라는 1×1 크기이기 때문에, 모든 국경선은 정사각형 형태이다.오늘부터 인구 이동이 시작되는 날이다.인구 이동은 하루 동안 다음과 같이 진행되고, 더 이상 아래 방법에 의해 인구 이동이 없을 때까지 지속된다. 국경선을 공유하는 두 나라의 인구 차이가 L명 이상, R명 이하라면, 두 나라가 공유하는 국경선을 오늘 하루 동안 연다. 위의 조건에 의해 열어야하는 국경선이 모두 열렸다면, 인구 이동을 시작한다. 국경선이 열려있어 인접한 칸만을 이용해 이동할 수 있으면, 그 나라를 오늘 하루 동안은 연합이라고 한다. 연합을 이루고 있는 각 칸의 인구수는 (연합의 인구수) / (연합을 이루고 있는 칸의 개수)가 된다. 편의상 소수점은 버린다. 연합을 해체하고, 모든 국경선을 닫는다.각 나라의 인구수가 주어졌을 때, 인구 이동이 며칠 동안 발생하는지 구하는 프로그램을 작성하시오.입력첫째 줄에 N, L, R이 주어진다. (1 ≤ N ≤ 50, 1 ≤ L ≤ R ≤ 100)둘째 줄부터 N개의 줄에 각 나라의 인구수가 주어진다. r행 c열에 주어지는 정수는 A[r][c]의 값이다. (0 ≤ A[r][c] ≤ 100)인구 이동이 발생하는 일수가 2,000번 보다 작거나 같은 입력만 주어진다.출력인구 이동이 며칠 동안 발생하는지 첫째 줄에 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;// mapint N;int map[55][55];int tmpmap[55][55];int visited[55][55];// joyint dy[] = {-1, 0, 1, 0};int dx[] = {0, 1, 0, -1};int y, x;// 국경이 열려있는 곳의 좌표 벡터vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; v;// 인구 차 기준 int mn, mx;int sub;// 열린 국가들의 인구 합int sum; int num=1;// ans int ans = 0;int answer = 0;bool flag = 0;void dfs(int y, int x){ visited[y][x] = 1; sum += map[y][x]; num++; // 국경이 열린 죄표 저장 v.push_back({y, x}); for(int i=0; i &amp;lt; 4; i++) { int ny = y + dy[i]; int nx = x + dx[i]; if(ny &amp;lt; 0 || nx &amp;lt; 0 || ny &amp;gt;= N || nx &amp;gt;= N) continue; // 인구차 sub = abs(map[y][x] - map[ny][nx]); // 방문하지 않고, 국경이 열리는 조건일 경우 if(!visited[ny][nx] &amp;amp;&amp;amp; sub &amp;gt;= mn &amp;amp;&amp;amp; sub &amp;lt;= mx) { flag = 1; dfs(ny, nx); } } return;}int main(){ cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; mn &amp;gt;&amp;gt; mx; for(int i=0; i &amp;lt; N; i++) for(int j=0; j &amp;lt; N; j++) cin &amp;gt;&amp;gt; map[i][j]; while(1) { flag = 0; for(int i=0; i &amp;lt; N; i++) { for(int j=0; j &amp;lt; N; j++) { tmpmap[i][j] = map[i][j]; sum = 0; num = 0; if(!visited[i][j]) { dfs(i, j); int tmp = sum / num; // 인구 이동을 해야하는 경우 if(v.size()) { ans++; for(auto &amp;amp;el : v) map[el.first][el.second] = tmp; } v.clear(); } } } fill(&amp;amp;visited[0][0], &amp;amp;visited[N][N], 0); // 인구이동이 있었는가 확인 if(flag == 1) answer++; // 없었다면 종료 if(!flag) break; } cout &amp;lt;&amp;lt; answer &amp;lt;&amp;lt; endl; return 0;}SOL 인구 이동을 해야하는 경우 벡터에 좌표저장 방문하지 않고, 인구 이동이 있을 경우 dfs 호출 및 flag 온 보든 루프를 돌았을 때 flag즉 인구이동이 없다면 종료 및 결과 출력Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startDFS 깊이 우선 탐색" }, { "title": "BOJ - 14442 - 벽 부수고 이동하기 2", "url": "/posts/BOJ-14442/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, bfs, graph", "date": "2022-09-19 11:10:00 +0900", "snippet": "BOJ - 14442 - 벽 부수고 이동하기 2문제14442번: 벽 부수고 이동하기 2문제N×M의 행렬로 표현되는 맵이 있다. 맵에서 0은 이동할 수 있는 곳을 나타내고, 1은 이동할 수 없는 벽이 있는 곳을 나타낸다. 당신은 (1, 1)에서 (N, M)의 위치까지 이동하려 하는데, 이때 최단 경로로 이동하려 한다. 최단경로는 맵에서 가장 적은 개수의 칸을 지나는 경로를 말하는데, 이때 시작하는 칸과 끝나는 칸도 포함해서 센다.만약에 이동하는 도중에 벽을 부수고 이동하는 것이 좀 더 경로가 짧아진다면, 벽을 K개 까지 부수고 이동하여도 된다.한 칸에서 이동할 수 있는 칸은 상하좌우로 인접한 칸이다.맵이 주어졌을 때, 최단 경로를 구해 내는 프로그램을 작성하시오.입력첫째 줄에 N(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 1,000), K(1 ≤ K ≤ 10)이 주어진다. 다음 N개의 줄에 M개의 숫자로 맵이 주어진다. (1, 1)과 (N, M)은 항상 0이라고 가정하자.출력첫째 줄에 최단 거리를 출력한다. 불가능할 때는 -1을 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std;// mapint n, m;bool map[1004][1004];int visited[1004][1004][11];// joyint dy[] = {-1, 0, 1, 0};int dx[] = {0, 1, 0, -1};// 부술 수 있는 벽의 개수 int num;int ans = 0;void bfs(int sy, int sx, int N){ queue&amp;lt;pair&amp;lt;pair&amp;lt;int, int&amp;gt;, int&amp;gt;&amp;gt; q; q.push({{sy, sx}, N}); visited[sy][sx][N] = 1; while(q.size()) { int y = q.front().first.first; int x = q.front().first.second; int bk = q.front().second; q.pop(); if(y == n-1 &amp;amp;&amp;amp; x == m-1) { ans = visited[y][x][bk]; break; } for(int i=0; i &amp;lt; 4; i++) { int ny = y + dy[i]; int nx = x + dx[i]; if(ny &amp;lt; 0 || nx &amp;lt; 0 || ny &amp;gt;= n || nx &amp;gt;= m) continue; // 방문하지 않았고, 길인 경우 if(!visited[ny][nx][bk] &amp;amp;&amp;amp; !map[ny][nx]) { visited[ny][nx][bk] = visited[y][x][bk] + 1; q.push({{ny, nx}, bk}); } // 방문하지 않았고, 벽이고, 부술 수 있는 기회가 있을 경우 if(!visited[ny][nx][bk-1] &amp;amp;&amp;amp; map[ny][nx] &amp;amp;&amp;amp; bk) { visited[ny][nx][bk-1] = visited[y][x][bk] + 1; q.push({{ny, nx}, bk-1}); } } }}int main(){ cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; num; for(int i=0; i &amp;lt; n; i++) { string str; cin &amp;gt;&amp;gt; str; for(int j=0; j &amp;lt; m; j++) if(str[j] == &#39;1&#39;) map[i][j] = 1; } bfs(0, 0, num); if(!ans) cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; endl; else cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl; return 0;}SOL visited를 3차원으로 만들어 bfs를 돌 때 벽을 몇번이나 부쉈는지 측정 한다. bfs의 호출 조건을 근접해 있는 좌표가 벽인경우, 길인 경우 두가지 경우로 조건을 만든다. 방문하지 않았고, 길인 경우 방문하지 않았고, 벽인 경우 맵의 도착점에 도달 하였을 때 answer값을 초기화 한다.Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startBFS 너비 우선 탐색" }, { "title": "BOJ - 1926 - 그림", "url": "/posts/BOJ-1926/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, dfs, graph", "date": "2022-09-18 11:10:00 +0900", "snippet": "BOJ - 1926 - 그림문제1926번: 그림문제어떤 큰 도화지에 그림이 그려져 있을 때, 그 그림의 개수와, 그 그림 중 넓이가 가장 넓은 것의 넓이를 출력하여라. 단, 그림이라는 것은 1로 연결된 것을 한 그림이라고 정의하자. 가로나 세로로 연결된 것은 연결이 된 것이고 대각선으로 연결이 된 것은 떨어진 그림이다. 그림의 넓이란 그림에 포함된 1의 개수이다.입력첫째 줄에 도화지의 세로 크기 n(1 ≤ n ≤ 500)과 가로 크기 m(1 ≤ m ≤ 500)이 차례로 주어진다. 두 번째 줄부터 n+1 줄 까지 그림의 정보가 주어진다. (단 그림의 정보는 0과 1이 공백을 두고 주어지며, 0은 색칠이 안된 부분, 1은 색칠이 된 부분을 의미한다)출력첫째 줄에는 그림의 개수, 둘째 줄에는 그 중 가장 넓은 그림의 넓이를 출력하여라. 단, 그림이 하나도 없는 경우에는 가장 넓은 그림의 넓이는 0이다.구현#include &amp;lt;iostream&amp;gt;using namespace std;// map int n, m;bool map[505][505];bool visited[505][505];// joy int y, x;int dy[] = {-1, 0, 1, 0};int dx[] = {0, 1, 0, -1};// ansint ans = 0;int cnt = 0;int num = 0;void dfs(int y, int x){ visited[y][x] = 1; cnt++; for(int i=0; i &amp;lt; 4; i++) { int ny = y + dy[i]; int nx = x + dx[i]; if(ny &amp;lt; 0 || nx &amp;lt; 0 || ny &amp;gt;= n || nx &amp;gt;= m) continue; if(!visited[ny][nx] &amp;amp;&amp;amp; map[ny][nx]) dfs(ny, nx); } return;}int main(){ cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; m; j++) cin &amp;gt;&amp;gt; map[i][j]; for(int i=0; i &amp;lt; n; i++) { for(int j=0; j &amp;lt; m; j++) { cnt = 0; if(!visited[i][j] &amp;amp;&amp;amp; map[i][j]) { num++; dfs(i, j); ans = max(cnt, ans); } } } cout &amp;lt;&amp;lt; num &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl; return 0;}SOL dfs를 통해 그림의 크기 측정 및, 개수 추출Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startDFS 깊이 우선 탐색" }, { "title": "BOJ - 2589 - 보물섬", "url": "/posts/BOJ-2589/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, bfs, graph", "date": "2022-09-17 11:10:00 +0900", "snippet": "BOJ - 2589 - 보물섬문제2589번: 보물섬문제보물섬 지도를 발견한 후크 선장은 보물을 찾아나섰다. 보물섬 지도는 아래 그림과 같이 직사각형 모양이며 여러 칸으로 나뉘어져 있다. 각 칸은 육지(L)나 바다(W)로 표시되어 있다. 이 지도에서 이동은 상하좌우로 이웃한 육지로만 가능하며, 한 칸 이동하는데 한 시간이 걸린다. 보물은 서로 간에 최단 거리로 이동하는데 있어 가장 긴 시간이 걸리는 육지 두 곳에 나뉘어 묻혀있다. 육지를 나타내는 두 곳 사이를 최단 거리로 이동하려면 같은 곳을 두 번 이상 지나가거나, 멀리 돌아가서는 안 된다.예를 들어 위와 같이 지도가 주어졌다면 보물은 아래 표시된 두 곳에 묻혀 있게 되고, 이 둘 사이의 최단 거리로 이동하는 시간은 8시간이 된다.보물 지도가 주어질 때, 보물이 묻혀 있는 두 곳 간의 최단 거리로 이동하는 시간을 구하는 프로그램을 작성하시오.입력첫째 줄에는 보물 지도의 세로의 크기와 가로의 크기가 빈칸을 사이에 두고 주어진다. 이어 L과 W로 표시된 보물 지도가 아래의 예와 같이 주어지며, 각 문자 사이에는 빈 칸이 없다. 보물 지도의 가로, 세로의 크기는 각각 50이하이다.출력첫째 줄에 보물이 묻혀 있는 두 곳 사이를 최단 거리로 이동하는 시간을 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std;// mapint n, m;bool map[51][51];int visited[51][51];// answervector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; dp;int ans = 0;// joyint dy[] = {-1, 0, 1, 0};int dx[] = {0, 1, 0, -1};void bfs(int sy, int sx){ int cnt = 0; queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; q; q.push({sy, sx}); visited[sy][sx] = 1; while(q.size()) { int y = q.front().first; int x = q.front().second; q.pop(); for(int i=0; i &amp;lt; 4; i++) { int ny = y + dy[i]; int nx = x + dx[i]; if(ny &amp;lt; 0 || ny &amp;gt;= n || nx &amp;lt; 0 || nx &amp;gt;= m) continue; if(!visited[ny][nx] &amp;amp;&amp;amp; !map[ny][nx]) { visited[ny][nx] = visited[y][x] + 1; ans = max(visited[ny][nx], ans); q.push({ny, nx}); } } }}int main(){ cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; // map 입력 for(int i=0; i &amp;lt; n; i++) { string str; cin &amp;gt;&amp;gt; str; for(int j=0; j &amp;lt; m; j++) { map[i][j] = str[j] == &#39;W&#39; ? 1 : 0; if(!map[i][j]) dp.push_back({i, j}); } } for(auto &amp;amp;el : dp) { bfs(el.first, el.second); fill(&amp;amp;visited[0][0], &amp;amp;visited[n][m], 0); } cout &amp;lt;&amp;lt; ans-1 &amp;lt;&amp;lt; endl; return 0;}SOL bfs 함수가 가능한 육지인 좌표를 dp에 저장한다. 위에서 저장한 dp의 값들을 모두 bfs 함수에 싱행시킨다. 각 bfs함수를 실행시킬 때 마다 최솟값을 초기화 한다. 출력Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startBFS 너비 우선 탐색" }, { "title": "BOJ - 6593 - 상범 빌딩", "url": "/posts/BOJ-1189/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, bfs, dfs, graph", "date": "2022-09-16 11:10:00 +0900", "snippet": "BOJ - 1189 - 컴백홈문제1189번: 컴백홈문제한수는 캠프를 마치고 집에 돌아가려 한다. 한수는 현재 왼쪽 아래점에 있고 집은 오른쪽 위에 있다. 그리고 한수는 집에 돌아가는 방법이 다양하다. 단, 한수는 똑똑하여 한번 지나친 곳을 다시 방문하지는 않는다.      cdef  ...f  ..ef  ..gh  cdeh  cdej  ...f      bT..  .T.e  .Td.  .Tfe  bTfg  bTfi  .Tde      a...  abcd  abc.  abcd  a...  a.gh  abc.거리 :  6     6     6     8     8    10    6위 예제는 한수가 집에 돌아갈 수 있는 모든 경우를 나타낸 것이다. T로 표시된 부분은 가지 못하는 부분이다. 문제는 R x C 맵에 못가는 부분이 주어지고 거리 K가 주어지면 한수가 집까지도 도착하는 경우 중 거리가 K인 가짓수를 구하는 것이다.입력첫 줄에 정수 R(1 ≤ R ≤ 5), C(1 ≤ C ≤ 5), K(1 ≤ K ≤ R×C)가 공백으로 구분되어 주어진다. 두 번째부터 R+1번째 줄까지는 R×C 맵의 정보를 나타내는 ‘.’과 ‘T’로 구성된 길이가 C인 문자열이 주어진다.출력첫 줄에 거리가 K인 가짓수를 출력한다.구현#include &amp;lt;iostream&amp;gt;using namespace std;// mapint n, m, num;bool map[10][10];int visited[10][10];// joy int dy[] = {-1, 0, 1, 0};int dx[] = {0, 1, 0, -1};int y, x;// dfsint dfs(int y, int x){ // 기저사례 // 집은 오른쪽 위에 있다. if(y == 0 &amp;amp;&amp;amp; x == m-1) { // 집에 도착하면 if(num == visited[y][x]) return 1; return 0; } int cnt = 0; for(int i=0; i &amp;lt; 4; i++) { int ny = y + dy[i]; int nx = x + dx[i]; if(ny &amp;lt; 0 || ny &amp;gt;= n || nx &amp;lt; 0 || nx &amp;gt;= m) continue; if(!visited[ny][nx] &amp;amp;&amp;amp; !map[ny][nx]) { visited[ny][nx] = visited[y][x] + 1; // 목적지에 도착하면 cnt += dfs(ny, nx); // 지나온 흔적은 지운다. visited[ny][nx] = 0; } } return cnt;}int main(){ cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; num; for(int i=0; i &amp;lt; n; i++) { string str; cin &amp;gt;&amp;gt; str; for(int j=0; j &amp;lt; m; j++) if(str[j] == &#39;T&#39;) map[i][j] = 1; } // 한수는 현재 왼쪽 아래점에 있다. visited[n-1][0] = 1; cout &amp;lt;&amp;lt; dfs(n-1, 0) &amp;lt;&amp;lt; endl;}SOL dfs로 구현하되, bfs와 같이 가중치를 더해준다. 지나온 목적지에 도착 하였을 경우 목적 거리 num와 맞을 경우 return 1 목적 거리 num와 틀린 경우 return 0 Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startBFS 너비 우선 탐색DFS 깊이 우선 탐색" }, { "title": "BOJ - 6593 - 상범 빌딩", "url": "/posts/BOJ-6593/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, bfs, graph", "date": "2022-09-15 11:10:00 +0900", "snippet": "BOJ - 6593 - 상범 빌딩문제6593번: 상범 빌딩문제당신은 상범 빌딩에 갇히고 말았다. 여기서 탈출하는 가장 빠른 길은 무엇일까? 상범 빌딩은 각 변의 길이가 1인 정육면체(단위 정육면체)로 이루어져있다. 각 정육면체는 금으로 이루어져 있어 지나갈 수 없거나, 비어있어서 지나갈 수 있게 되어있다. 당신은 각 칸에서 인접한 6개의 칸(동,서,남,북,상,하)으로 1분의 시간을 들여 이동할 수 있다. 즉, 대각선으로 이동하는 것은 불가능하다. 그리고 상범 빌딩의 바깥면도 모두 금으로 막혀있어 출구를 통해서만 탈출할 수 있다.당신은 상범 빌딩을 탈출할 수 있을까? 만약 그렇다면 얼마나 걸릴까?입력입력은 여러 개의 테스트 케이스로 이루어지며, 각 테스트 케이스는 세 개의 정수 L, R, C로 시작한다. L(1 ≤ L ≤ 30)은 상범 빌딩의 층 수이다. R(1 ≤ R ≤ 30)과 C(1 ≤ C ≤ 30)는 상범 빌딩의 한 층의 행과 열의 개수를 나타낸다.그 다음 각 줄이 C개의 문자로 이루어진 R개의 행이 L번 주어진다. 각 문자는 상범 빌딩의 한 칸을 나타낸다. 금으로 막혀있어 지나갈 수 없는 칸은 ‘#’으로 표현되고, 비어있는 칸은 ‘.’으로 표현된다. 당신의 시작 지점은 ‘S’로 표현되고, 탈출할 수 있는 출구는 ‘E’로 표현된다. 각 층 사이에는 빈 줄이 있으며, 입력의 끝은 L, R, C가 모두 0으로 표현된다. 시작 지점과 출구는 항상 하나만 있다.출력각 빌딩에 대해 한 줄씩 답을 출력한다. 만약 당신이 탈출할 수 있다면 다음과 같이 출력한다. Escaped in x minute(s).여기서 x는 상범 빌딩을 탈출하는 데에 필요한 최단 시간이다.만일 탈출이 불가능하다면, 다음과 같이 출력한다. Trapped!구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std;// map[z][y][x]int n=1, m=1, l=1;bool map[33][33][33];int visited[33][33][33];// joy 상 하 남 동 북 서 int dz[] = {1, -1, 0, 0, 0, 0};int dy[] = {0, 0, -1, 0, 1, 0};int dx[] = {0, 0, 0, 1, 0, -1};int x, y, z;// 시작점, 끝점int sz, sy, sx;int ez, ey, ex;void bfs(int tz, int ty, int tx){ queue&amp;lt;pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt; q; q.push({tz, {ty, tx}}); visited[tz][ty][tx] = 1; while(q.size()) { int z = q.front().first; int y = q.front().second.first; int x = q.front().second.second; q.pop(); for(int i=0; i &amp;lt; 6; i++) { int nz = z + dz[i]; int ny = y + dy[i]; int nx = x + dx[i]; if(nz &amp;lt; 0 || nz &amp;gt;= l || ny &amp;lt; 0 || ny &amp;gt;= n || nx &amp;lt; 0 || nx &amp;gt;= m) continue; if(!visited[nz][ny][nx] &amp;amp;&amp;amp; !map[nz][ny][nx]) { visited[nz][ny][nx] = visited[z][y][x] + 1; q.push({nz, {ny, nx}}); } } }}int main(){ while(m || n || l) { // z y x cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; for(int i=0; i &amp;lt; l; i++) for(int j=0; j &amp;lt; n; j++) for(int k=0; k &amp;lt; m; k++) { char tmp; cin &amp;gt;&amp;gt; tmp; if(tmp == &#39;E&#39;) { ez = i; ey = j; ex = k; } else if(tmp == &#39;S&#39;) { sz = i; sy = j; sx = k; } else if(tmp == &#39;#&#39;) map[i][j][k] = 1; } bfs(sz, sy, sx); // map 출력 // cout &amp;lt;&amp;lt; &quot; ---- &quot; &amp;lt;&amp;lt; endl; // for(int i=0; i &amp;lt; l; i++) // { // for(int j=0; j &amp;lt; n; j++) // { // for(int k=0; k &amp;lt; m; k++) // cout &amp;lt;&amp;lt; visited[i][j][k] &amp;lt;&amp;lt; &quot; &quot;; // cout &amp;lt;&amp;lt; endl; // } // cout &amp;lt;&amp;lt; &quot; ---- &quot; &amp;lt;&amp;lt; endl; // } if(m || n || l) { if(visited[ez][ey][ex]) cout &amp;lt;&amp;lt; &quot;Escaped in &quot; &amp;lt;&amp;lt; visited[ez][ey][ex] - 1 &amp;lt;&amp;lt; &quot; minute(s).&quot; &amp;lt;&amp;lt; endl; else cout &amp;lt;&amp;lt; &quot;Trapped!&quot; &amp;lt;&amp;lt; endl; } fill(&amp;amp;map[0][0][0], &amp;amp;map[l][n][m], 0); fill(&amp;amp;visited[0][0][0], &amp;amp;visited[l][n][m], 0); } return 0;}SOL map[l][m][n] 으로 3차원으로 맵을 설정한다. 상 하 남 동 북 서 순으로 bfs 탐색 이전 bfs와 다른점은 상 하 가 생겻다는 점 Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startBFS 너비 우선 탐색" }, { "title": "BOJ - 2644 - 촌수계산", "url": "/posts/BOJ-2644/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, dfs, graph", "date": "2022-09-13 11:10:00 +0900", "snippet": "BOJ - 2644 - 촌수계산문제2644번: 촌수계산문제우리 나라는 가족 혹은 친척들 사이의 관계를 촌수라는 단위로 표현하는 독특한 문화를 가지고 있다. 이러한 촌수는 다음과 같은 방식으로 계산된다. 기본적으로 부모와 자식 사이를 1촌으로 정의하고 이로부터 사람들 간의 촌수를 계산한다. 예를 들면 나와 아버지, 아버지와 할아버지는 각각 1촌으로 나와 할아버지는 2촌이 되고, 아버지 형제들과 할아버지는 1촌, 나와 아버지 형제들과는 3촌이 된다.여러 사람들에 대한 부모 자식들 간의 관계가 주어졌을 때, 주어진 두 사람의 촌수를 계산하는 프로그램을 작성하시오.입력사람들은 1, 2, 3, …, n (1 ≤ n ≤ 100)의 연속된 번호로 각각 표시된다. 입력 파일의 첫째 줄에는 전체 사람의 수 n이 주어지고, 둘째 줄에는 촌수를 계산해야 하는 서로 다른 두 사람의 번호가 주어진다. 그리고 셋째 줄에는 부모 자식들 간의 관계의 개수 m이 주어진다. 넷째 줄부터는 부모 자식간의 관계를 나타내는 두 번호 x,y가 각 줄에 나온다. 이때 앞에 나오는 번호 x는 뒤에 나오는 정수 y의 부모 번호를 나타낸다.각 사람의 부모는 최대 한 명만 주어진다.출력입력에서 요구한 두 사람의 촌수를 나타내는 정수를 출력한다. 어떤 경우에는 두 사람의 친척 관계가 전혀 없어 촌수를 계산할 수 없을 때가 있다. 이때에는 -1을 출력해야 한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;vector&amp;lt;int&amp;gt; gp[104];bool visited[104];int n, m, num, a, b, c, d;int cnt = 0;int ans;bool flag = 1;void dfs(int idx){ visited[idx] = 1; for(auto &amp;amp;el : gp[idx]) if(!visited[el]) { cnt++; if(el == d) { ans = cnt; flag = 0; return; } dfs(el); // 그래프의 끝점에 다다를 경우 감소 cnt--; } return;}int main(){ cin &amp;gt;&amp;gt; n; cin &amp;gt;&amp;gt; c &amp;gt;&amp;gt; d; cin &amp;gt;&amp;gt; num; for(int i=0; i &amp;lt; num; i++) { cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; gp[a].push_back(b); gp[b].push_back(a); } dfs(c); if(flag) cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; endl; else cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl; return 0;}SOL 양 간선 그래프를 구현한다. 그래프의 끝 점에 다다를 때 감소시켜준다.Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startDFS 깊이 우선 탐색TREE" }, { "title": "BOJ - 1260 - DFS와 BFS", "url": "/posts/BOJ-1260/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, dfs, bfs, graph", "date": "2022-09-09 11:10:00 +0900", "snippet": "BOJ - 1260 - DFS와 BFS문제1260번: DFS와 BFS문제그래프를 DFS로 탐색한 결과와 BFS로 탐색한 결과를 출력하는 프로그램을 작성하시오. 단, 방문할 수 있는 정점이 여러 개인 경우에는 정점 번호가 작은 것을 먼저 방문하고, 더 이상 방문할 수 있는 점이 없는 경우 종료한다. 정점 번호는 1번부터 N번까지이다.입력첫째 줄에 정점의 개수 N(1 ≤ N ≤ 1,000), 간선의 개수 M(1 ≤ M ≤ 10,000), 탐색을 시작할 정점의 번호 V가 주어진다. 다음 M개의 줄에는 간선이 연결하는 두 정점의 번호가 주어진다. 어떤 두 정점 사이에 여러 개의 간선이 있을 수 있다. 입력으로 주어지는 간선은 양방향이다.출력첫째 줄에 DFS를 수행한 결과를, 그 다음 줄에는 BFS를 수행한 결과를 출력한다. V부터 방문된 점을 순서대로 출력하면 된다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std;vector&amp;lt;int&amp;gt; v[1004];bool visited[1004];int n, m, srt, a, b;void dfs(int idx){ visited[idx] = 1; cout &amp;lt;&amp;lt; idx &amp;lt;&amp;lt; &quot; &quot;; for(auto &amp;amp;el : v[idx]) if(!visited[el]) dfs(el);}void bfs(int idx){ queue&amp;lt;int&amp;gt; q; q.push(idx); visited[idx] = 1; while(q.size()) { int y = q.front(); cout &amp;lt;&amp;lt; y &amp;lt;&amp;lt; &quot; &quot;; q.pop(); for(auto &amp;amp;el : v[y]) if(!visited[el]) { visited[el] = 1; q.push(el); } } }int main(){ cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; srt; for(int i=0; i &amp;lt; m; i++) { cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; v[a].push_back(b); v[b].push_back(a); } for(int i=1; i &amp;lt;= n; i++) sort(v[i].begin(), v[i].end()); dfs(srt); cout &amp;lt;&amp;lt; endl; fill(visited, visited + n+1, 0); bfs(srt); cout &amp;lt;&amp;lt; endl; return 0;}SOL 양방향 간선 구현 dfs, bfs 결과 출력Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startBFS 너비 우선 탐색DFS 깊이 우선 탐색" }, { "title": "BOJ - 2606 - 바이러스", "url": "/posts/BOJ-2606/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, dfs, graph", "date": "2022-09-08 11:10:00 +0900", "snippet": "BOJ - 2606 - 바이러스문제2606번: 바이러스문제신종 바이러스인 웜 바이러스는 네트워크를 통해 전파된다. 한 컴퓨터가 웜 바이러스에 걸리면 그 컴퓨터와 네트워크 상에서 연결되어 있는 모든 컴퓨터는 웜 바이러스에 걸리게 된다.예를 들어 7대의 컴퓨터가 &amp;lt;그림 1&amp;gt;과 같이 네트워크 상에서 연결되어 있다고 하자. 1번 컴퓨터가 웜 바이러스에 걸리면 웜 바이러스는 2번과 5번 컴퓨터를 거쳐 3번과 6번 컴퓨터까지 전파되어 2, 3, 5, 6 네 대의 컴퓨터는 웜 바이러스에 걸리게 된다. 하지만 4번과 7번 컴퓨터는 1번 컴퓨터와 네트워크상에서 연결되어 있지 않기 때문에 영향을 받지 않는다.어느 날 1번 컴퓨터가 웜 바이러스에 걸렸다. 컴퓨터의 수와 네트워크 상에서 서로 연결되어 있는 정보가 주어질 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 출력하는 프로그램을 작성하시오.입력첫째 줄에는 컴퓨터의 수가 주어진다. 컴퓨터의 수는 100 이하이고 각 컴퓨터에는 1번 부터 차례대로 번호가 매겨진다. 둘째 줄에는 네트워크 상에서 직접 연결되어 있는 컴퓨터 쌍의 수가 주어진다. 이어서 그 수만큼 한 줄에 한 쌍씩 네트워크 상에서 직접 연결되어 있는 컴퓨터의 번호 쌍이 주어진다.출력1번 컴퓨터가 웜 바이러스에 걸렸을 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 첫째 줄에 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;vector&amp;lt;int&amp;gt; v[104];bool visited[104];int n, m, a, b;int cnt = 0;void dfs(int srt){ cnt++; visited[srt] = 1; for(auto &amp;amp;el : v[srt]) if(!visited[el]) dfs(el); return;}int main(){ cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; for(int i=0; i &amp;lt; m; i++) { cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; v[a].push_back(b); v[b].push_back(a); } dfs(1); cout &amp;lt;&amp;lt; cnt-1 &amp;lt;&amp;lt; endl; return 0;}SOL 양 간선 그래프를 구현한다. 1회 탐색마다 cnt 해준 후 1번 컴퓨터를 제외한 감염된 컴퓨터 수를 출력한다.Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startDFS 깊이 우선 탐색TREE" }, { "title": "BOJ - 24479 - 알고리즘 수업 - 깊이 우선 탐색 1", "url": "/posts/BOJ-24479/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, dfs, graph", "date": "2022-09-07 11:10:00 +0900", "snippet": "BOJ - 24479 - 알고리즘 수업 - 깊이 우선 탐색 1문제24479번 - 알고리즘 수업 - 깊이 우선 탐색 1문제오늘도 서준이는 깊이 우선 탐색(DFS) 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.N개의 정점과 M개의 간선으로 구성된 무방향 그래프(undirected graph)가 주어진다. 정점 번호는 1번부터 N번이고 모든 간선의 가중치는 1이다. 정점 R에서 시작하여 깊이 우선 탐색으로 노드를 방문할 경우 노드의 방문 순서를 출력하자.깊이 우선 탐색 의사 코드는 다음과 같다. 인접 정점은 오름차순으로 방문한다.dfs(V, E, R) { # V : 정점 집합, E : 간선 집합, R : 시작 정점  visited[R] &amp;lt;- YES; # 시작 정점 R을 방문 했다고 표시한다.  for each x ∈ E(R) # E(R) : 정점 R의 인접 정점 집합.(정점 번호를오름차순으로 방문한다) if (visited[x] = NO) then dfs(V, E, x);}입력첫째 줄에 정점의 수 N (5 ≤ N ≤ 100,000), 간선의 수 M (1 ≤ M ≤ 200,000), 시작 정점 R (1 ≤ R ≤ N)이 주어진다.다음 M개 줄에 간선 정보 u* *v*가 주어지며 정점 u와 정점 v의 가중치 1인 양방향 간선을 나타낸다. (1 ≤ u &amp;lt; v ≤ N, u ≠ v) 모든 간선의 (u, v*) 쌍의 값은 서로 다르다.출력첫째 줄부터 N개의 줄에 정수를 한 개씩 출력한다. i번째 줄에는 정점 i의 방문 순서를 출력한다. 시작 정점의 방문 순서는 1이다. 시작 정점에서 방문할 수 없는 경우 0을 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;vector&amp;lt;int&amp;gt; gp[100004];bool visited[100004];int ans[100004];int cnt = 0;void dfs(int idx){ // 방문순서 ans[idx] = ++cnt; visited[idx] = 1; for(auto &amp;amp;el : gp[idx]) if(!visited[el]) dfs(el); return;}int n, m, a, b, srt;int main(){ ios_base :: sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; srt; for(int i=0; i &amp;lt; m; i++) { cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; // 양 방향 간선이기 떄문에 gp[a].push_back(b); gp[b].push_back(a); } for(int i=0; i &amp;lt; n; i++) sort(gp[i].begin(), gp[i].end()); dfs(srt); //cout &amp;lt;&amp;lt; 0 &amp;lt;&amp;lt; &#39;\\n&#39;; for(int i=1; i &amp;lt;= n; i++) cout &amp;lt;&amp;lt; ans[i] &amp;lt;&amp;lt; &#39;\\n&#39;; return 0;}SOL 양 방향 간선 그래프를 구현한다. gp[a].push_back(b); gp[b].push_back(a); 그래프를 정렬한다. 방문 순서를 출력 해야 하기 때문에 가중치를 두어 방문 순서를 저장한다.Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startDFS 깊이 우선 탐색TREE" }, { "title": "BOJ - 2206 - 벽 부수고 이동하기", "url": "/posts/BOJ-24479-copy/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, bfs, graph", "date": "2022-09-07 11:10:00 +0900", "snippet": "BOJ - 2206 - 벽 부수고 이동하기문제2206번: 벽 부수고 이동하기문제N×M의 행렬로 표현되는 맵이 있다. 맵에서 0은 이동할 수 있는 곳을 나타내고, 1은 이동할 수 없는 벽이 있는 곳을 나타낸다. 당신은 (1, 1)에서 (N, M)의 위치까지 이동하려 하는데, 이때 최단 경로로 이동하려 한다. 최단경로는 맵에서 가장 적은 개수의 칸을 지나는 경로를 말하는데, 이때 시작하는 칸과 끝나는 칸도 포함해서 센다.만약에 이동하는 도중에 한 개의 벽을 부수고 이동하는 것이 좀 더 경로가 짧아진다면, 벽을 한 개 까지 부수고 이동하여도 된다.한 칸에서 이동할 수 있는 칸은 상하좌우로 인접한 칸이다.맵이 주어졌을 때, 최단 경로를 구해 내는 프로그램을 작성하시오.입력첫째 줄에 N(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 1,000)이 주어진다. 다음 N개의 줄에 M개의 숫자로 맵이 주어진다. (1, 1)과 (N, M)은 항상 0이라고 가정하자.출력첫째 줄에 최단 거리를 출력한다. 불가능할 때는 -1을 출력한다.구현 - bruteforce#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;// mapint n, m;bool map[1004][1004];int visited[1004][1004];// answervector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; v;int dp[1004];int ans = 9999999;// joy int dy[] = {-1, 0, 1, 0};int dx[] = {0, 1, 0, -1};int x, y;int main(){ ios_base :: sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; for(int i=0; i &amp;lt; n; i++) { string str; cin &amp;gt;&amp;gt; str; for(int j=0; j &amp;lt; m; j++) { if(str[j] == &#39;1&#39;) map[i][j] = 1; // 벽이면 if(map[i][j]) v.push_back({i, j}); } } for(int k=0; k &amp;lt; v.size(); k++) { map[v[k].first][v[k].second] = 0; queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; q; q.push({0, 0}); visited[0][0] = 1; while(q.size()) { y = q.front().first; x = q.front().second; q.pop(); for(int i=0; i &amp;lt; 4; i++) { int ny = y + dy[i]; int nx = x + dx[i]; if(ny &amp;lt; 0 || ny &amp;gt;= n || nx &amp;lt; 0 || nx &amp;gt;= m) continue; if(!visited[ny][nx] &amp;amp;&amp;amp; !map[ny][nx]) { visited[ny][nx] = visited[y][x] + 1; q.push({ny, nx}); } } } if(visited[n-1][m-1] != 0) ans = min(ans, visited[n-1][m-1]); map[v[k].first][v[k].second] = 1; fill(&amp;amp;visited[0][0], &amp;amp;visited[n][m], 0); } if(ans == 9999999) cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; &#39;\\n&#39;; else cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; &#39;\\n&#39;; return 0;} bruteforce 기법을 이용해 모든 경우의 수를 대입하여 보았더니 시간초과가 발생 하였다.구현 - 3차원 배열 사용#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;// mapint n, m;bool map[1004][1004];int visited[1004][1004][2];// answerint dp[1004];int ans;// joy int dy[] = {-1, 0, 1, 0};int dx[] = {0, 1, 0, -1};int x, y, bk;int main(){ ios_base :: sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; for(int i=0; i &amp;lt; n; i++) { string str; cin &amp;gt;&amp;gt; str; for(int j=0; j &amp;lt; m; j++) { if(str[j] == &#39;1&#39;) map[i][j] = 1; } } queue&amp;lt;pair&amp;lt;pair&amp;lt;int, int&amp;gt;, int&amp;gt;&amp;gt; q; q.push({{0, 0}, 1}); visited[0][0][1] = 1; while(q.size()) { y = q.front().first.first; x = q.front().first.second; bk = q.front().second; q.pop(); if(y == n-1 &amp;amp;&amp;amp; x == m-1) { ans = visited[y][x][bk]; break; } for(int i=0; i &amp;lt; 4; i++) { int ny = y + dy[i]; int nx = x + dx[i]; if(ny &amp;lt; 0 || ny &amp;gt;= n || nx &amp;lt; 0 || nx &amp;gt;= m) continue; // 벽으로 막혀 있고, 벽이 부순 경험이 없고(bk == 1), 방문한 적이 없는 경우 if(map[ny][nx] &amp;amp;&amp;amp; bk &amp;amp;&amp;amp; !visited[ny][nx][bk-1]) { // 방문한 벽을 부수고, 가중치 입력 visited[ny][nx][bk-1] = visited[y][x][bk] + 1; q.push({{ny, nx}, bk-1}); } // 길이고, 방문하지 않았을 경우 else if(!map[ny][nx] &amp;amp;&amp;amp; !visited[ny][nx][bk]) { // 가중치를 입력하고, 벽을 부순 여부는 그대로 이행 visited[ny][nx][bk] = visited[y][x][bk] + 1; q.push({{ny, nx}, bk}); } } } if(ans != 0) cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl; else cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; endl; return 0;}SOL visited[row][col][bk] 을 통해 방문 여부, 벽을 부순 여부를 확인한다. 두개의 조건을 두어 각각의 조건에 따른 push 를 이행한다. 방문하지 않았고, 이동경로가 벽으로 막혀있고, 기존에 벽을 부순 경험이 없는 경우 벽을 부순 경험 추가. 가중치 입력 방문하지 않았고, 이동경로가 벽으로 막혀있지 않은 경우 가중치 입력 기존 벽을 부순 여부 그대로 이행 Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startBFS 너비 우선 탐색" }, { "title": "BOJ - 1068 - 트리", "url": "/posts/BOJ-1068/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, dfs, graph, tree", "date": "2022-09-06 11:10:00 +0900", "snippet": "BOJ - 1068 - 트리문제1068번: 트리문제트리에서 리프 노드란, 자식의 개수가 0인 노드를 말한다.트리가 주어졌을 때, 노드 하나를 지울 것이다. 그 때, 남은 트리에서 리프 노드의 개수를 구하는 프로그램을 작성하시오. 노드를 지우면 그 노드와 노드의 모든 자손이 트리에서 제거된다.예를 들어, 다음과 같은 트리가 있다고 하자.현재 리프 노드의 개수는 3개이다. (초록색 색칠된 노드) 이때, 1번을 지우면, 다음과 같이 변한다. 검정색으로 색칠된 노드가 트리에서 제거된 노드이다.이제 리프 노드의 개수는 1개이다.입력첫째 줄에 트리의 노드의 개수 N이 주어진다. N은 50보다 작거나 같은 자연수이다. 둘째 줄에는 0번 노드부터 N-1번 노드까지, 각 노드의 부모가 주어진다. 만약 부모가 없다면 (루트) -1이 주어진다. 셋째 줄에는 지울 노드의 번호가 주어진다.출력첫째 줄에 입력으로 주어진 트리에서 입력으로 주어진 노드를 지웠을 때, 리프 노드의 개수를 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;int delNum;vector&amp;lt;int&amp;gt; v[51];bool visited[51];int cnt = 0;// 방문 횟수 dfs int dfs(int idx){ int ret = 0; int child = 0; for(int i=0; i &amp;lt; v[idx].size(); i++) { // 삭제된 노드면 넘긴다. if(v[idx][i] == delNum) continue; // 자식 노드를 방문하지 않았더라면 ret += dfs(v[idx][i]); child++; } if(child == 0) return 1; return ret;}int main(){ int num; cin &amp;gt;&amp;gt; num; // root int root; for(int i=0; i &amp;lt; num; i++) { int tmp; cin &amp;gt;&amp;gt; tmp; if(tmp == -1) root = i; else v[tmp].push_back(i); } // delete node cin &amp;gt;&amp;gt; delNum; if(root == delNum) cout &amp;lt;&amp;lt; 0 &amp;lt;&amp;lt; endl; else cout &amp;lt;&amp;lt; dfs(root) &amp;lt;&amp;lt; endl; return 0;}SOL 그래프를 구현한다. v[tmp].push_back(i) 삭제할 노드를 continue를 통해 넘긴다. 자식 노드가 없다면 즉, 리프 노드임으로 함수를 끝내고 1을 반환, 개수를 구한다.Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startDFS 깊이 우선 탐색TREE" }, { "title": "BOJ - 1325 - 효율적인 해킹", "url": "/posts/BOJ-1325/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, dfs, graph, tree", "date": "2022-09-05 11:10:00 +0900", "snippet": "BOJ - 1325 - 효율적인 해킹문제1325번: 효율적인 해킹문제해커 김지민은 잘 알려진 어느 회사를 해킹하려고 한다. 이 회사는 N개의 컴퓨터로 이루어져 있다. 김지민은 귀찮기 때문에, 한 번의 해킹으로 여러 개의 컴퓨터를 해킹 할 수 있는 컴퓨터를 해킹하려고 한다.이 회사의 컴퓨터는 신뢰하는 관계와, 신뢰하지 않는 관계로 이루어져 있는데, A가 B를 신뢰하는 경우에는 B를 해킹하면, A도 해킹할 수 있다는 소리다.이 회사의 컴퓨터의 신뢰하는 관계가 주어졌을 때, 한 번에 가장 많은 컴퓨터를 해킹할 수 있는 컴퓨터의 번호를 출력하는 프로그램을 작성하시오.입력첫째 줄에, N과 M이 들어온다. N은 10,000보다 작거나 같은 자연수, M은 100,000보다 작거나 같은 자연수이다. 둘째 줄부터 M개의 줄에 신뢰하는 관계가 A B와 같은 형식으로 들어오며, ”A가 B를 신뢰한다”를 의미한다. 컴퓨터는 1번부터 N번까지 번호가 하나씩 매겨져 있다.출력첫째 줄에, 김지민이 한 번에 가장 많은 컴퓨터를 해킹할 수 있는 컴퓨터의 번호를 오름차순으로 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;vector&amp;lt;int&amp;gt; v[10004];int visited[10004];int dp[10004];int n, m, a, b, mx;// root node를 찾아라int dfs(int here){ int ret = 1; visited[here] = 1; for(auto &amp;amp;el : v[here]) { // 방문했음 넘기고 if(visited[el]) continue; ret += dfs(el); } return ret;}int main(){ cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; for(int i=0; i &amp;lt; m; i++) { cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; v[b].push_back(a); } for(int i=1; i &amp;lt;= n; i++) { // 방문 초기화 fill(visited, visited + 10004, 0); // 노드 i에 따른 값 저장. dp[i] = dfs(i); // 최댓값 mx = max(dp[i], mx); } for(int i=1; i &amp;lt;= n; i++) if(mx == dp[i]) cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot; &quot;; cout &amp;lt;&amp;lt; endl; return 0;}SOL 1부터 n 번째 까지의 모든 dfs값들을 저장. 후 오름차순으로 정렬한다.Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startDFS 깊이 우선 탐색" }, { "title": "TREE", "url": "/posts/tree/", "categories": "algorithm, graph", "tags": "algorithm, graph, dfs, bfs", "date": "2022-09-05 11:10:00 +0900", "snippet": "Tree개요트리순회트리 순회는 2진트리에서 트리를 순회하는 것을 말한다.총 4가지의 순회 알고리즘이 있고, 각각의 알고리즘을 알아보고자 한다. 후위순회(postorder traversal) 전위순회(preorder traversal) 중위순회(inorder traversal) 레벨순회(level traversal)후위순회 후위순회(postorder traversal)는 자식들 노드를 방문하고 자신의 노드를 방문하는 것수도코드postorder( node )// 방문하지 않았더라면 if (node.visited == false)// 왼쪽 노드(자식노드) 방문 postorder( node-&amp;gt;left ) postorder( node-&amp;gt;right )// 오른쪽 노드(본인노드) 방문 node.visited = true전위순회 전위순회(preorder traversal)는 먼저 자신의 노드를 방문하고 그 다음 노드들을 방문하는 것수도코드postorder( node )// 방문하지 않았더라면 if (node.visited == false)// 오른쪽 노드(본인노드) 방문 node.visited = true postorder( node-&amp;gt; right) // 왼쪽 노드(자식노드) 방문 postorder( node-&amp;gt;left ) 중위순회중위순회(inorder traversal)는 왼쪽 노드를 먼저 방문 그다음의 자신의 노드를 방문하고 그 다음 오른쪽 노드를 방문하는 것수도코드inorder( node ) if (node.visited == false) inorder( node-&amp;gt;left ) node.visited = true inorder( node-&amp;gt;right )레벨순회레벨순회(level traversal) BFS(너비우선 탐색)를 생각하면 된다.Q. 아래의 그래프가 주어졌을 때 preorder, inorder, postorder를 구현하라.수도코드를 보고 코드를 구축하는 연습을 하셔야 합니다. 아래와 같이 그래프가 주어졌을 때 비어진 함수를 채워서 preorder, inorder, postorder를 구현하고 이 때 방문했을 때 해당 노드를 출력하는 것을 구현하라.#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std; vector&amp;lt;int&amp;gt; adj[1004]; int visited[1004];// 전위순회void postOrder(int here){ } // 후위순회void preOrder(int here){ } // 중위순회void inOrder(int here){ } int main(){/* 1 2 34 5*/ adj[1].push_back(2); adj[1].push_back(3); adj[2].push_back(4); adj[2].push_back(5); int root = 1; cout &amp;lt;&amp;lt; &quot;\\n 트리순회 : postOrder \\n&quot;; postOrder(root); memset(visited, 0, sizeof(visited)); cout &amp;lt;&amp;lt; &quot;\\n 트리순회 : preOrder \\n&quot;; preOrder(root); memset(visited, 0, sizeof(visited)); cout &amp;lt;&amp;lt; &quot;\\n 트리순회 : inOrder \\n&quot;; inOrder(root); return 0;}정답코드#include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; vector&amp;lt;int&amp;gt; adj[1004]; int visited[1004];void postOrder(int here){ if(visited[here] == 0){ if(adj[here].size() == 1)postOrder(adj[here][0]); if(adj[here].size() == 2){ postOrder(adj[here][0]); postOrder(adj[here][1]); } visited[here] = 1; cout &amp;lt;&amp;lt; here &amp;lt;&amp;lt; &#39; &#39;; } } void preOrder(int here){ if(visited[here] == 0){ visited[here] = 1; cout &amp;lt;&amp;lt; here &amp;lt;&amp;lt; &#39; &#39;; if(adj[here].size() == 1)preOrder(adj[here][0]); if(adj[here].size() == 2){ preOrder(adj[here][0]); preOrder(adj[here][1]); } }} void inOrder(int here){ if(visited[here] == 0){ if(adj[here].size() == 1){ inOrder(adj[here][0]); visited[here] = 1; cout &amp;lt;&amp;lt; here &amp;lt;&amp;lt; &#39; &#39;; }else if(adj[here].size() == 2){ inOrder(adj[here][0]); visited[here] = 1; cout &amp;lt;&amp;lt; here &amp;lt;&amp;lt; &#39; &#39;; inOrder(adj[here][1]); }else{ visited[here] = 1; cout &amp;lt;&amp;lt; here &amp;lt;&amp;lt; &#39; &#39;; } }} int main(){ adj[1].push_back(2); adj[1].push_back(3); adj[2].push_back(4); adj[2].push_back(5); /* 1 2 34 5*/ int root = 1; cout &amp;lt;&amp;lt; &quot;\\n 트리순회 : postOrder \\n&quot;; postOrder(root); memset(visited, 0, sizeof(visited)); cout &amp;lt;&amp;lt; &quot;\\n 트리순회 : preOrder \\n&quot;; preOrder(root); memset(visited, 0, sizeof(visited)); cout &amp;lt;&amp;lt; &quot;\\n 트리순회 : inOrder \\n&quot;; inOrder(root); return 0;}/* 트리순회 : postOrder4 5 2 3 1 트리순회 : preOrder1 2 4 5 3 트리순회 : inOrder4 2 5 1 3*/Reference큰돌의 터전 : 네이버 블로그" }, { "title": "BOJ - 2636 - 치즈", "url": "/posts/BOJ-2636/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, bfs, graph", "date": "2022-09-02 11:10:00 +0900", "snippet": "BOJ - 2636 - 치즈문제2636번: 치즈문제아래 &amp;lt;그림 1&amp;gt;과 같이 정사각형 칸들로 이루어진 사각형 모양의 판이 있고, 그 위에 얇은 치즈(회색으로 표시된 부분)가 놓여 있다. 판의 가장자리(&amp;lt;그림 1&amp;gt;에서 네모 칸에 X친 부분)에는 치즈가 놓여 있지 않으며 치즈에는 하나 이상의 구멍이 있을 수 있다.이 치즈를 공기 중에 놓으면 녹게 되는데 공기와 접촉된 칸은 한 시간이 지나면 녹아 없어진다. 치즈의 구멍 속에는 공기가 없지만 구멍을 둘러싼 치즈가 녹아서 구멍이 열리면 구멍 속으로 공기가 들어가게 된다. &amp;lt;그림 1&amp;gt;의 경우, 치즈의 구멍을 둘러싼 치즈는 녹지 않고 ‘c’로 표시된 부분만 한 시간 후에 녹아 없어져서 &amp;lt;그림 2&amp;gt;와 같이 된다.&amp;lt;그림 1&amp;gt; 원래 치즈 모양다시 한 시간 후에는 &amp;lt;그림 2&amp;gt;에서 ‘c’로 표시된 부분이 녹아 없어져서 &amp;lt;그림 3&amp;gt;과 같이 된다.&amp;lt;그림 2&amp;gt; 한 시간 후의 치즈 모양&amp;lt;그림 3&amp;gt; 두 시간 후의 치즈 모양&amp;lt;그림 3&amp;gt;은 원래 치즈의 두 시간 후 모양을 나타내고 있으며, 남은 조각들은 한 시간이 더 지나면 모두 녹아 없어진다. 그러므로 처음 치즈가 모두 녹아 없어지는 데는 세 시간이 걸린다. &amp;lt;그림 3&amp;gt;과 같이 치즈가 녹는 과정에서 여러 조각으로 나누어 질 수도 있다.입력으로 사각형 모양의 판의 크기와 한 조각의 치즈가 판 위에 주어졌을 때, 공기 중에서 치즈가 모두 녹아 없어지는 데 걸리는 시간과 모두 녹기 한 시간 전에 남아있는 치즈조각이 놓여 있는 칸의 개수를 구하는 프로그램을 작성하시오.입력첫째 줄에는 사각형 모양 판의 세로와 가로의 길이가 양의 정수로 주어진다. 세로와 가로의 길이는 최대 100이다. 판의 각 가로줄의 모양이 윗 줄부터 차례로 둘째 줄부터 마지막 줄까지 주어진다. 치즈가 없는 칸은 0, 치즈가 있는 칸은 1로 주어지며 각 숫자 사이에는 빈칸이 하나씩 있다.출력첫째 줄에는 치즈가 모두 녹아서 없어지는 데 걸리는 시간을 출력하고, 둘째 줄에는 모두 녹기 한 시간 전에 남아있는 치즈조각이 놓여 있는 칸의 개수를 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std;// mapint n, m;int map[104][104];int tmpmap[104][104];int visited[104][104];// joyint dy[] = {-1, 0, 1, 0};int dx[] = {0, 1, 0, -1};int x, y;// bfs로 푼다. // 단 조건은 인접하는 치즈인 부분은 녹이는걸로 int main(){ cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; m; j++) cin &amp;gt;&amp;gt; map[i][j]; queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; q; int count = 1; int ans = 0; int cnt; while(count) { cnt = 0; // map 복사 for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; m; j++) { tmpmap[i][j] = map[i][j]; if(tmpmap[i][j]) cnt++; } count = 0; q.push({0,0}); while(q.size()) { y = q.front().first; x = q.front().second; q.pop(); for(int i=0; i &amp;lt; 4; i++) { int ny = y + dy[i]; int nx = x + dx[i]; if(ny &amp;lt; 0 || ny &amp;gt;= n || nx &amp;lt; 0 || nx &amp;gt;= m) continue; // 방문하지 않았고 치즈 외부일 경우 if(!visited[ny][nx] &amp;amp;&amp;amp; !map[ny][nx]) { visited[ny][nx] = visited[y][x] + 1; q.push({ny, nx}); } // 방문하지 않았고, 외부와 치즈와 인접한 경우 if(!visited[ny][nx] &amp;amp;&amp;amp; map[ny][nx]) { map[ny][nx] = 0; visited[ny][nx] = visited[y][x] + 1; } } } for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; m; j++) if(map[i][j]) count++; ans++; // 방문 초기화 fill(&amp;amp;visited[0][0], &amp;amp;visited[n][m], 0); } cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; cnt &amp;lt;&amp;lt; endl; return 0;}SOL 방문하지 않았고, 치즈의 외부일 경우 일반적인 bfs의 특성을 이용한다. 단 방문하지 않았고, 치즈와 인접한 외부일 경우 그 부분을 0으로 녹이고 방문처리 하되 추가적인 푸쉬는 하지 않는다. 위 과정을 치즈과 완전히 녹을 때 까지 반복하고 치즈를 녹이기 전 맵을 복사해 두어 정답을 추출한다.Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startBFS 너비 우선 탐색" }, { "title": "BOJ - 14502 - 연구소", "url": "/posts/BOJ-14502/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, dfs, graph", "date": "2022-09-01 11:10:00 +0900", "snippet": "BOJ - 14502 - 연구소문제14502번: 연구소문제인체에 치명적인 바이러스를 연구하던 연구소에서 바이러스가 유출되었다. 다행히 바이러스는 아직 퍼지지 않았고, 바이러스의 확산을 막기 위해서 연구소에 벽을 세우려고 한다.연구소는 크기가 N×M인 직사각형으로 나타낼 수 있으며, 직사각형은 1×1 크기의 정사각형으로 나누어져 있다. 연구소는 빈 칸, 벽으로 이루어져 있으며, 벽은 칸 하나를 가득 차지한다.일부 칸은 바이러스가 존재하며, 이 바이러스는 상하좌우로 인접한 빈 칸으로 모두 퍼져나갈 수 있다. 새로 세울 수 있는 벽의 개수는 3개이며, 꼭 3개를 세워야 한다.예를 들어, 아래와 같이 연구소가 생긴 경우를 살펴보자.2 0 0 0 1 1 00 0 1 0 1 2 00 1 1 0 1 0 00 1 0 0 0 0 00 0 0 0 0 1 10 1 0 0 0 0 00 1 0 0 0 0 0이때, 0은 빈 칸, 1은 벽, 2는 바이러스가 있는 곳이다. 아무런 벽을 세우지 않는다면, 바이러스는 모든 빈 칸으로 퍼져나갈 수 있다.2행 1열, 1행 2열, 4행 6열에 벽을 세운다면 지도의 모양은 아래와 같아지게 된다.2 1 0 0 1 1 01 0 1 0 1 2 00 1 1 0 1 0 00 1 0 0 0 1 00 0 0 0 0 1 10 1 0 0 0 0 00 1 0 0 0 0 0바이러스가 퍼진 뒤의 모습은 아래와 같아진다.2 1 0 0 1 1 21 0 1 0 1 2 20 1 1 0 1 2 20 1 0 0 0 1 20 0 0 0 0 1 10 1 0 0 0 0 00 1 0 0 0 0 0벽을 3개 세운 뒤, 바이러스가 퍼질 수 없는 곳을 안전 영역이라고 한다. 위의 지도에서 안전 영역의 크기는 27이다.연구소의 지도가 주어졌을 때 얻을 수 있는 안전 영역 크기의 최댓값을 구하는 프로그램을 작성하시오.입력첫째 줄에 지도의 세로 크기 N과 가로 크기 M이 주어진다. (3 ≤ N, M ≤ 8)둘째 줄부터 N개의 줄에 지도의 모양이 주어진다. 0은 빈 칸, 1은 벽, 2는 바이러스가 있는 위치이다. 2의 개수는 2보다 크거나 같고, 10보다 작거나 같은 자연수이다.빈 칸의 개수는 3개 이상이다.출력첫째 줄에 얻을 수 있는 안전 영역의 최대 크기를 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;// mapint n, m;int map[10][10];int tmpmap[10][10];bool visited[10][10];// joy int dy[] = {-1, 0, 1, 0};int dx[] = {0, 1, 0, -1};// x yint x, y;// 바이러스vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; v;// 벽을 새울 수 있는 후보 vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; wallv;// 안전지대 int safe_zone = 0;void dfs(int y, int x, bool flag){ visited[y][x] = 1; for(int i=0; i &amp;lt; 4; i++) { int ny = y + dy[i]; int nx = x + dx[i]; if(ny &amp;lt; 0 || nx &amp;lt; 0 || ny &amp;gt;= n || nx &amp;gt;= m) continue; // 방문하지 않고, 벽만 아니면 if(!visited[ny][nx] &amp;amp;&amp;amp; tmpmap[ny][nx] != 1 &amp;amp;&amp;amp; flag) { // 감염 tmpmap[ny][nx] = 2; dfs(ny, nx, 1); } } return;}int solve(){ int cnt = 0; // map temp for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; m; j++) tmpmap[i][j] = map[i][j]; // 오염 시키기 for(auto &amp;amp;el : v) if(!visited[el.first][el.second] &amp;amp;&amp;amp; tmpmap[el.first][el.second] != 1) dfs(el.first, el.second, 1); for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; m; j++) if(!tmpmap[i][j]) cnt++; return cnt;}int main(){ cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; m; j++) { // 맵 입력 &amp;amp;&amp;amp; 바이러스 좌표 추출 cin &amp;gt;&amp;gt; map[i][j]; if(map[i][j] == 2) v.push_back({i, j}); // 벽 새우기 후보 else if(!map[i][j]) wallv.push_back({i, j}); } // 3개의 벽 새우기 int ans = 0; for(int i=0; i &amp;lt; wallv.size(); i++) { for(int j=i+1; j &amp;lt; wallv.size(); j++) { for(int k=j+1; k &amp;lt; wallv.size(); k++) { map[wallv[i].first][wallv[i].second] = 1; map[wallv[j].first][wallv[j].second] = 1; map[wallv[k].first][wallv[k].second] = 1; ans = max(solve(), ans); // 초기화 map[wallv[i].first][wallv[i].second] = 0; map[wallv[j].first][wallv[j].second] = 0; map[wallv[k].first][wallv[k].second] = 0; // 방문 초기화 for(int i=0; i &amp;lt; n; i++) fill(visited[i], visited[i] + m, 0); } } } cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl; return 0;}SOL 벽을 새울 수 있는 모든 경우에 dfs를 시전한다.Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startDFS 깊이 우선 탐색" }, { "title": "BOJ - 3474 - 교수가 된 현우", "url": "/posts/BOJ-3474/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, math", "date": "2022-08-31 11:10:00 +0900", "snippet": "BOJ - 3474 - 교수가 된 현우문제3474번: 교수가 된 현우문제 개념문제알고리즘의 킹갓제너럴엠퍼러마제스티충무공알고리즘마스터 현우가 교수로 취임하였다!그러나 학생들에게 크나큰 기대를 품고 첫 수업에 들어갔던 현우는 아무도 외판원 순회 문제(Traveling Salesman Problem, TSP)를 풀지 못하는 것을 보고 낙심하였다.그 와중에 학생 남규는 TSP를 완전탐색으로 풀려고 하였고, 현우는 그걸 보고 경악을 금치 못한다. 왜냐면 TSP를 완전탐색으로 풀려면 O(N!)의 시간이 소모되는데, 이는 경악을 금치 못할 시간이기 때문이다.그러나 남규는 O(N!)이 왜 큰지도 잘 모른다. 그래서 현우는 더더욱 경악을 금치 못하고, N!이 얼마나 큰지 대략적으로나마 알려주기 위해, 자연수 N이 주어지면 N!의 오른쪽 끝에 있는 0의 개수를 알려주기로 하였다.그러나 현우는 경악을 금치 못하여 지금 코딩을 할 수 없는 상황이다. 여러분이 현우를 대신하여 프로그램을 작성하시오.입력첫째 줄에 테스트 케이스의 개수 T가 주어지고, 이어서 T개의 줄에 정수 N이 주어진다(1 &amp;lt;= N &amp;lt;= 1000000000).출력각 줄마다 N!의 오른쪽 끝에 있는 0의 개수를 출력한다.구현#include &amp;lt;iostream&amp;gt;using namespace std;int main(){ ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL); int num; cin &amp;gt;&amp;gt; num; for(int i=0; i &amp;lt; num; i++) { int n; cin &amp;gt;&amp;gt; n; int ret2 = 0; int ret5 = 0; for(int j=2; j &amp;lt;= n; j*=2) ret2 += n / j; for(int j=5; j &amp;lt;= n; j*=5) ret5 += n / j; cout &amp;lt;&amp;lt; min(ret2, ret5) &amp;lt;&amp;lt; &#39;\\n&#39;; } return 0;}SOL 뒤에서 0이 나올 경우는 10의 제곱일 경우 뿐이다. 따라서 5 그리고 2로 나눠지는 경우를 구한다. N까지기에 5, 25, 125 등등의 5의 배수의 개수를 구한 후 더해 문제를 해결한다. Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 start" }, { "title": "BOJ - 2870 - 수학 숙제", "url": "/posts/BOJ-2870/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, sort", "date": "2022-08-31 11:10:00 +0900", "snippet": "BOJ - 2870 - 수학숙제문제2870번: 수학숙제문제문제상근이는 수학시간에 딴 짓을 하다가 선생님께 걸렸다. 선생님은 상근이에게 이번 주말동안 반성하라며 엄청난 숙제를 내주었다.선생님이 상근이에게 준 종이에는 숫자와 알파벳 소문자로 되어있는 글자가 N줄있다. 상근이는 여기서 숫자를 모두 찾은 뒤, 이 숫자를 비내림차순으로 정리해야한다. 숫자의 앞에 0이 있는 경우에는 정리하면서 생략할 수 있다.글자를 살펴보다가 숫자가 나오는 경우에는, 가능한 가장 큰 숫자를 찾아야 한다. 즉, 모든 숫자의 앞과 뒤에 문자가 있거나, 줄의 시작 또는 끝이어야 한다.예를 들어, 01a2b3456cde478에서 숫자를 찾으면 1, 2, 3456, 478이다.선생님이 준 종이의 내용이 주어졌을 때, 상근이의 숙제를 대신하는 프로그램을 작성하시오.입력첫째 줄에 종이의 줄의 개수 N이 주어진다. (1 ≤ N ≤ 100)다음 N개의 줄에는 각 줄의 내용이 주어진다. 각 줄은 최대 100글자이고, 항상 알파벳 소문자와 숫자로만 이루어져 있다.출력종이에서 찾은 숫자의 개수를 M이라고 하면, 출력은 M줄로 이루어져야 한다. 각 줄에는 종이에서 찾은 숫자를 하나씩 출력해야 한다. 이때, 비내림차순으로 출력해야 한다. 비내림차순은 내림차순의 반대인 경우인데, 다음 수가 앞의 수보다 크거나 같은 경우를 말한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;bool compare(string a, string b){ if(a.size() == b.size()) return a &amp;lt; b; return a.size() &amp;lt; b.size();}int main(){ int num; cin &amp;gt;&amp;gt; num; // 앞자리에 0이오면 무시한다. vector&amp;lt;string&amp;gt; v; for(int i=0; i &amp;lt; num; i++) { string str; cin &amp;gt;&amp;gt; str; string tmp = &quot;&quot;; for(int j=0; j &amp;lt; str.size(); j++) { if(str[j] &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; str[j] &amp;lt;= &#39;9&#39;) tmp += str[j]; if(str[j] &amp;gt;= &#39;a&#39; &amp;amp;&amp;amp; str[j] &amp;lt;= &#39;z&#39; &amp;amp;&amp;amp; tmp.size()) { while(tmp[0] == &#39;0&#39; &amp;amp;&amp;amp; tmp.size() &amp;gt; 1) { tmp.erase(tmp.begin()); } v.push_back(tmp); tmp = &quot;&quot;; } if(j == str.size()-1 &amp;amp;&amp;amp; tmp.size()) { while(tmp[0] == &#39;0&#39; &amp;amp;&amp;amp; tmp.size() &amp;gt; 1) { tmp.erase(tmp.begin()); } v.push_back(tmp); tmp = &quot;&quot;; } } } sort(v.begin(), v.end(), compare); for(auto &amp;amp;el : v) cout &amp;lt;&amp;lt; el &amp;lt;&amp;lt; &#39;\\n&#39;; return 0;}SOL 숫자와 문자 구별 후 숫자 모음 string 생성 앞자리가 0 이면, 숫자 string이 1이 아니고 앞자리가 0이 아닌 숫자가 나올때 까지 pop_front 커스텀 compare을 통해 숫자 문자열의 크기를 오름차순 정렬Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 start" }, { "title": "BOJ - 2910 - 빈도 정렬", "url": "/posts/BOJ-2910/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, sort, hash", "date": "2022-08-30 11:10:00 +0900", "snippet": "BOJ - 2910 - 빈도정렬문제2910번: 빈도 정렬문제문제위대한 해커 창영이는 모든 암호를 깨는 방법을 발견했다. 그 방법은 빈도를 조사하는 것이다.창영이는 말할 수 없는 방법을 이용해서 현우가 강산이에게 보내는 메시지를 획득했다. 이 메시지는 숫자 N개로 이루어진 수열이고, 숫자는 모두 C보다 작거나 같다. 창영이는 이 숫자를 자주 등장하는 빈도순대로 정렬하려고 한다.만약, 수열의 두 수 X와 Y가 있을 때, X가 Y보다 수열에서 많이 등장하는 경우에는 X가 Y보다 앞에 있어야 한다. 만약, 등장하는 횟수가 같다면, 먼저 나온 것이 앞에 있어야 한다.이렇게 정렬하는 방법을 빈도 정렬이라고 한다.수열이 주어졌을 때, 빈도 정렬을 하는 프로그램을 작성하시오.입력첫째 줄에 메시지의 길이 N과 C가 주어진다. (1 ≤ N ≤ 1,000, 1 ≤ C ≤ 1,000,000,000)둘째 줄에 메시지 수열이 주어진다.출력첫째 줄에 입력으로 주어진 수열을 빈도 정렬한 다음 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;class cl{public: // 숫자 long long num; // 순서 int number; // 빈도 int bindo;};bool compare(cl &amp;amp;a, cl &amp;amp;b){ if(a.bindo == b.bindo) return a.number &amp;lt; b.number; return a.bindo &amp;gt; b.bindo;}int main(){ int n, m; cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; // 숫자와 순서 map&amp;lt;long long, int&amp;gt; mp1; // 숫자와 빈도 map&amp;lt;long long, int&amp;gt; mp2; // 숫자와 순서 빈도 vector&amp;lt;cl&amp;gt; v; for(int i=1; i &amp;lt;= n; i++) { long long tmp; cin &amp;gt;&amp;gt; tmp; if(mp1[tmp] == 0) mp1[tmp] = i; mp2[tmp] += 1; } for(auto &amp;amp;el : mp1) { // 숫자 순서 빈도 cl tmp; tmp.bindo = mp2[el.first]; tmp.num = el.first; tmp.number = el.second; v.push_back(tmp); } sort(v.begin(), v.end(), compare); for(auto &amp;amp;el : v) while(el.bindo) { cout &amp;lt;&amp;lt; el.num &amp;lt;&amp;lt; &quot; &quot;; el.bindo--; } cout &amp;lt;&amp;lt; endl; return 0;}SOL 숫자와 순서, 순자와 빈도 각각의 맵을 따로 만든다. 숫자, 순서, 빈도를 각각 입력받을 수 있는 클래스를 만들어 맵에 저장한 정보들을 입력한다. 커스텀 compare를 두어 정렬 후 순서대로 출력한다.Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 start" }, { "title": "BOJ - 1992 - 쿼드트리", "url": "/posts/BOJ-1992/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, graph, recursive", "date": "2022-08-30 11:10:00 +0900", "snippet": "BOJ - 1992 - 쿼드트리문제1992번: 쿼드트리문제흑백 영상을 압축하여 표현하는 데이터 구조로 쿼드 트리(Quad Tree)라는 방법이 있다. 흰 점을 나타내는 0과 검은 점을 나타내는 1로만 이루어진 영상(2차원 배열)에서 같은 숫자의 점들이 한 곳에 많이 몰려있으면, 쿼드 트리에서는 이를 압축하여 간단히 표현할 수 있다.주어진 영상이 모두 0으로만 되어 있으면 압축 결과는 “0”이 되고, 모두 1로만 되어 있으면 압축 결과는 “1”이 된다. 만약 0과 1이 섞여 있으면 전체를 한 번에 나타내지를 못하고, 왼쪽 위, 오른쪽 위, 왼쪽 아래, 오른쪽 아래, 이렇게 4개의 영상으로 나누어 압축하게 되며, 이 4개의 영역을 압축한 결과를 차례대로 괄호 안에 묶어서 표현한다위 그림에서 왼쪽의 영상은 오른쪽의 배열과 같이 숫자로 주어지며, 이 영상을 쿼드 트리 구조를 이용하여 압축하면 “(0(0011)(0(0111)01)1)“로 표현된다.  N ×N 크기의 영상이 주어질 때, 이 영상을 압축한 결과를 출력하는 프로그램을 작성하시오.입력첫째 줄에는 영상의 크기를 나타내는 숫자 N 이 주어진다. N 은 언제나 2의 제곱수로 주어지며, 1 ≤ N ≤ 64의 범위를 가진다. 두 번째 줄부터는 길이 N의 문자열이 N개 들어온다. 각 문자열은 0 또는 1의 숫자로 이루어져 있으며, 영상의 각 점들을 나타낸다.출력영상을 압축한 결과를 출력한다.구현#include &amp;lt;iostream&amp;gt;using namespace std;char map[101][101];int num;string quard(int y, int x, int size){ if(size == 1) return string(1, map[y][x]); char tmp = map[y][x]; string ret = &quot;&quot;; for(int i=y; i &amp;lt; y + size; i++) for(int j=x; j &amp;lt; x + size; j++) // 0, 1 이 되지 않는다면 if(tmp != map[i][j]) { ret += &#39;(&#39;; // 왼 위 ret += quard(y, x, size / 2); // 오 위 ret += quard(y, x + size / 2, size / 2); // 왼 아래 ret += quard(y + size / 2, x, size / 2); // 오른 아래 ret += quard(y + size / 2, x + size / 2, size / 2); ret += &#39;)&#39;; return ret; } return string(1, map[y][x]);}int main(){ cin &amp;gt;&amp;gt; num; for(int i=0; i &amp;lt; num; i++) { string str; cin &amp;gt;&amp;gt; str; for(int j=0; j &amp;lt; num; j++) map[i][j] = str[j]; } cout &amp;lt;&amp;lt; quard(0, 0, num) &amp;lt;&amp;lt; endl; return 0;}SOL 재귀 함수의 특성을 이용한다. 중단 조건 왼쪽 위, 오른쪽 위 왼쪽 아래, 오른쪽 아래 재귀탐색 Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 start" }, { "title": "BOJ - 5427 - 불", "url": "/posts/BOJ-5427/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, graph, bfs", "date": "2022-08-29 11:10:00 +0900", "snippet": "BOJ - 5427 - 불문제5427번: 불문제상근이는 빈 공간과 벽으로 이루어진 건물에 갇혀있다. 건물의 일부에는 불이 났고, 상근이는 출구를 향해 뛰고 있다.매 초마다, 불은 동서남북 방향으로 인접한 빈 공간으로 퍼져나간다. 벽에는 불이 붙지 않는다. 상근이는 동서남북 인접한 칸으로 이동할 수 있으며, 1초가 걸린다. 상근이는 벽을 통과할 수 없고, 불이 옮겨진 칸 또는 이제 불이 붙으려는 칸으로 이동할 수 없다. 상근이가 있는 칸에 불이 옮겨옴과 동시에 다른 칸으로 이동할 수 있다.빌딩의 지도가 주어졌을 때, 얼마나 빨리 빌딩을 탈출할 수 있는지 구하는 프로그램을 작성하시오.입력첫째 줄에 테스트 케이스의 개수가 주어진다. 테스트 케이스는 최대 100개이다.각 테스트 케이스의 첫째 줄에는 빌딩 지도의 너비와 높이 w와 h가 주어진다. (1 ≤ w,h ≤ 1000)다음 h개 줄에는 w개의 문자, 빌딩의 지도가 주어진다. ’.’: 빈 공간 ’#’: 벽 ’@’: 상근이의 시작 위치 ‘*’: 불각 지도에 @의 개수는 하나이다.출력각 테스트 케이스마다 빌딩을 탈출하는데 가장 빠른 시간을 출력한다. 빌딩을 탈출할 수 없는 경우에는 “IMPOSSIBLE”을 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;// mapint n, m;int map[1004][1004];int Jvisited[1004][1004];int Fvisited[1004][1004];// joyint dy[] = {-1, 0, 1, 0};int dx[] = {0, 1, 0, -1};// x, yint x, y, jx, jy, fx, fy;// q queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; fq;queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; jq;vector&amp;lt;string&amp;gt; v;int main(){ int num; cin &amp;gt;&amp;gt; num; for(int k=0; k &amp;lt; num; k++) { cin &amp;gt;&amp;gt; m &amp;gt;&amp;gt; n; // map 이진화 for(int i=0; i &amp;lt; n; i++) { string str; cin &amp;gt;&amp;gt; str; for(int j=0; j &amp;lt; m; j++) { char tmp = str[j]; if(tmp == &#39;#&#39;) map[i][j] = 1; else if(tmp == &#39;.&#39;) map[i][j] = 0; else if(tmp == &#39;@&#39;) { jy = i; jx = j; } else { fq.push({i, j}); Fvisited[i][j] = 1; } } } jq.push({jy, jx}); Jvisited[jy][jx] = 1; // 최단거리 while (fq.size()) { fx = fq.front().second; fy = fq.front().first; fq.pop(); for(int i=0; i &amp;lt; 4; i++) { int ny = fy + dy[i]; int nx = fx + dx[i]; if(ny &amp;lt; 0 || nx &amp;lt; 0|| ny &amp;gt;= n || nx &amp;gt;= m) continue; // 벽일 경우, 이미 방문 했을 경우 if(map[ny][nx] || Fvisited[ny][nx]) continue; Fvisited[ny][nx] = Fvisited[fy][fx] + 1; fq.push({ny, nx}); } } while(jq.size()) { y = jq.front().first; x = jq.front().second; jq.pop(); for(int i=0; i &amp;lt; 4; i++) { int ny = y + dy[i]; int nx = x + dx[i]; if(ny &amp;lt; 0 || nx &amp;lt; 0|| ny &amp;gt;= n || nx &amp;gt;= m) continue; // 벽일 경우, 이미 방문 했을 경우 if(map[ny][nx] || Jvisited[ny][nx]) continue; Jvisited[ny][nx] = Jvisited[y][x] + 1; jq.push({ny, nx}); } } // 불을 피해가는 최단거리 값 for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; m; j++) if(Jvisited[i][j] &amp;gt;= Fvisited[i][j] &amp;amp;&amp;amp; Fvisited[i][j]) Jvisited[i][j] = 0; long long min = 9999999999; for(int i=0; i &amp;lt; n; i++) { if(i == 0 || i == n-1) { for(int j=0; j &amp;lt; m; j++) if(min &amp;gt; Jvisited[i][j] &amp;amp;&amp;amp; Jvisited[i][j]) min = Jvisited[i][j]; } else { if(min &amp;gt; Jvisited[i][0] &amp;amp;&amp;amp; Jvisited[i][0]) min = Jvisited[i][0]; else if(min &amp;gt; Jvisited[i][m-1] &amp;amp;&amp;amp; Jvisited[i][m-1]) min = Jvisited[i][m-1]; } } // map 출력 // cout &amp;lt;&amp;lt; &quot;---------------&quot; &amp;lt;&amp;lt; endl; // for(int i=0; i &amp;lt; n; i++) // { // for(int j=0; j &amp;lt; m; j++) // { // cout &amp;lt;&amp;lt; Jvisited[i][j] &amp;lt;&amp;lt; &quot; &quot;; // } // cout &amp;lt;&amp;lt; endl; // } // 출구가 존재하면 if(min != 9999999999) v.push_back(to_string(min)); else v.push_back(&quot;IMPOSSIBLE&quot;); for(int i=0; i &amp;lt; n+4; i++) for(int j=0; j &amp;lt; m+4; j++) { Fvisited[i][j] = 0; Jvisited[i][j] = 0; map[i][j] = 0; } // 초기화 while(jq.size()) jq.pop(); while(fq.size()) fq.pop(); } for(auto &amp;amp;el : v) cout &amp;lt;&amp;lt; el &amp;lt;&amp;lt; endl; return 0;}SOL map 이진화 불, 이동경로 BFS를 각각 따로 생성 불 BFS 실행 후 이동경로 BFS 실행 불, 이동경로의 visited를 비교 후 동일 좌표에서 불 보다 큰 값을 가지고 있으면 0으로 초기화. map의 가장자리를 모두 탐색하여 최솟 값 추출 없다면 IMPOSSIBLE 출력 지난번에 풀었던 불! 문제와 동일함.Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startBFS 너비 우선 탐색" }, { "title": "BOJ - 2667 - 단지번호 붙이기", "url": "/posts/BOJ-2667/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, graph, dfs", "date": "2022-08-25 11:10:00 +0900", "snippet": "BOJ - 2667 - 단지번호붙이기문제2667번: 단지번호붙이기문제&amp;lt;그림 1&amp;gt;과 같이 정사각형 모양의 지도가 있다. 1은 집이 있는 곳을, 0은 집이 없는 곳을 나타낸다. 철수는 이 지도를 가지고 연결된 집의 모임인 단지를 정의하고, 단지에 번호를 붙이려 한다. 여기서 연결되었다는 것은 어떤 집이 좌우, 혹은 아래위로 다른 집이 있는 경우를 말한다. 대각선상에 집이 있는 경우는 연결된 것이 아니다. &amp;lt;그림 2&amp;gt;는 &amp;lt;그림 1&amp;gt;을 단지별로 번호를 붙인 것이다. 지도를 입력하여 단지수를 출력하고, 각 단지에 속하는 집의 수를 오름차순으로 정렬하여 출력하는 프로그램을 작성하시오.입력첫 번째 줄에는 지도의 크기 N(정사각형이므로 가로와 세로의 크기는 같으며 5≤N≤25)이 입력되고, 그 다음 N줄에는 각각 N개의 자료(0혹은 1)가 입력된다.출력첫 번째 줄에는 총 단지수를 출력하시오. 그리고 각 단지내 집의 수를 오름차순으로 정렬하여 한 줄에 하나씩 출력하시오.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;// mapint n, m;bool map[1004][1004];bool visited[1004][1004];// joy int dy[] = {-1, 0, 1, 0};int dx[] = {0, 1, 0, -1};int x, y;// 단지수, 가구수int cnt;vector&amp;lt;int&amp;gt; v;void dfs(int y, int x){ visited[y][x] = 1; cnt++; for(int i=0; i &amp;lt; 4; i++) { int ny = y + dy[i]; int nx = x + dx[i]; // 범위 if(ny &amp;lt; 0 || nx &amp;lt; 0 || ny &amp;gt;= n || nx &amp;gt;= m) continue; // 방문하지 않았고, 집이 있으면 if(!visited[ny][nx] &amp;amp;&amp;amp; map[ny][nx]) { dfs(ny, nx); } } return;}int main(){ cin &amp;gt;&amp;gt; n; m = n; for(int i=0; i &amp;lt; n; i++) { string str; cin &amp;gt;&amp;gt; str; for(int j=0; j &amp;lt; m; j++) { if(str[j] == &#39;0&#39;) map[i][j] = 0; else map[i][j] = 1; } } for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; m; j++) if(!visited[i][j] &amp;amp;&amp;amp; map[i][j]) { cnt = 0; dfs(i, j); v.push_back(cnt); } // 오름차순 정렬 sort(v.begin(), v.end()); // 출력 cout &amp;lt;&amp;lt; v.size() &amp;lt;&amp;lt; &#39;\\n&#39;; for(auto &amp;amp;el : v) cout &amp;lt;&amp;lt; el &amp;lt;&amp;lt; &#39;\\n&#39;; return 0;}SOL dfs를 사용하여 단지 수를 구하고, 함수가 사용될 때마다 cnt 하여 단지 내 가구 수를 구한다.Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startDFS 깊이 우선 탐색" }, { "title": "BOJ - 14503 - 로봇 청소기", "url": "/posts/BOJ-14503/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, graph, dfs", "date": "2022-08-24 11:10:00 +0900", "snippet": "BOJ - 14503 - 로봇 청소기문제14503번: 로봇 청소기문제로봇 청소기가 주어졌을 때, 청소하는 영역의 개수를 구하는 프로그램을 작성하시오.로봇 청소기가 있는 장소는 N×M 크기의 직사각형으로 나타낼 수 있으며, 1×1크기의 정사각형 칸으로 나누어져 있다. 각각의 칸은 벽 또는 빈 칸이다. 청소기는 바라보는 방향이 있으며, 이 방향은 동, 서, 남, 북중 하나이다. 지도의 각 칸은 (r, c)로 나타낼 수 있고, r은 북쪽으로부터 떨어진 칸의 개수, c는 서쪽으로 부터 떨어진 칸의 개수이다.로봇 청소기는 다음과 같이 작동한다. 현재 위치를 청소한다. 현재 위치에서 현재 방향을 기준으로 왼쪽방향부터 차례대로 탐색을 진행한다. 왼쪽 방향에 아직 청소하지 않은 공간이 존재한다면, 그 방향으로 회전한 다음 한 칸을 전진하고 1번부터 진행한다. 왼쪽 방향에 청소할 공간이 없다면, 그 방향으로 회전하고 2번으로 돌아간다. 네 방향 모두 청소가 이미 되어있거나 벽인 경우에는, 바라보는 방향을 유지한 채로 한 칸 후진을 하고 2번으로 돌아간다. 네 방향 모두 청소가 이미 되어있거나 벽이면서, 뒤쪽 방향이 벽이라 후진도 할 수 없는 경우에는 작동을 멈춘다. 로봇 청소기는 이미 청소되어있는 칸을 또 청소하지 않으며, 벽을 통과할 수 없다.입력첫째 줄에 세로 크기 N과 가로 크기 M이 주어진다. (3 ≤ N, M ≤ 50)둘째 줄에 로봇 청소기가 있는 칸의 좌표 (r, c)와 바라보는 방향 d가 주어진다. d가 0인 경우에는 북쪽을, 1인 경우에는 동쪽을, 2인 경우에는 남쪽을, 3인 경우에는 서쪽을 바라보고 있는 것이다.셋째 줄부터 N개의 줄에 장소의 상태가 북쪽부터 남쪽 순서대로, 각 줄은 서쪽부터 동쪽 순서대로 주어진다. 빈 칸은 0, 벽은 1로 주어진다. 지도의 첫 행, 마지막 행, 첫 열, 마지막 열에 있는 모든 칸은 벽이다.로봇 청소기가 있는 칸의 상태는 항상 빈 칸이다.출력로봇 청소기가 청소하는 칸의 개수를 출력한다.구현#include &amp;lt;iostream&amp;gt;using namespace std;// mapint n, m;bool map[1004][1004];int visited[1004][1004];// joy 북 동 남 서 int dy[] = {-1, 0, 1, 0};int dx[] = {0, 1, 0, -1};void dfs(int y, int x, int w, int sum){ for(int i=0; i &amp;lt; 4; i++) { // 왼쪽부터 탐색 int rotate = (w + 3 - i) % 4; int ny = y + dy[rotate]; int nx = x + dx[rotate]; // map 범위를 벗어날 경우 if(ny &amp;lt; 0 || nx &amp;lt; 0 || ny &amp;gt;= n || nx &amp;gt;= m || map[ny][nx] == 1) continue; // 청소가 되어있지 않고, 벽이 아닐 경우 if(!visited[ny][nx] &amp;amp;&amp;amp; !map[ny][nx]) { visited[ny][nx] = 1; dfs(ny, nx, rotate, sum+1); } } // robot 후진 int backrotate = w + 2 &amp;lt; 4 ? w+2 : w-2; int backy = y + dy[backrotate]; int backx = x + dx[backrotate]; if(0 &amp;lt;= backy &amp;amp;&amp;amp; 0 &amp;lt;= backx &amp;amp;&amp;amp; backy &amp;lt;= n &amp;amp;&amp;amp; backx &amp;lt;= m) { if(!map[backy][backx]) dfs(backy, backx, w, sum); else { cout &amp;lt;&amp;lt; sum &amp;lt;&amp;lt; endl; exit(0); } }}int main(){ int x, y, w; cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; cin &amp;gt;&amp;gt; y &amp;gt;&amp;gt; x &amp;gt;&amp;gt; w; for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; m; j++) cin &amp;gt;&amp;gt; map[i][j]; visited[y][x] = 1; dfs(y, x, w, 1); // map 출력 // for(int i=0; i &amp;lt; n; i++) // { // for(int j=0; j &amp;lt; m; j++) // cout &amp;lt;&amp;lt; visited[i][j] &amp;lt;&amp;lt; &quot; &quot;; // cout &amp;lt;&amp;lt; endl; // } return 0;}SOL 일반적인 dfs함수를 사용하게 되면 동, 서, 남, 북 각각의 방향으로 뻗어나갈 수 있다. 로봇은 1대이고 한가지 경로로만 이동해야 하기 때문! 따라서 1회성을 보장하기 위해 함수가 1회 사용이 끝난 이후 프로그램을 종료하는 exit(0) 를 사용한다.exit() &amp;amp;&amp;amp; return 의 차이return 은 함수의 종료를 의미하고, exit(0) 함수는 해당 프로그램의 종료를 의미한다.Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startDFS 깊이 우선 탐색" }, { "title": "BOJ - 10026 - 적록색약", "url": "/posts/BOJ-10026/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, graph, dfs", "date": "2022-08-23 11:10:00 +0900", "snippet": "BOJ - 10026 - 적록색약문제10026번: 적록색약문제적록색약은 빨간색과 초록색의 차이를 거의 느끼지 못한다. 따라서, 적록색약인 사람이 보는 그림은 아닌 사람이 보는 그림과는 좀 다를 수 있다.크기가 N×N인 그리드의 각 칸에 R(빨강), G(초록), B(파랑) 중 하나를 색칠한 그림이 있다. 그림은 몇 개의 구역으로 나뉘어져 있는데, 구역은 같은 색으로 이루어져 있다. 또, 같은 색상이 상하좌우로 인접해 있는 경우에 두 글자는 같은 구역에 속한다. (색상의 차이를 거의 느끼지 못하는 경우도 같은 색상이라 한다)예를 들어, 그림이 아래와 같은 경우에RRRBBGGBBBBBBRRBBRRRRRRRR적록색약이 아닌 사람이 봤을 때 구역의 수는 총 4개이다. (빨강 2, 파랑 1, 초록 1) 하지만, 적록색약인 사람은 구역을 3개 볼 수 있다. (빨강-초록 2, 파랑 1)그림이 입력으로 주어졌을 때, 적록색약인 사람이 봤을 때와 아닌 사람이 봤을 때 구역의 수를 구하는 프로그램을 작성하시오.입력첫째 줄에 N이 주어진다. (1 ≤ N ≤ 100)둘째 줄부터 N개 줄에는 그림이 주어진다.출력적록색약이 아닌 사람이 봤을 때의 구역의 개수와 적록색약인 사람이 봤을 때의 구역의 수를 공백으로 구분해 출력한다.구현#include &amp;lt;iostream&amp;gt;using namespace std;// map int n, m;char map[1004][1004];bool Rvisited[1004][1004];bool Gvisited[1004][1004];bool Bvisited[1004][1004];bool RGvisited[1004][1004];// joy int dy[] = {-1, 0, 1, 0};int dx[] = {0, 1, 0, -1};// xyint rx, ry;int gx, gy;int bx, by;int rgx, rgy;void Rdfs(int ry, int rx){ Rvisited[ry][rx] = 1; for(int i=0; i &amp;lt; 4; i++) { int ny = ry + dy[i]; int nx = rx + dx[i]; if(ny &amp;lt; 0 || nx &amp;lt; 0 || ny &amp;gt;= n || nx &amp;gt;= m) continue; if(!Rvisited[ny][nx] &amp;amp;&amp;amp; map[ny][nx] == &#39;R&#39;) Rdfs(ny, nx); } return;}void Gdfs(int gy, int gx){ Gvisited[gy][gx] = 1; for(int i=0; i &amp;lt; 4; i++) { int ny = gy + dy[i]; int nx = gx + dx[i]; if(ny &amp;lt; 0 || nx &amp;lt; 0 || ny &amp;gt;= n || nx &amp;gt;= m) continue; if(!Gvisited[ny][nx] &amp;amp;&amp;amp; map[ny][nx] == &#39;G&#39;) Gdfs(ny, nx); } return;}void Bdfs(int by, int bx){ Bvisited[by][bx] = 1; for(int i=0; i &amp;lt; 4; i++) { int ny = by + dy[i]; int nx = bx + dx[i]; if(ny &amp;lt; 0 || nx &amp;lt; 0 || ny &amp;gt;= n || nx &amp;gt;= m) continue; if(!Bvisited[ny][nx] &amp;amp;&amp;amp; map[ny][nx] == &#39;B&#39;) Bdfs(ny, nx); } return;}void RGdfs(int rgy, int rgx){ RGvisited[rgy][rgx] = 1; for(int i=0; i &amp;lt; 4; i++) { int ny = rgy + dy[i]; int nx = rgx + dx[i]; if(ny &amp;lt; 0 || nx &amp;lt; 0 || ny &amp;gt;= n || nx &amp;gt;= m) continue; if(!RGvisited[ny][nx] &amp;amp;&amp;amp; (map[ny][nx] == &#39;R&#39; || map[ny][nx] == &#39;G&#39;)) RGdfs(ny, nx); } return;}int main(){ cin &amp;gt;&amp;gt; n; m = n; for(int i=0; i &amp;lt; n; i++) { string str; cin &amp;gt;&amp;gt; str; for(int j=0; j &amp;lt; m; j++) map[i][j] = str[j]; } int R = 0; int G = 0; int B = 0; int RG = 0; for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; m; j++) { if(!Rvisited[i][j] &amp;amp;&amp;amp; map[i][j] == &#39;R&#39;) { R++; Rdfs(i, j); } if(!Gvisited[i][j] &amp;amp;&amp;amp; map[i][j] == &#39;G&#39;) { G++; Gdfs(i, j); } if(!Bvisited[i][j] &amp;amp;&amp;amp; map[i][j] == &#39;B&#39;) { B++; Bdfs(i, j); } if(!RGvisited[i][j] &amp;amp;&amp;amp; (map[i][j] == &#39;R&#39; || map[i][j] == &#39;G&#39;)) { RG++; RGdfs(i, j); } } cout &amp;lt;&amp;lt; R + G + B &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; RG + B &amp;lt;&amp;lt; endl; // // map 출력 // for(int i=0; i &amp;lt; n; i++) // { // for(int j=0; j &amp;lt; m; j++) // cout &amp;lt;&amp;lt; map[i][j] &amp;lt;&amp;lt; &quot; &quot;; // cout &amp;lt;&amp;lt; endl; // } return 0;}SOL R, G, B , RG 각각의 dfs를 따로두어 각각의 영역의 개수를 각각 구한다.Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startDFS 깊이 우선 탐색" }, { "title": "BOJ - 4179 - 불!", "url": "/posts/BOJ-4179/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, graph, bfs", "date": "2022-08-22 11:10:00 +0900", "snippet": "BOJ - 4179 - 불!문제4179번: 불!문제지훈이는 미로에서 일을 한다. 지훈이를 미로에서 탈출하도록 도와주자!미로에서의 지훈이의 위치와 불이 붙은 위치를 감안해서 지훈이가 불에 타기전에 탈출할 수 있는지의 여부, 그리고 얼마나 빨리 탈출할 수 있는지를 결정해야한다.지훈이와 불은 매 분마다 한칸씩 수평또는 수직으로(비스듬하게 이동하지 않는다)  이동한다.불은 각 지점에서 네 방향으로 확산된다.지훈이는 미로의 가장자리에 접한 공간에서 탈출할 수 있다.지훈이와 불은 벽이 있는 공간은 통과하지 못한다.입력입력의 첫째 줄에는 공백으로 구분된 두 정수 R과 C가 주어진다. 단, 1 ≤ R, C ≤ 1000 이다. R은 미로 행의 개수, C는 열의 개수이다.다음 입력으로 R줄동안 각각의 미로 행이 주어진다.각각의 문자들은 다음을 뜻한다. #: 벽 .: 지나갈 수 있는 공간 J: 지훈이의 미로에서의 초기위치 (지나갈 수 있는 공간) F: 불이 난 공간J는 입력에서 하나만 주어진다.출력지훈이가 불이 도달하기 전에 미로를 탈출 할 수 없는 경우 IMPOSSIBLE 을 출력한다.지훈이가 미로를 탈출할 수 있는 경우에는 가장 빠른 탈출시간을 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;// mapint n, m;int map[1004][1004];int Jvisited[1004][1004];int Fvisited[1004][1004];// joyint dy[] = {-1, 0, 1, 0};int dx[] = {0, 1, 0, -1};// x, yint x, y, jx, jy, fx, fy;vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; v;// q queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; fq;queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; jq;int main(){ cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; // map 이진화 for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; m; j++) { char tmp; cin &amp;gt;&amp;gt; tmp; if(tmp == &#39;#&#39;) map[i][j] = 1; else if(tmp == &#39;.&#39;) map[i][j] = 0; else if(tmp == &#39;J&#39;) { jy = i; jx = j; } else { fq.push({i, j}); Fvisited[i][j] = 1; } } jq.push({jy, jx}); Jvisited[jy][jx] = 1; // 최단거리 while (fq.size()) { fx = fq.front().second; fy = fq.front().first; fq.pop(); for(int i=0; i &amp;lt; 4; i++) { int ny = fy + dy[i]; int nx = fx + dx[i]; if(ny &amp;lt; 0 || nx &amp;lt; 0|| ny &amp;gt;= n || nx &amp;gt;= m) continue; // 벽일 경우, 이미 방문 했을 경우 if(map[ny][nx] || Fvisited[ny][nx]) continue; Fvisited[ny][nx] = Fvisited[fy][fx] + 1; fq.push({ny, nx}); } } while(jq.size()) { y = jq.front().first; x = jq.front().second; jq.pop(); for(int i=0; i &amp;lt; 4; i++) { int ny = y + dy[i]; int nx = x + dx[i]; if(ny &amp;lt; 0 || nx &amp;lt; 0|| ny &amp;gt;= n || nx &amp;gt;= m) continue; // 벽일 경우, 이미 방문 했을 경우 if(map[ny][nx] || Jvisited[ny][nx]) continue; Jvisited[ny][nx] = Jvisited[y][x] + 1; jq.push({ny, nx}); } } // 불을 피해가는 최단거리 값 for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; m; j++) if(Jvisited[i][j] &amp;gt;= Fvisited[i][j] &amp;amp;&amp;amp; Fvisited[i][j]) Jvisited[i][j] = 0; int min = 9999; for(int i=0; i &amp;lt; n; i++) { if(i == 0 || i == n-1) { for(int j=0; j &amp;lt; m; j++) if(min &amp;gt; Jvisited[i][j] &amp;amp;&amp;amp; Jvisited[i][j]) min = Jvisited[i][j]; } else { if(min &amp;gt; Jvisited[i][0] &amp;amp;&amp;amp; Jvisited[i][0]) min = Jvisited[i][0]; else if(min &amp;gt; Jvisited[i][m-1] &amp;amp;&amp;amp; Jvisited[i][m-1]) min = Jvisited[i][m-1]; } } // map 출력 // cout &amp;lt;&amp;lt; &quot;---------------&quot; &amp;lt;&amp;lt; endl; // for(int i=0; i &amp;lt; n; i++) // { // for(int j=0; j &amp;lt; m; j++) // { // cout &amp;lt;&amp;lt; Jvisited[i][j] &amp;lt;&amp;lt; &quot; &quot;; // } // cout &amp;lt;&amp;lt; endl; // } // 출구가 존재하면 if(min != 9999) cout &amp;lt;&amp;lt; min &amp;lt;&amp;lt; endl; else cout &amp;lt;&amp;lt; &quot;IMPOSSIBLE &quot; &amp;lt;&amp;lt; endl; return 0;}SOL map 이진화 불, 이동경로 BFS를 각각 따로 생성 불 BFS 실행 후 이동경로 BFS 실행 불, 이동경로의 visited를 비교 후 동일 좌표에서 불 보다 큰 값을 가지고 있으면 0으로 초기화. map의 가장자리를 모두 탐색하여 최솟 값 추출 없다면 IMPOSSIBLE 출력Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startBFS 너비 우선 탐색" }, { "title": "BOJ - 2573 - 빙산", "url": "/posts/BOJ-2573/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, graph, dfs", "date": "2022-08-19 11:10:00 +0900", "snippet": "BOJ - 2573 - 빙산문제2573번: 빙산문제지구 온난화로 인하여 북극의 빙산이 녹고 있다. 빙산을 그림 1과 같이 2차원 배열에 표시한다고 하자. 빙산의 각 부분별 높이 정보는 배열의 각 칸에 양의 정수로 저장된다. 빙산 이외의 바다에 해당되는 칸에는 0이 저장된다. 그림 1에서 빈칸은 모두 0으로 채워져 있다고 생각한다.빙산의 높이는 바닷물에 많이 접해있는 부분에서 더 빨리 줄어들기 때문에, 배열에서 빙산의 각 부분에 해당되는 칸에 있는 높이는 일년마다 그 칸에 동서남북 네 방향으로 붙어있는 0이 저장된 칸의 개수만큼 줄어든다. 단, 각 칸에 저장된 높이는 0보다 더 줄어들지 않는다. 바닷물은 호수처럼 빙산에 둘러싸여 있을 수도 있다. 따라서 그림 1의 빙산은 일년후에 그림 2와 같이 변형된다.그림 3은 그림 1의 빙산이 2년 후에 변한 모습을 보여준다. 2차원 배열에서 동서남북 방향으로 붙어있는 칸들은 서로 연결되어 있다고 말한다. 따라서 그림 2의 빙산은 한 덩어리이지만, 그림 3의 빙산은 세 덩어리로 분리되어 있다.한 덩어리의 빙산이 주어질 때, 이 빙산이 두 덩어리 이상으로 분리되는 최초의 시간(년)을 구하는 프로그램을 작성하시오. 그림 1의 빙산에 대해서는 2가 답이다. 만일 전부 다 녹을 때까지 두 덩어리 이상으로 분리되지 않으면 프로그램은 0을 출력한다.입력첫 줄에는 이차원 배열의 행의 개수와 열의 개수를 나타내는 두 정수 N과 M이 한 개의 빈칸을 사이에 두고 주어진다. N과 M은 3 이상 300 이하이다. 그 다음 N개의 줄에는 각 줄마다 배열의 각 행을 나타내는 M개의 정수가 한 개의 빈 칸을 사이에 두고 주어진다. 각 칸에 들어가는 값은 0 이상 10 이하이다. 배열에서 빙산이 차지하는 칸의 개수, 즉, 1 이상의 정수가 들어가는 칸의 개수는 10,000 개 이하이다. 배열의 첫 번째 행과 열, 마지막 행과 열에는 항상 0으로 채워진다.출력첫 줄에 빙산이 분리되는 최초의 시간(년)을 출력한다. 만일 빙산이 다 녹을 때까지 분리되지 않으면 0을 출력한다.구현#include &amp;lt;iostream&amp;gt;using namespace std;//mapint n, m;int map[301][301];bool visited[301][301];// joy int dy[] = {-1, 0, 1, 0};int dx[] = {0, 1, 0, -1};// x, yint x, y;void dfs(int y, int x){ visited[y][x] = 1; for(int i=0; i &amp;lt; 4; i++) { int ny = y + dy[i]; int nx = x + dx[i]; // 범위 값 확인 if(ny &amp;lt; 0 || nx &amp;lt; 0 || ny &amp;gt;= n || nx &amp;gt;= m) continue; if(visited[ny][nx]) continue; if(!map[ny][nx]) { map[y][x] -= 1; if(!map[y][x]) return; else continue; } dfs(ny, nx); } return;}void check_dfs(int y, int x){ visited[y][x] = 1; for(int i=0; i &amp;lt; 4; i++) { int ny = y + dy[i]; int nx = x + dx[i]; // 범위 값 확인 if(ny &amp;lt; 0 || nx &amp;lt; 0 || ny &amp;gt;= n || nx &amp;gt;= m) continue; if(visited[ny][nx] || !map[ny][nx]) continue; check_dfs(ny, nx); } return;}int main(){ ios_base :: sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; // map input for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; m; j++) cin &amp;gt;&amp;gt; map[i][j]; int ans = 0; while(1) { // 빙산 녹이기 int count = 0; for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; m; j++) { if(map[i][j]) count += map[i][j]; if(!visited[i][j] &amp;amp;&amp;amp; map[i][j]) dfs(i, j); } // 방문 초기화 fill(&amp;amp;visited[0][0], &amp;amp;visited[n][m], 0); // 빙산의 개수 측정 int cnt = 0; for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; m; j++) if(!visited[i][j] &amp;amp;&amp;amp; map[i][j]) { check_dfs(i, j); cnt++; } // 방문 초기화 fill(&amp;amp;visited[0][0], &amp;amp;visited[n][m], 0); // 빙산 개수 확인 check dfs //map 출력 // cout &amp;lt;&amp;lt; &quot;-----------&quot; &amp;lt;&amp;lt; endl; // for(int i=0; i &amp;lt; n; i++) // { // for(int j=0; j &amp;lt; m; j++) // cout &amp;lt;&amp;lt; map[i][j] &amp;lt;&amp;lt; &quot; &quot;; // cout &amp;lt;&amp;lt; endl; // } // 걸리는 일수 ++ ans++; // 빙산이 두조각 이상으로 쪼개지면 종료 if(cnt &amp;gt;= 2) break; // 빙산이 두조각으로 쪼개지지 않고 빙산이 녹아 없어지면 0으로 반환 및 종료 if(!count) { ans = 0; break; } } cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; &#39;\\n&#39;; return 0;}SOL 빙산을 녹일 dfs, 빙산의 개수를 새어 줄 dfs를 각각 만들어 확인 후 해결한다. 단. 빙산이 완전히 녹아 없어질 때 까지 한덩이면 0으로 반환 후 출력한다.Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startDFS 깊이 우선 탐색" }, { "title": "BOJ - 7576 - 토마토", "url": "/posts/BOJ-7576/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, graph, bfs", "date": "2022-08-17 11:10:00 +0900", "snippet": "BOJ - 7576 - 토마토문제7576번: 토마토문제철수의 토마토 농장에서는 토마토를 보관하는 큰 창고를 가지고 있다. 토마토는 아래의 그림과 같이 격자 모양 상자의 칸에 하나씩 넣어서 창고에 보관한다.창고에 보관되는 토마토들 중에는 잘 익은 것도 있지만, 아직 익지 않은 토마토들도 있을 수 있다. 보관 후 하루가 지나면, 익은 토마토들의 인접한 곳에 있는 익지 않은 토마토들은 익은 토마토의 영향을 받아 익게 된다. 하나의 토마토의 인접한 곳은 왼쪽, 오른쪽, 앞, 뒤 네 방향에 있는 토마토를 의미한다. 대각선 방향에 있는 토마토들에게는 영향을 주지 못하며, 토마토가 혼자 저절로 익는 경우는 없다고 가정한다. 철수는 창고에 보관된 토마토들이 며칠이 지나면 다 익게 되는지, 그 최소 일수를 알고 싶어 한다.토마토를 창고에 보관하는 격자모양의 상자들의 크기와 익은 토마토들과 익지 않은 토마토들의 정보가 주어졌을 때, 며칠이 지나면 토마토들이 모두 익는지, 그 최소 일수를 구하는 프로그램을 작성하라. 단, 상자의 일부 칸에는 토마토가 들어있지 않을 수도 있다.입력첫 줄에는 상자의 크기를 나타내는 두 정수 M,N이 주어진다. M은 상자의 가로 칸의 수, N은 상자의 세로 칸의 수를 나타낸다. 단, 2 ≤ M,N ≤ 1,000 이다. 둘째 줄부터는 하나의 상자에 저장된 토마토들의 정보가 주어진다. 즉, 둘째 줄부터 N개의 줄에는 상자에 담긴 토마토의 정보가 주어진다. 하나의 줄에는 상자 가로줄에 들어있는 토마토의 상태가 M개의 정수로 주어진다. 정수 1은 익은 토마토, 정수 0은 익지 않은 토마토, 정수 -1은 토마토가 들어있지 않은 칸을 나타낸다.토마토가 하나 이상 있는 경우만 입력으로 주어진다.출력여러분은 토마토가 모두 익을 때까지의 최소 날짜를 출력해야 한다. 만약, 저장될 때부터 모든 토마토가 익어있는 상태이면 0을 출력해야 하고, 토마토가 모두 익지는 못하는 상황이면 -1을 출력해야 한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;// map int n, m;int map[1004][1004];int visited[1004][1004];// joyint dy[] = {-1, 0, 1, 0};int dx[] = {0, 1, 0, -1};// 현 위치, 익은 토마도 위치int x, y, tx, ty;vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; v;int main(){ cin &amp;gt;&amp;gt; m &amp;gt;&amp;gt; n; for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; m; j++) { cin &amp;gt;&amp;gt; map[i][j]; // 익은 도마도 위치 if(map[i][j] == 1) v.push_back({i, j}); } queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; q; // 초기 위치 입력, 방문처리 for(auto &amp;amp;el : v) { // 익은 토마토가 2개 이상일 경우 q.push({el.first, el.second}); visited[el.first][el.second] = 1; map[el.first][el.second] = 1004; } int ans; while (q.size()) { y = q.front().first; x = q.front().second; q.pop(); for(int i=0; i &amp;lt; 4; i++) { int ny = y + dy[i]; int nx = x + dx[i]; // 범위값 확인 if(ny &amp;lt; 0 || ny &amp;gt;= n || nx &amp;lt; 0 || nx &amp;gt;= m || map[ny][nx] == -1) continue; if(visited[ny][nx]) continue; visited[ny][nx] = visited[y][x] + 1; map[ny][nx] = 1004; q.push({ny, nx}); } } bool flag = 0; int max = 0; for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; m; j++) { // 익지 않은 토마토가 있을 경우 if(!map[i][j]) { flag = 1; break; } if(max &amp;lt; visited[i][j]) max = visited[i][j]; } if(flag) cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; endl; else cout &amp;lt;&amp;lt; max - 1 &amp;lt;&amp;lt; endl; // map 출력 // for(int i=0; i &amp;lt; n; i++) // { // for(int j=0; j &amp;lt; m; j++) // cout &amp;lt;&amp;lt; visited[i][j] &amp;lt;&amp;lt; &quot; &quot;; // cout &amp;lt;&amp;lt; endl; // } return 0;}SOL 익은 토마토가 2개 이상일 경우 익은 토마토들의 좌표를 벡터에 동척 할당 하여 처리한다. BFS사용Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startBFS 너비 우선 탐색" }, { "title": "BOJ - 7569 - 토마토 2", "url": "/posts/BOJ-7569/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, graph, bfs", "date": "2022-08-17 11:10:00 +0900", "snippet": "BOJ - 7569 - 토마토 2문제7569번: 토마토문제철수의 토마토 농장에서는 토마토를 보관하는 큰 창고를 가지고 있다. 토마토는 아래의 그림과 같이 격자모양 상자의 칸에 하나씩 넣은 다음, 상자들을 수직으로 쌓아 올려서 창고에 보관한다.창고에 보관되는 토마토들 중에는 잘 익은 것도 있지만, 아직 익지 않은 토마토들도 있을 수 있다. 보관 후 하루가 지나면, 익은 토마토들의 인접한 곳에 있는 익지 않은 토마토들은 익은 토마토의 영향을 받아 익게 된다. 하나의 토마토에 인접한 곳은 위, 아래, 왼쪽, 오른쪽, 앞, 뒤 여섯 방향에 있는 토마토를 의미한다. 대각선 방향에 있는 토마토들에게는 영향을 주지 못하며, 토마토가 혼자 저절로 익는 경우는 없다고 가정한다. 철수는 창고에 보관된 토마토들이 며칠이 지나면 다 익게 되는지 그 최소 일수를 알고 싶어 한다.토마토를 창고에 보관하는 격자모양의 상자들의 크기와 익은 토마토들과 익지 않은 토마토들의 정보가 주어졌을 때, 며칠이 지나면 토마토들이 모두 익는지, 그 최소 일수를 구하는 프로그램을 작성하라. 단, 상자의 일부 칸에는 토마토가 들어있지 않을 수도 있다.입력첫 줄에는 상자의 크기를 나타내는 두 정수 M,N과 쌓아올려지는 상자의 수를 나타내는 H가 주어진다. M은 상자의 가로 칸의 수, N은 상자의 세로 칸의 수를 나타낸다. 단, 2 ≤ M ≤ 100, 2 ≤ N ≤ 100, 1 ≤ H ≤ 100 이다. 둘째 줄부터는 가장 밑의 상자부터 가장 위의 상자까지에 저장된 토마토들의 정보가 주어진다. 즉, 둘째 줄부터 N개의 줄에는 하나의 상자에 담긴 토마토의 정보가 주어진다. 각 줄에는 상자 가로줄에 들어있는 토마토들의 상태가 M개의 정수로 주어진다. 정수 1은 익은 토마토, 정수 0 은 익지 않은 토마토, 정수 -1은 토마토가 들어있지 않은 칸을 나타낸다. 이러한 N개의 줄이 H번 반복하여 주어진다.토마토가 하나 이상 있는 경우만 입력으로 주어진다.출력여러분은 토마토가 모두 익을 때까지 최소 며칠이 걸리는지를 계산해서 출력해야 한다. 만약, 저장될 때부터 모든 토마토가 익어있는 상태이면 0을 출력해야 하고, 토마토가 모두 익지는 못하는 상황이면 -1을 출력해야 한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;// map int n, m, h;int map[104][104][104];int visited[104][104][104];// joyint dy[] = {0, 0, -1, 0, 1, 0};int dx[] = {0, 0, 0, 1, 0, -1};int dz[] = {1, -1, 0, 0, 0, 0};// 현 위치, 익은 토마도 위치int x, y, z;class tomato{public: int tx, ty, tz;};vector&amp;lt;tomato&amp;gt; v;queue&amp;lt;tomato&amp;gt; q;int main(){ cin &amp;gt;&amp;gt; m &amp;gt;&amp;gt; n &amp;gt;&amp;gt; h; for(int k=0; k &amp;lt; h; k++) for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; m; j++) { cin &amp;gt;&amp;gt; map[k][i][j]; // 익은 도마도 위치 if(map[k][i][j] == 1) v.push_back({j, i, k}); } // 초기 위치 입력, 방문처리 for(auto &amp;amp;el : v) { // 익은 토마토가 2개 이상일 경우 q.push({el.tx, el.ty, el.tz}); visited[el.tz][el.ty][el.tx] = 1; map[el.tz][el.ty][el.tx] = 1004; } while (q.size()) { z = q.front().tz; y = q.front().ty; x = q.front().tx; q.pop(); for(int i=0; i &amp;lt; 6; i++) { int nz = z + dz[i]; int ny = y + dy[i]; int nx = x + dx[i]; // 범위값 확인 if(nz &amp;lt; 0 || nz &amp;gt;= h || ny &amp;lt; 0 || ny &amp;gt;= n || nx &amp;lt; 0 || nx &amp;gt;= m || map[nz][ny][nx] == -1) continue; if(visited[nz][ny][nx]) continue; visited[nz][ny][nx] = visited[z][y][x] + 1; map[nz][ny][nx] = 1004; q.push({nx, ny, nz}); } } bool flag = 0; int max = 0; for(int k=0; k &amp;lt; h; k++) for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; m; j++) { // 익지 않은 토마토가 있을 경우 if(!map[k][i][j]) { flag = 1; break; } if(max &amp;lt; visited[k][i][j]) max = visited[k][i][j]; } if(flag) cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; endl; else cout &amp;lt;&amp;lt; max - 1 &amp;lt;&amp;lt; endl; // map 출력 // for(int k=0; k &amp;lt; h; k++) // { // for(int i=0; i &amp;lt; n; i++) // { // for(int j=0; j &amp;lt; m; j++) // cout &amp;lt;&amp;lt; visited[k][i][j] &amp;lt;&amp;lt; &quot; &quot;; // cout &amp;lt;&amp;lt; endl; // } // cout &amp;lt;&amp;lt; &quot;---------&quot; &amp;lt;&amp;lt; endl; // } return 0;}SOL 익은 토마토가 2개 이상일 경우 익은 토마토들의 좌표를 벡터에 동척 할당 하여 처리한다. BFS사용 앞서 풀었던 토마토 문제와 푸는 방식은 동일함. 단지 2차원에서 3차원으로 바뀐것 뿐Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startBFS 너비 우선 탐색" }, { "title": "BOJ - 2483 - 영역 구하기", "url": "/posts/BOJ-2483/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, graph, dfs", "date": "2022-08-16 11:10:00 +0900", "snippet": "BOJ - 2583 - 영역 구하기문제2583번: 영역 구하기문제눈금의 간격이 1인 M×N(M,N≤100)크기의 모눈종이가 있다. 이 모눈종이 위에 눈금에 맞추어 K개의 직사각형을 그릴 때, 이들 K개의 직사각형의 내부를 제외한 나머지 부분이 몇 개의 분리된 영역으로 나누어진다.예를 들어 M=5, N=7 인 모눈종이 위에 &amp;lt;그림 1&amp;gt;과 같이 직사각형 3개를 그렸다면, 그 나머지 영역은 &amp;lt;그림 2&amp;gt;와 같이 3개의 분리된 영역으로 나누어지게 된다.&amp;lt;그림 2&amp;gt;와 같이 분리된 세 영역의 넓이는 각각 1, 7, 13이 된다.M, N과 K 그리고 K개의 직사각형의 좌표가 주어질 때, K개의 직사각형 내부를 제외한 나머지 부분이 몇 개의 분리된 영역으로 나누어지는지, 그리고 분리된 각 영역의 넓이가 얼마인지를 구하여 이를 출력하는 프로그램을 작성하시오.입력첫째 줄에 M과 N, 그리고 K가 빈칸을 사이에 두고 차례로 주어진다. M, N, K는 모두 100 이하의 자연수이다. 둘째 줄부터 K개의 줄에는 한 줄에 하나씩 직사각형의 왼쪽 아래 꼭짓점의 x, y좌표값과 오른쪽 위 꼭짓점의 x, y좌표값이 빈칸을 사이에 두고 차례로 주어진다. 모눈종이의 왼쪽 아래 꼭짓점의 좌표는 (0,0)이고, 오른쪽 위 꼭짓점의 좌표는(N,M)이다. 입력되는 K개의 직사각형들이 모눈종이 전체를 채우는 경우는 없다.출력첫째 줄에 분리되어 나누어지는 영역의 개수를 출력한다. 둘째 줄에는 각 영역의 넓이를 오름차순으로 정렬하여 빈칸을 사이에 두고 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;// x1, y1, x2, y2 사각형의 영역 칠하기 // mapbool map[101][101];bool visited[101][101];// 현 위치int x, y;// joyint dy[] = {-1, 0, 1, 0};int dx[] = {0, 1, 0, -1};int m, n, a;int cnt=0;void dfs(int y, int x){ visited[y][x] = 1; cnt++; // joy for(int i=0; i &amp;lt; 4; i++) { int ny = y + dy[i]; int nx = x + dx[i]; // 범위 확인 if(ny &amp;lt; 0 || nx &amp;lt; 0 || ny &amp;gt;= m || nx &amp;gt;= n) continue; // 갈 수 있는 구간이고, 방문하지 않았더라면 if(!map[ny][nx] &amp;amp;&amp;amp; !visited[ny][nx]) dfs(ny, nx); } return;}int main(){ cin &amp;gt;&amp;gt; m &amp;gt;&amp;gt; n &amp;gt;&amp;gt; a; for(int i=0; i &amp;lt; a; i++) { int x1, x2, y1, y2; cin &amp;gt;&amp;gt; x1 &amp;gt;&amp;gt; y1 &amp;gt;&amp;gt; x2 &amp;gt;&amp;gt; y2; for(int j=y1; j &amp;lt; y2; j++) for(int k=x1; k &amp;lt; x2; k++) map[j][k] = 1; } int ans=0; // map 탐색 vector&amp;lt;int&amp;gt; v; for(int i=0; i &amp;lt; m; i++) for(int j=0; j &amp;lt; n; j++) if(!map[i][j] &amp;amp;&amp;amp; !visited[i][j]) { ans++; dfs(i, j); v.push_back(cnt); cnt = 0; } sort(v.begin(), v.end()); cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl; for(auto &amp;amp;el : v) cout &amp;lt;&amp;lt; el &amp;lt;&amp;lt; &quot; &quot;; cout &amp;lt;&amp;lt; endl; // map 출력 // for(int i=0; i &amp;lt; m; i++) // { // for(int j=0; j &amp;lt; n; j++) // cout &amp;lt;&amp;lt; map[i][j] &amp;lt;&amp;lt; &quot; &quot;; // cout &amp;lt;&amp;lt; endl; // } return 0;}SOL 맵에 직사각형이 포함된 부분을 1로 표기 즉, 벽으로 처리한다. dfs함수를 한번 호출할 때마다 cnt 하여 직사각형이 없는 공간의 넓이를 구한다. 구한 넓이를 벡터를 이용하여 동적 할당 후 오름차순으로 정리, 출력한다.Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startDFS 깊이 우선 탐색" }, { "title": "BOJ - 2468 - 안전 지대", "url": "/posts/BOJ-2468/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, graph, dfs", "date": "2022-08-16 11:10:00 +0900", "snippet": "BOJ - 2468 - 안전 지대문제2468번: 안전 영역문제재난방재청에서는 많은 비가 내리는 장마철에 대비해서 다음과 같은 일을 계획하고 있다. 먼저 어떤 지역의 높이 정보를 파악한다. 그 다음에 그 지역에 많은 비가 내렸을 때 물에 잠기지 않는 안전한 영역이 최대로 몇 개가 만들어 지는 지를 조사하려고 한다. 이때, 문제를 간단하게 하기 위하여, 장마철에 내리는 비의 양에 따라 일정한 높이 이하의 모든 지점은 물에 잠긴다고 가정한다.어떤 지역의 높이 정보는 행과 열의 크기가 각각 N인 2차원 배열 형태로 주어지며 배열의 각 원소는 해당 지점의 높이를 표시하는 자연수이다. 예를 들어, 다음은 N=5인 지역의 높이 정보이다.이제 위와 같은 지역에 많은 비가 내려서 높이가 4 이하인 모든 지점이 물에 잠겼다고 하자. 이 경우에 물에 잠기는 지점을 회색으로 표시하면 다음과 같다.물에 잠기지 않는 안전한 영역이라 함은 물에 잠기지 않는 지점들이 위, 아래, 오른쪽 혹은 왼쪽으로 인접해 있으며 그 크기가 최대인 영역을 말한다. 위의 경우에서 물에 잠기지 않는 안전한 영역은 5개가 된다(꼭짓점으로만 붙어 있는 두 지점은 인접하지 않는다고 취급한다).또한 위와 같은 지역에서 높이가 6이하인 지점을 모두 잠기게 만드는 많은 비가 내리면 물에 잠기지 않는 안전한 영역은 아래 그림에서와 같이 네 개가 됨을 확인할 수 있다.이와 같이 장마철에 내리는 비의 양에 따라서 물에 잠기지 않는 안전한 영역의 개수는 다르게 된다. 위의 예와 같은 지역에서 내리는 비의 양에 따른 모든 경우를 다 조사해 보면 물에 잠기지 않는 안전한 영역의 개수 중에서 최대인 경우는 5임을 알 수 있다.어떤 지역의 높이 정보가 주어졌을 때, 장마철에 물에 잠기지 않는 안전한 영역의 최대 개수를 계산하는 프로그램을 작성하시오.입력첫째 줄에는 어떤 지역을 나타내는 2차원 배열의 행과 열의 개수를 나타내는 수 N이 입력된다. N은 2 이상 100 이하의 정수이다. 둘째 줄부터 N개의 각 줄에는 2차원 배열의 첫 번째 행부터 N번째 행까지 순서대로 한 행씩 높이 정보가 입력된다. 각 줄에는 각 행의 첫 번째 열부터 N번째 열까지 N개의 높이 정보를 나타내는 자연수가 빈 칸을 사이에 두고 입력된다. 높이는 1이상 100 이하의 정수이다.출력첫째 줄에 장마철에 물에 잠기지 않는 안전한 영역의 최대 개수를 출력한다.구현#include &amp;lt;iostream&amp;gt;using namespace std;// map int n;int map[101][101];bool mp[101][101];bool visited[101][101];// joyint dy[] = {-1, 0, 1, 0};int dx[] = {0, 1, 0, -1};// 현 위치 int x, y;void dfs(int y, int x){ // 방문 visited[y][x] = 1; for(int i=0; i &amp;lt; 4; i++) { int ny = y + dy[i]; int nx = x + dx[i]; // map을 벗어나면 if(ny &amp;lt; 0 || nx &amp;lt; 0 || ny &amp;gt;= n || nx &amp;gt;= n) continue; // 안전구역이고, 방문하지 않았더라면 if(mp[ny][nx] &amp;amp;&amp;amp; !visited[ny][nx]) dfs(ny, nx); } return;}// 침수지역 표기 int main(){ cin &amp;gt;&amp;gt; n; int ans = -1; for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; n; j++) cin &amp;gt;&amp;gt; map[i][j]; for(int k=0; k &amp;lt; 101; k++) { for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; n; j++) { // 안전지역일 경우 1로 표기 if(map[i][j] &amp;gt; k) mp[i][j] = 1; } // 안전지역 탐색 int cnt=0; for(int i=0; i &amp;lt; n; i++) for(int j=0; j &amp;lt; n; j++) if(mp[i][j] &amp;amp;&amp;amp; !visited[i][j]) { cnt++; dfs(i, j); } if(ans &amp;lt; cnt) ans = cnt; // 초기화 for(int i=0; i &amp;lt; 101; i++) for(int j=0; j &amp;lt; 101; j++) { mp[i][j] = 0; visited[i][j] = 0; } } cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl; return 0;}SOL 임시 맵과 안전지대 맵을 따로두어 안전지대의 높이를 0~101 까지의 범위를 탐색하여 최댓값을 출력한다.Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startDFS 깊이 우선 탐색" }, { "title": "BFS 너비 우선 탐색", "url": "/posts/bfs/", "categories": "algorithm, graph", "tags": "algorithm, graph, bfs", "date": "2022-08-16 11:10:00 +0900", "snippet": "BFS 너비 우선 탐색개요BFS 너비우선탐색BFS는 그래프를 탐색하는 알고리즘으로 노드에서 시작해 이웃한 노드들을 우선적으로 탐색하는 알고리즘 이다.같은 가중치를 가진 그래프에서 최단거리를 구할 때 사용되는 알고리즘이다.시간 복잡도는 앞의 포스팅에서 소개한 DFS와 같으며 주어진 맵 전체를 탐색하며 한번 방문한 노드는 다시 방문하지 않기에 인접 리스트로 이뤄진 맵인 경우O(V + E)인접 행렬로 이뤄진 경우O(V^2)만약 가중치가 다른 그래프 내의 최단거리를 구해야 할 경우는 다익스트라, 벨만포드 알고리즘을 사용해야 한다.너비 우선 탐색 (BFS) 특정 노드에서 가장 먼 곳의 노드부터 순차적으로 탐색한다.수도코드아래는 BFS의 수도코드다.BFS(G, u) u.visited = 1 q.push(u); while(q.size()) u = q.front() q.pop() for each v ∈ G.Adj[u] if v.visited == false v.visited = u.visited + 1 q.push(v) [출처] [알고리즘 강의] 2주차. 그래프이론, DFS, BFS, 트리순회 작성자 큰돌 특징이전에 방문하지 않았더라면 가중치를 적용시켜 방문좌표에 가중치를 더한다.BFS함수를 반복으로 호출하는 방법을 쓰며, 만약 이전에 방문을 했더라면 함수를 종료 시킨다.예시문제 입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트 케이스에 대해 첫째 줄에는 배추를 심은 배추밭의 가로길이 M(1 ≤ M ≤ 50)과 세로길이 N(1 ≤ N ≤ 50), 그리고 배추가 심어져 있는 위치의 개수 K(1 ≤ K ≤ 2500)이 주어진다. 그 다음 K줄에는 배추의 위치 X(0 ≤ X ≤ M-1), Y(0 ≤ Y ≤ N-1)가 주어진다. 두 배추의 위치가 같은 경우는 없다.2178번: 미로 탐색문제N×M크기의 배열로 표현되는 미로가 있다.미로에서 1은 이동할 수 있는 칸을 나타내고, 0은 이동할 수 없는 칸을 나타낸다. 이러한 미로가 주어졌을 때, (1, 1)에서 출발하여 (N, M)의 위치로 이동할 때 지나야 하는 최소의 칸 수를 구하는 프로그램을 작성하시오. 한 칸에서 다른 칸으로 이동할 때, 서로 인접한 칸으로만 이동할 수 있다.위의 예에서는 15칸을 지나야 (N, M)의 위치로 이동할 수 있다. 칸을 셀 때에는 시작 위치와 도착 위치도 포함한다.입력첫째 줄에 두 정수 N, M(2 ≤ N, M ≤ 100)이 주어진다. 다음 N개의 줄에는 M개의 정수로 미로가 주어진다. 각각의 수들은 붙어서 입력으로 주어진다.출력첫째 줄에 지나야 하는 최소의 칸 수를 출력한다. 항상 도착위치로 이동할 수 있는 경우만 입력으로 주어진다.SOLjoy를 이용해 가야할 위치에 방문한 위치값 + 1 의 가중치를 이용하여 해결한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std;// joy int dy[] = {-1, 0, 1, 0};int dx[] = {0, 1, 0, -1};// map bool map[101][101];int visited [101][101];// map 크기 int n, m;// 현 위치 int x, y;int main(){ cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; for(int i=0; i &amp;lt; n; i++) { string str; cin &amp;gt;&amp;gt; str; // map 생성 for(int j=0; j &amp;lt; m; j++) { if(str[j] == &#39;1&#39;) map[i][j] = 1; } } // (1, 1)에서 출발 함으로 해당 좌표 방문처리 visited[0][0] = 1; queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; q; // 방문한 곳 푸쉬 q.push({0, 0}); while(q.size()) { // 현재 위치 값 초기화 y = q.front().first; x = q.front().second; q.pop(); // joy 탐색 for(int i=0; i &amp;lt; 4; i++) { int ny = y + dy[i]; int nx = x + dx[i]; // 범위 값을 넘어갈 경우, 이미 방문한 경우, 벽인 경우 if(ny &amp;lt; 0 || nx &amp;lt; 0 || ny &amp;gt;= n || nx &amp;gt;= m || !map[ny][nx]) continue; if(visited[ny][nx]) continue; // 위 조건이 아닐 경우 가산 값 추가 visited[ny][nx] += visited[y][x] + 1; // 방문한 다음 위치 다시 푸쉬 q.push({ny, nx}); } } // 최단 거리 맵 출력 // for(int i=0; i &amp;lt; n; i++) // { // for(int j=0; j &amp;lt; m; j++) // { // cout &amp;lt;&amp;lt; visited[i][j] &amp;lt;&amp;lt; &quot; &quot;; // } // cout &amp;lt;&amp;lt; endl; // } cout &amp;lt;&amp;lt; visited[n-1][m-1] &amp;lt;&amp;lt; endl; return 0;}Reference큰돌의 터전 : 네이버 블로그" }, { "title": "DFS 깊이 우선 탐색", "url": "/posts/dfs/", "categories": "algorithm, graph", "tags": "algorithm, graph, dfs", "date": "2022-08-11 11:10:00 +0900", "snippet": "DFS 깊이 우선 탐색개요DFS, 깊이우선탐색깊이 우선탐색은 그래프를 탐색할 때 쓰이는 알고리즘으로, 특정한 노드에서 가장 멀리 있는 노드를 우선적으로 탐색하는 알고리즘이다.주어진 맵 전체를 탐색하며, 한번 방문한 노드는 재 방문하지 않기에 인접한 리스트로 이루어진 맵이면O(V + E)인접 행렬로 이루어진 맵이면O(V^2)깊이 우선 탐색 (DFS) 특정 노드에서 가장 먼 곳의 노드부터 순차적으로 탐색한다.수도코드아래는 DFS의 수도코드다.DFS(G, u) u.visited = true for each v ∈ G.Adj[u] if v.visited == false DFS(G,v)특징방문할 수 있는 좌표이며, 이전에 방문하지 않았더라면DFS함수를 재귀적으로 호출하는 방법을 쓰며, 만약 이전에 방문을 했더라면 함수를 종료 시킨다.예시문제1012번: 유기농 배추문제차세대 영농인 한나는 강원도 고랭지에서 유기농 배추를 재배하기로 하였다. 농약을 쓰지 않고 배추를 재배하려면 배추를 해충으로부터 보호하는 것이 중요하기 때문에, 한나는 해충 방지에 효과적인 배추흰지렁이를 구입하기로 결심한다. 이 지렁이는 배추근처에 서식하며 해충을 잡아 먹음으로써 배추를 보호한다. 특히, 어떤 배추에 배추흰지렁이가 한 마리라도 살고 있으면 이 지렁이는 인접한 다른 배추로 이동할 수 있어, 그 배추들 역시 해충으로부터 보호받을 수 있다. 한 배추의 상하좌우 네 방향에 다른 배추가 위치한 경우에 서로 인접해있는 것이다.한나가 배추를 재배하는 땅은 고르지 못해서 배추를 군데군데 심어 놓았다. 배추들이 모여있는 곳에는 배추흰지렁이가 한 마리만 있으면 되므로 서로 인접해있는 배추들이 몇 군데에 퍼져있는지 조사하면 총 몇 마리의 지렁이가 필요한지 알 수 있다. 예를 들어 배추밭이 아래와 같이 구성되어 있으면 최소 5마리의 배추흰지렁이가 필요하다. 0은 배추가 심어져 있지 않은 땅이고, 1은 배추가 심어져 있는 땅을 나타낸다.입력입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트 케이스에 대해 첫째 줄에는 배추를 심은 배추밭의 가로길이 M(1 ≤ M ≤ 50)과 세로길이 N(1 ≤ N ≤ 50), 그리고 배추가 심어져 있는 위치의 개수 K(1 ≤ K ≤ 2500)이 주어진다. 그 다음 K줄에는 배추의 위치 X(0 ≤ X ≤ M-1), Y(0 ≤ Y ≤ N-1)가 주어진다. 두 배추의 위치가 같은 경우는 없다.출력각 테스트 케이스에 대해 필요한 최소의 배추흰지렁이 마리 수를 출력한다.SOL주어진 맵의 인접한 곳들은 모두 하나의 ans값으로 취급한다. 맵 생성 후 주어진 좌표에 배추를 심는다. 맵 전체를 순회 하면서 dfs를 실행시킨다.구현#include &amp;lt;iostream&amp;gt;using namespace std;// 배추밭, 방문여부, 배추밭의 크기int n, m;bool map[51][51];bool visited[51][51];// 좌표int x, y;// joyint dy[] = {-1, 0, 1, 0};int dx[] = {0, 1, 0, -1};void dfs(int y, int x){ // 방문 visited[y][x] = 1; // 동서남북 탐색 for(int i=0; i &amp;lt; 4; i++) { int ny = y + dy[i]; int nx = x + dx[i]; // 주어진 배추밭의 크기를 넘기면 콘티뉴 if(ny &amp;lt; 0 || ny &amp;gt;= n || nx &amp;lt; 0 || nx &amp;gt;= m) continue; // 배추가 존재하고, 방문하지 않을 경우 // 즉, 인접해 있을 경우 방문 if(map[ny][nx] == 1 &amp;amp;&amp;amp; !visited[ny][nx]) dfs(ny, nx); } // 인접하지 않을 경우 함수 종료 return;}int main(){ int num; cin &amp;gt;&amp;gt; num; for(int i=0; i &amp;lt; num; i++) { // 지렁이의 필요 개수 int ans = 0; // 배추밭의 크기, 배추의 개수 입력 int N; cin &amp;gt;&amp;gt; m &amp;gt;&amp;gt; n &amp;gt;&amp;gt; N; // 배추 심기 for(int j=0; j &amp;lt; N; j++) { int tmpx, tmpy; cin &amp;gt;&amp;gt; tmpx &amp;gt;&amp;gt; tmpy; map[tmpy][tmpx] = 1; } // 배추밭 탐색 for(int j=0; j &amp;lt; n; j++) for(int k=0; k &amp;lt; m; k++) // 배추가 존재하고, 방문하지 않았다면 if(map[j][k] == 1 &amp;amp;&amp;amp; !visited[j][k]) { ans++; dfs(j, k); } // 필요 지렁이 개수 출력 cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; &#39;\\n&#39;; //배추밭 출력 // for(int j=0; j &amp;lt; n; j++) // { // for(int k=0; k &amp;lt; m; k++) // cout &amp;lt;&amp;lt; map[j][k] &amp;lt;&amp;lt; &quot; &quot;; // cout &amp;lt;&amp;lt; endl; // } // 배추밭 초기화 for(int j=0; j &amp;lt; 51; j++) for(int k=0; k &amp;lt; 51; k++) { map[j][k] = 0; visited[j][k] = 0; } } return 0;}Reference큰돌의 터전 : 네이버 블로그" }, { "title": "BOJ - 11478 - 서로 다른 부분 문자열의 개수", "url": "/posts/BOJ-11478/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, hash, map, set", "date": "2022-07-25 11:10:00 +0900", "snippet": "BOJ - 11478 - 서로 다른 부분 문자열의 개수문제11478번: 서로 다른 부분 문자열의 개수문제문자열 S가 주어졌을 때, S의 서로 다른 부분 문자열의 개수를 구하는 프로그램을 작성하시오.부분 문자열은 S에서 연속된 일부분을 말하며, 길이가 1보다 크거나 같아야 한다.예를 들어, ababc의 부분 문자열은 a, b, a, b, c, ab, ba, ab, bc, aba, bab, abc, abab, babc, ababc가 있고, 서로 다른것의 개수는 12개이다.입력첫째 줄에 문자열 S가 주어진다. S는 알파벳 소문자로만 이루어져 있고, 길이는 1,000 이하이다.출력첫째 줄에 S의 서로 다른 부분 문자열의 개수를 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;set&amp;gt;using namespace std;int main(){ string str; cin &amp;gt;&amp;gt; str; set&amp;lt;string&amp;gt; strSet; for(int i=0; i &amp;lt; str.size(); i++) { string tmp=&quot;&quot;; for(int j=i; j &amp;lt; str.size(); j++) { tmp += str[j]; strSet.insert(tmp); } } cout &amp;lt;&amp;lt; strSet.size() &amp;lt;&amp;lt; endl; return 0;}SOL set을 이용해 중복된 값을 처리한다.Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startc++ 표준 템플릿 라이브러리 컨테이너 소개" }, { "title": "BOJ - 7785 - 회사에 있는 사람", "url": "/posts/BOJ-7785/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, hash, map", "date": "2022-07-18 11:10:00 +0900", "snippet": "BOJ - 7785 - 회사에 있는 사람문제7785번: 회사에 있는 사람문제상근이는 세계적인 소프트웨어 회사 기글에서 일한다. 이 회사의 가장 큰 특징은 자유로운 출퇴근 시간이다. 따라서, 직원들은 반드시 9시부터 6시까지 회사에 있지 않아도 된다.각 직원은 자기가 원할 때 출근할 수 있고, 아무때나 퇴근할 수 있다.상근이는 모든 사람의 출입카드 시스템의 로그를 가지고 있다. 이 로그는 어떤 사람이 회사에 들어왔는지, 나갔는지가 기록되어져 있다. 로그가 주어졌을 때, 현재 회사에 있는 모든 사람을 구하는 프로그램을 작성하시오.입력첫째 줄에 로그에 기록된 출입 기록의 수 n이 주어진다. (2 ≤ n ≤ 106) 다음 n개의 줄에는 출입 기록이 순서대로 주어지며, 각 사람의 이름이 주어지고 “enter”나 “leave”가 주어진다. “enter”인 경우는 출근, “leave”인 경우는 퇴근이다.회사에는 동명이인이 없으며, 대소문자가 다른 경우에는 다른 이름이다. 사람들의 이름은 알파벳 대소문자로 구성된 5글자 이하의 문자열이다.출력현재 회사에 있는 사람의 이름을 사전 순의 역순으로 한 줄에 한 명씩 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;map&amp;gt;using namespace std;int main(){ ios_base :: sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int num; cin &amp;gt;&amp;gt; num; map&amp;lt;string, bool, greater&amp;lt;&amp;gt;&amp;gt; map; for(int i=0; i &amp;lt; num; i++) { string name; string state; cin &amp;gt;&amp;gt; name &amp;gt;&amp;gt; state; if(state == &quot;enter&quot;) map[name] = 1; else map[name] = 0; } for(auto &amp;amp;el : map) if(el.second == 1) cout &amp;lt;&amp;lt; el.first &amp;lt;&amp;lt; &#39;\\n&#39;; return 0;}SOL map을 이용해 key value 값을 각각 이름, 출근여부 로 입력 후 사전의 내림차순으로 출력하기 위해 greater&amp;lt;&amp;gt; 옵션 추가 map&amp;lt;string, bool, greater&amp;lt;&amp;gt;&amp;gt; map; Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startc++ 표준 템플릿 라이브러리 컨테이너 소개" }, { "title": "BOJ - 1620 - 나는야 포켓몬 마스터 이다솜", "url": "/posts/BOJ-1620/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, hash, map", "date": "2022-07-17 11:10:00 +0900", "snippet": "BOJ - 1620 - 나는야 포켓몬 마스터 이다솜문제1620번: 나는야 포켓몬 마스터 이다솜문제포켓몬의 이름을 입력하면 해당 번호를,번호를 입력하면 포켓몬의 이름을 출력하라.입력첫째 줄에는 도감에 수록되어 있는 포켓몬의 개수 N이랑 내가 맞춰야 하는 문제의 개수 M이 주어져. N과 M은 1보다 크거나 같고, 100,000보다 작거나 같은 자연수인데, 자연수가 뭔지는 알지? 모르면 물어봐도 괜찮아. 나는 언제든지 질문에 답해줄 준비가 되어있어.둘째 줄부터 N개의 줄에 포켓몬의 번호가 1번인 포켓몬부터 N번에 해당하는 포켓몬까지 한 줄에 하나씩 입력으로 들어와. 포켓몬의 이름은 모두 영어로만 이루어져있고, 또, 음… 첫 글자만 대문자이고, 나머지 문자는 소문자로만 이루어져 있어. 아참! 일부 포켓몬은 마지막 문자만 대문자일 수도 있어. 포켓몬 이름의 최대 길이는 20, 최소 길이는 2야. 그 다음 줄부터 총 M개의 줄에 내가 맞춰야하는 문제가 입력으로 들어와. 문제가 알파벳으로만 들어오면 포켓몬 번호를 말해야 하고, 숫자로만 들어오면, 포켓몬 번호에 해당하는 문자를 출력해야해. 입력으로 들어오는 숫자는 반드시 1보다 크거나 같고, N보다 작거나 같고, 입력으로 들어오는 문자는 반드시 도감에 있는 포켓몬의 이름만 주어져. 그럼 화이팅!!!출력첫째 줄부터 차례대로 M개의 줄에 각각의 문제에 대한 답을 말해줬으면 좋겠어!!!. 입력으로 숫자가 들어왔다면 그 숫자에 해당하는 포켓몬의 이름을, 문자가 들어왔으면 그 포켓몬의 이름에 해당하는 번호를 출력하면 돼. 그럼 땡큐~이게 오박사님이 나에게 새로 주시려고 하는 도감이야. 너무 가지고 싶다ㅠㅜ. 꼭 만점을 받아줬으면 좋겠어!! 파이팅!!!구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;map&amp;gt;using namespace std;int main(){ ios_base :: sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); map&amp;lt;string, int&amp;gt; poketmon; int n, m; cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; string dogam[n+1]; for(int i=1; i &amp;lt;= n; i++) { string str; cin &amp;gt;&amp;gt; str; poketmon[str] = i; dogam[i] = str; } for(int i=0; i &amp;lt; m; i++) { string str; cin &amp;gt;&amp;gt; str; if(str[0] &amp;gt;= 65 &amp;amp;&amp;amp; str[0] &amp;lt;= 90) cout &amp;lt;&amp;lt; poketmon[str] &amp;lt;&amp;lt; &#39;\\n&#39;; else { int ii = stoi(str); cout &amp;lt;&amp;lt; dogam[ii] &amp;lt;&amp;lt; &#39;\\n&#39;; } } return 0;}SOL 포켓몬의 첫 알파뱃은 아스키 코드 값의 65~90의 범위에 해당 하기에 포켓몬의 이름이 입력되면 map의 key to value를 통해 포켓몬의 번호 값을 출력한다. 숫자가 입력될 시 string 배열의 도감 배열에서 해당 값을 찾아 출력한다.Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startc++ 표준 템플릿 라이브러리 컨테이너 소개" }, { "title": "BOJ - 1302 - 베스트셀러", "url": "/posts/BOJ-1302/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, hash, map", "date": "2022-07-16 11:10:00 +0900", "snippet": "BOJ - 1302 - 베스트셀러문제1302번: 베스트셀러문제김형택은 탑문고의 직원이다. 김형택은 계산대에서 계산을 하는 직원이다. 김형택은 그날 근무가 끝난 후에, 오늘 판매한 책의 제목을 보면서 가장 많이 팔린 책의 제목을 칠판에 써놓는 일도 같이 하고 있다.오늘 하루 동안 팔린 책의 제목이 입력으로 들어왔을 때, 가장 많이 팔린 책의 제목을 출력하는 프로그램을 작성하시오.입력첫째 줄에 오늘 하루 동안 팔린 책의 개수 N이 주어진다. 이 값은 1,000보다 작거나 같은 자연수이다. 둘째부터 N개의 줄에 책의 제목이 입력으로 들어온다. 책의 제목의 길이는 50보다 작거나 같고, 알파벳 소문자로만 이루어져 있다.출력첫째 줄에 가장 많이 팔린 책의 제목을 출력한다. 만약 가장 많이 팔린 책이 여러 개일 경우에는 사전 순으로 가장 앞서는 제목을 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;map&amp;gt;using namespace std;int main(){ int num; cin &amp;gt;&amp;gt; num; map&amp;lt;string, int&amp;gt; map; for(int i=0; i &amp;lt; num; i++) { string str; cin &amp;gt;&amp;gt; str; map[str] += 1; } int max = 0; string ans; for(auto &amp;amp;el : map) { if(el.second &amp;gt; max) { max = el.second; ans = el.first; } } cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl; return 0;}SOL json 구조의 map을 활용하여 key value를 구하여 최댓값을 구함.Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startc++ 표준 템플릿 라이브러리 컨테이너 소개" }, { "title": "BOJ - 2346 - 풍선 터뜨리기", "url": "/posts/BOJ-2346/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, deque", "date": "2022-07-13 11:10:00 +0900", "snippet": "BOJ - 2346 - 풍선 터뜨리기문제2346번: 풍선 터뜨리기문제1번부터 N번까지 N개의 풍선이 원형으로 놓여 있고. i번 풍선의 오른쪽에는 i+1번 풍선이 있고, 왼쪽에는 i-1번 풍선이 있다. 단, 1번 풍선의 왼쪽에 N번 풍선이 있고, N번 풍선의 오른쪽에 1번 풍선이 있다. 각 풍선 안에는 종이가 하나 들어있고, 종이에는 -N보다 크거나 같고, N보다 작거나 같은 정수가 하나 적혀있다. 이 풍선들을 다음과 같은 규칙으로 터뜨린다.우선, 제일 처음에는 1번 풍선을 터뜨린다. 다음에는 풍선 안에 있는 종이를 꺼내어 그 종이에 적혀있는 값만큼 이동하여 다음 풍선을 터뜨린다. 양수가 적혀 있을 경우에는 오른쪽으로, 음수가 적혀 있을 때는 왼쪽으로 이동한다. 이동할 때에는 이미 터진 풍선은 빼고 이동한다.예를 들어 다섯 개의 풍선 안에 차례로 3, 2, 1, -3, -1이 적혀 있었다고 하자. 이 경우 3이 적혀 있는 1번 풍선, -3이 적혀 있는 4번 풍선, -1이 적혀 있는 5번 풍선, 1이 적혀 있는 3번 풍선, 2가 적혀 있는 2번 풍선의 순서대로 터지게 된다.입력첫째 줄에 자연수 N(1 ≤ N ≤ 1,000)이 주어진다. 다음 줄에는 차례로 각 풍선 안의 종이에 적혀 있는 수가 주어진다. 종이에 0은 적혀있지 않다.출력첫째 줄에 터진 풍선의 번호를 차례로 나열한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;deque&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;class Balloon{public: int num; int number;};int main(){ int num; cin &amp;gt;&amp;gt; num; deque&amp;lt;Balloon&amp;gt; dq; for(int i=1; i &amp;lt;= num; i++) { Balloon tmp; cin &amp;gt;&amp;gt; tmp.num; tmp.number = i; dq.push_back(tmp); } int temp = dq.front().num; vector&amp;lt;int&amp;gt; answer; // 1회차 풍선 펑! answer.push_back(dq.front().number); dq.pop_front(); while(!dq.empty()) { // 터진 풍선이 양수일 경우 if(temp &amp;gt; 0) { // 새겨진 숫자만큼 이동 for(int i=1; i &amp;lt; temp; i++) { dq.push_back(dq.front()); dq.pop_front(); } // 오른쪽 이동 후 풍선 넘버 저장 후 펑! answer.push_back(dq.front().number); temp = dq.front().num; dq.pop_front(); } // 음수일 경우 else { // 새겨진 숫자만큼 이동 for(int i=1; i &amp;lt; abs(temp); i++) { dq.push_front(dq.back()); dq.pop_back(); } // 왼쪽 이동 후 풍선 넘버 저장 후 펑! answer.push_back(dq.back().number); temp = dq.back().num; dq.pop_back(); } } // 결과 출력 for(auto &amp;amp;el : answer) cout &amp;lt;&amp;lt; el &amp;lt;&amp;lt; &quot; &quot;; cout &amp;lt;&amp;lt; endl; return 0;}SOL 클래스를 이용하여 풍선의 좌표, 이동해야 하는 명령어를 저장하는 자료형을 만든 뒤 해당 조건에 맞추어 1회차 이후 명령에 따라 이동 후 풍선이 터지도록 함. deque 사용 Reference &amp;amp; 다른 PS 모음집https://github.com/ggh-png/PS" }, { "title": "BOJ - 1072 - 게임", "url": "/posts/BOJ-1072/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, BinarySearch, math", "date": "2022-06-27 11:10:00 +0900", "snippet": "BOJ - 1072 - 게임문제1072번: 게임문제김형택은 지금 몰래 Spider Solitaire(스파이더 카드놀이)를 하고 있다. 형택이는 이 게임을 이길 때도 있었지만, 질 때도 있었다. 누군가의 시선이 느껴진 형택이는 게임을 중단하고 코딩을 하기 시작했다. 의심을 피했다고 생각한 형택이는 다시 게임을 켰다. 그 때 형택이는 잠시 코딩을 하는 사이에 자신의 게임 실력이 눈에 띄게 향상된 것을 알았다.이제 형택이는 앞으로의 모든 게임에서 지지 않는다. 하지만, 형택이는 게임 기록을 삭제 할 수 없기 때문에, 자신의 못하던 예전 기록이 현재 자신의 엄청난 실력을 증명하지 못한다고 생각했다.게임 기록은 다음과 같이 생겼다. 게임 횟수 : X 이긴 게임 : Y (Z%) Z는 형택이의 승률이고, 소수점은 버린다. 예를 들어, X=53, Y=47이라면, Z=88이다.X와 Y가 주어졌을 때, 형택이가 게임을 최소 몇 번 더 해야 Z가 변하는지 구하는 프로그램을 작성하시오.입력각 줄에 정수 X와 Y가 주어진다.출력첫째 줄에 형택이가 게임을 최소 몇 판 더 해야하는지 출력한다. 만약 Z가 절대 변하지 않는다면 -1을 출력한다.제한 1 ≤ X ≤ 1,000,000,000 0 ≤ Y ≤ X구현#include &amp;lt;iostream&amp;gt;using namespace std;long long BinarySearch(long long begin, long long end, long long x, long long y, long long k){ long long m = (begin + end) / 2; if(begin &amp;gt;= end) return m; long long z = (y + m) * 100 / (x + m); if(z &amp;gt; k) return BinarySearch(begin, m - 1, x, y, k); else return BinarySearch(m, end + 1, x, y, k);}int main(){ long long x, y; cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y; long long z = y * 100 / x; if(z &amp;gt;= 99) cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; endl; else cout &amp;lt;&amp;lt; BinarySearch(0, 1000000000, x, y, z) + 1 &amp;lt;&amp;lt; endl; return 0;}SOL 퍼센트 구하기 z = y * 100 / x 이분탐색 퍼센트 구하기 z + 1 = (y + k) * 100 / (x + k) Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 start" }, { "title": "BOJ - 1946 - 신입 사원", "url": "/posts/BOJ-1946/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, 정렬, greedy, sort", "date": "2022-06-26 11:10:00 +0900", "snippet": "BOJ - 1946 - 신입 사원문제1946번: 신입 사원문제 개념문제언제나 최고만을 지향하는 굴지의 대기업 진영 주식회사가 신규 사원 채용을 실시한다. 인재 선발 시험은 1차 서류심사와 2차 면접시험으로 이루어진다. 최고만을 지향한다는 기업의 이념에 따라 그들은 최고의 인재들만을 사원으로 선발하고 싶어 한다.그래서 진영 주식회사는, 다른 모든 지원자와 비교했을 때 서류심사 성적과 면접시험 성적 중 적어도 하나가 다른 지원자보다 떨어지지 않는 자만 선발한다는 원칙을 세웠다. 즉, 어떤 지원자 A의 성적이 다른 어떤 지원자 B의 성적에 비해 서류 심사 결과와 면접 성적이 모두 떨어진다면 A는 결코 선발되지 않는다.이러한 조건을 만족시키면서, 진영 주식회사가 이번 신규 사원 채용에서 선발할 수 있는 신입사원의 최대 인원수를 구하는 프로그램을 작성하시오.입력첫째 줄에는 테스트 케이스의 개수 T(1 ≤ T ≤ 20)가 주어진다. 각 테스트 케이스의 첫째 줄에 지원자의 숫자 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N개 줄에는 각각의 지원자의 서류심사 성적, 면접 성적의 순위가 공백을 사이에 두고 한 줄에 주어진다. 두 성적 순위는 모두 1위부터 N위까지 동석차 없이 결정된다고 가정한다.출력각 테스트 케이스에 대해서 진영 주식회사가 선발할 수 있는 신입사원의 최대 인원수를 한 줄에 하나씩 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;class Score{public: int document; int meeting;};bool compare(Score a, Score b){ return a.document &amp;lt; b.document;}int main(){ int num; cin &amp;gt;&amp;gt; num; for(int i=0; i &amp;lt; num; i++) { int n; cin &amp;gt;&amp;gt; n; vector&amp;lt;Score&amp;gt; v(n); for(int i=0; i &amp;lt; n; i++) cin &amp;gt;&amp;gt; v[i].document &amp;gt;&amp;gt; v[i].meeting; sort(v.begin(), v.end(), compare); int score = 99999999; int ans = 0; for(int i=0; i &amp;lt; n; i++) { if(v[i].meeting &amp;lt; score) { ans++; score = v[i].meeting; } } cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl; } return 0;}SOL 서류 성적순으로 오름 차순 정렬 현 면접 성적보다 등급이 높으면 ans count++Reference &amp;amp; 다른 PS 모음집https://github.com/ggh-png/PS" }, { "title": "BOJ - 10610 - 30", "url": "/posts/BOJ-10610/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, math, sort, 정렬, greedy, 구현", "date": "2022-06-25 11:10:00 +0900", "snippet": "BOJ - 10610 - 30문제10610번: 30문제어느 날, 미르코는 우연히 길거리에서 양수 N을 보았다. 미르코는 30이란 수를 존경하기 때문에, 그는 길거리에서 찾은 수에 포함된 숫자들을 섞어 30의 배수가 되는 가장 큰 수를 만들고 싶어한다.미르코를 도와 그가 만들고 싶어하는 수를 계산하는 프로그램을 작성하라.입력N을 입력받는다. N는 최대 105개의 숫자로 구성되어 있으며, 0으로 시작하지 않는다.출력미르코가 만들고 싶어하는 수가 존재한다면 그 수를 출력하라. 그 수가 존재하지 않는다면, -1을 출력하라.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;// 입력받은 숫자를 조합하여 30의 배수가 되는 가장 큰 값을 만들어라.// 30의 배수가 되는 조건 0으로 나눠 떨어저야 하고 각 자리의 수들의 합이 3의 배수여야 한다. int main(){ string str; cin &amp;gt;&amp;gt; str; // 내림차순 정렬 sort(str.rbegin(), str.rend()); int sum = 0; for(auto &amp;amp;el : str) sum += el - 48; if(str.back() == &#39;0&#39; &amp;amp;&amp;amp; sum % 3 == 0) cout &amp;lt;&amp;lt; str &amp;lt;&amp;lt; endl; else cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; endl; return 0;}SOL 30으로 나누어 떨어지기 위해선 두가지 조건이 필요하다. 0으로 끝나야 함. 각 자리의 숫자들의 합이 3으로 나누어 떨어져야 한다. Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 start" }, { "title": "c++ 표준 템플릿 라이브러리 컨테이너 소개", "url": "/posts/cpp-stl/", "categories": "C++, STL", "tags": "C++, map, STL, stack, queue, deque, map, set, string, 자료구조", "date": "2022-06-25 01:00:00 +0900", "snippet": "C++ 표준 템플릿 라이브러리 컨테이너 소개💡 vector, deque, set, map, string, stack, queue #include &amp;lt;.vector&amp;gt;#include &amp;lt;.deque&amp;gt;#include &amp;lt;.set&amp;gt;#include &amp;lt;.map&amp;gt;#include &amp;lt;.string&amp;gt;#include &amp;lt;.stack&amp;gt;#include &amp;lt;.queue&amp;gt;sequence_containers [ vector, deque ]void sequence_containers(){ // #include &amp;lt;vector&amp;gt; { vector&amp;lt;int&amp;gt; v; for(int i=0; i &amp;lt; 10; i++) v.push_back(i); for(auto &amp;amp;el : v) cout &amp;lt;&amp;lt; el &amp;lt;&amp;lt; &quot; &quot;; cout &amp;lt;&amp;lt; endl; // 0 1 2 3 4 5 6 7 8 9 } // #include &amp;lt;deque&amp;gt; { deque&amp;lt;int&amp;gt; dq; for(int i=0; i &amp;lt; 10; i++) { dq.push_back(i); dq.push_front(i); } for(auto &amp;amp;el : dq) cout &amp;lt;&amp;lt; el &amp;lt;&amp;lt; &quot; &quot;; cout &amp;lt;&amp;lt; endl; // 9 8 7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7 8 9 }}associative_containers [ set, map ]void associative_containers(){ // #include &amp;lt;set&amp;gt; 집합 { set&amp;lt;string&amp;gt; str_set; str_set.insert(&quot;Hello&quot;); str_set.insert(&quot;World&quot;); str_set.insert(&quot;Hello&quot;); cout &amp;lt;&amp;lt; str_set.size() &amp;lt;&amp;lt; endl; for(auto &amp;amp;el : str_set) cout &amp;lt;&amp;lt; el &amp;lt;&amp;lt; &quot; &quot;; cout &amp;lt;&amp;lt; endl; // 2 // Hello World 같은 원소는 추가하지 아니함. } // multiset : duplication is allowed { std::multiset&amp;lt;string&amp;gt; str_set; str_set.insert(&quot;Hello&quot;); str_set.insert(&quot;World&quot;); str_set.insert(&quot;Hello&quot;); cout &amp;lt;&amp;lt; str_set.size() &amp;lt;&amp;lt; endl; for(auto &amp;amp;el : str_set) cout &amp;lt;&amp;lt; el &amp;lt;&amp;lt; &quot; &quot;; cout &amp;lt;&amp;lt; endl; // 3 // Hello Hello World 같은 원소를 허락하고 묶어주는 듯 함. } // #inculde &amp;lt;map&amp;gt; { // key / value 가 존재함. // json의 구조와 같다곤 함 // 알아서 정렬된 구조로 나옴 std::map&amp;lt;char, int&amp;gt; map; map[&#39;a&#39;] = 10; map[&#39;b&#39;] = 20; map[&#39;c&#39;] = 50; cout &amp;lt;&amp;lt; map[&#39;a&#39;] &amp;lt;&amp;lt; endl; map[&#39;a&#39;] = 100; cout &amp;lt;&amp;lt; map[&#39;a&#39;] &amp;lt;&amp;lt; endl; for(auto &amp;amp;el : map) cout &amp;lt;&amp;lt; el.first &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; el.second &amp;lt;&amp;lt; &quot; &quot;; cout &amp;lt;&amp;lt; endl; /* 10 100 a 100 b 20 c 50 */ } // multimap : duplicated keys // 여러개의 키 값을 갖는다는 뜻 같음. { std::multimap&amp;lt;char, int&amp;gt; map; map.insert(std::pair(&#39;a&#39;, 10)); map.insert(std::pair(&#39;b&#39;, 10)); map.insert(std::pair(&#39;c&#39;, 10)); map.insert(std::pair(&#39;a&#39;, 100)); cout &amp;lt;&amp;lt; map.count(&#39;a&#39;) &amp;lt;&amp;lt; endl; for(auto &amp;amp;el : map) cout &amp;lt;&amp;lt; el.first &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; el.second &amp;lt;&amp;lt; &quot; &quot;; cout &amp;lt;&amp;lt; endl; // 2 // a 10 a 100 b 10 c 10 // 마찬가지로 정렬되어 나옴 }}container_adapters [ stack, queue ]void container_adapters(){ // #include &amp;lt;stack&amp;gt; { cout &amp;lt;&amp;lt; &quot;Stack&quot; &amp;lt;&amp;lt; endl; std::stack&amp;lt;int&amp;gt; stack; stack.push(1); // push adds a copy stack.emplace(2); // emplace constructs a new object stack.emplace(3); cout &amp;lt;&amp;lt; stack.top() &amp;lt;&amp;lt; endl; stack.pop(); cout &amp;lt;&amp;lt; stack.top() &amp;lt;&amp;lt; endl; // 3 // 2 } // #include &amp;lt;queue&amp;gt; { cout &amp;lt;&amp;lt; &quot;queue&quot; &amp;lt;&amp;lt; endl; std::queue&amp;lt;int&amp;gt; queue; queue.push(1); // push adds a copy queue.push(2); // emplace constructs a new object queue.push(3); cout &amp;lt;&amp;lt; queue.front() &amp;lt;&amp;lt; queue.back() &amp;lt;&amp;lt; endl; queue.pop(); cout &amp;lt;&amp;lt; queue.front() &amp;lt;&amp;lt; queue.back() &amp;lt;&amp;lt; endl; // 1 3 // 2 3 } // Priority queue { // 우선순위 큐 인듯 함. cout &amp;lt;&amp;lt; &quot;Priority queue&quot; &amp;lt;&amp;lt; endl; std::priority_queue&amp;lt;int&amp;gt; queue; for(const int n : {1, 8, 5, 6, 3, 4, 0, 9, 7, 2}) queue.push(n); for(int i=0; i &amp;lt; 10; i++) { cout &amp;lt;&amp;lt; queue.top() &amp;lt;&amp;lt; &quot; &quot;; queue.pop(); } cout &amp;lt;&amp;lt; endl; // 9 8 7 6 5 4 3 2 1 0 }}" }, { "title": "BOJ - 17413 - 단어 뒤집기 2", "url": "/posts/BOJ-17413/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, stack, queue, deque", "date": "2022-06-24 11:10:00 +0900", "snippet": "BOJ - 17413 - 단어 뒤집기 2문제17413번: 단어 뒤집기 2문제문자열 S가 주어졌을 때, 이 문자열에서 단어만 뒤집으려고 한다.먼저, 문자열 S는 아래와과 같은 규칙을 지킨다. 알파벳 소문자(‘a’-‘z’), 숫자(‘0’-‘9’), 공백(‘ ``’), 특수 문자(‘&amp;lt;’, ‘&amp;gt;‘)로만 이루어져 있다. 문자열의 시작과 끝은 공백이 아니다. ’&amp;lt;‘와 ‘&amp;gt;‘가 문자열에 있는 경우 번갈아가면서 등장하며, ‘&amp;lt;‘이 먼저 등장한다. 또, 두 문자의 개수는 같다.태그는 ‘&amp;lt;‘로 시작해서 ‘&amp;gt;‘로 끝나는 길이가 3 이상인 부분 문자열이고, ‘&amp;lt;‘와 ‘&amp;gt;‘ 사이에는 알파벳 소문자와 공백만 있다. 단어는 알파벳 소문자와 숫자로 이루어진 부분 문자열이고, 연속하는 두 단어는 공백 하나로 구분한다. 태그는 단어가 아니며, 태그와 단어 사이에는 공백이 없다.입력첫째 줄에 문자열 S가 주어진다. S의 길이는 100,000 이하이다.출력첫째 줄에 문자열 S의 단어를 뒤집어서 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;deque&amp;gt;using namespace std;int main(){ string str; getline(cin, str); // &amp;lt; 이 등장하면 &amp;gt; 이 등장할 때 까지 삽입한다. deque&amp;lt;char&amp;gt; dec; while(!str.empty()) { // &amp;lt; &amp;gt; 일 경우 if(str.front() == &#39;&amp;lt;&#39;) { string temp = &quot;&quot;; while(!dec.empty()) { temp += dec.back(); dec.pop_back(); } cout &amp;lt;&amp;lt; temp; dec.push_back(str.front()); str.erase(str.begin()); while(str.front() != &#39;&amp;gt;&#39;) { dec.push_back(str.front()); str.erase(str.begin()); } dec.push_back(str.front()); str.erase(str.begin()); string tmp = &quot;&quot;; while(!dec.empty()) { tmp += dec.front(); dec.pop_front(); } cout &amp;lt;&amp;lt; tmp; } else if(str.front() != &#39; &#39; &amp;amp;&amp;amp; str.size() != 1) { dec.push_back(str.front()); str.erase(str.begin()); } else if(str.front() == &#39; &#39;) { string tmp = &quot;&quot;; while(!dec.empty()) { tmp += dec.back(); dec.pop_back(); } str.erase(str.begin()); cout &amp;lt;&amp;lt; tmp &amp;lt;&amp;lt; &quot; &quot;; } else if(str.size() == 1) { dec.push_back(str.front()); str.erase(str.begin()); string tmp = &quot;&quot;; while(!dec.empty()) { tmp += dec.back(); dec.pop_back(); } cout &amp;lt;&amp;lt; tmp &amp;lt;&amp;lt; endl; break; } } return 0;}SOL 덱의 스택과 큐의 성질을 활용하여 &amp;lt;, &amp;gt; 일 때는 큐의 특성을 공백이나 마지막일 경우에는 스택의 특성을 사용하여 reverse를 해 주었다.Reference &amp;amp; 다른 PS 모음집https://github.com/ggh-png/PS" }, { "title": "BOJ - 1015 - 수열 정렬", "url": "/posts/BOJ-1015/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, 정렬, sort", "date": "2022-06-23 11:10:00 +0900", "snippet": "BOJ - 1015 - 수열 정렬문제1015번: 수열 정렬문제 개념문제P[0], P[1], …., P[N-1]은 0부터 N-1까지(포함)의 수를 한 번씩 포함하고 있는 수열이다. 수열 P를 길이가 N인 배열 A에 적용하면 길이가 N인 배열 B가 된다. 적용하는 방법은 B[P[i]] = A[i]이다.배열 A가 주어졌을 때, 수열 P를 적용한 결과가 비내림차순이 되는 수열을 찾는 프로그램을 작성하시오. 비내림차순이란, 각각의 원소가 바로 앞에 있는 원소보다 크거나 같을 경우를 말한다. 만약 그러한 수열이 여러개라면 사전순으로 앞서는 것을 출력한다.입력첫째 줄에 배열 A의 크기 N이 주어진다. 둘째 줄에는 배열 A의 원소가 0번부터 차례대로 주어진다. N은 50보다 작거나 같은 자연수이고, 배열의 원소는 1,000보다 작거나 같은 자연수이다.출력첫째 줄에 비내림차순으로 만드는 수열 P를 출력한다.구현#include &amp;lt;iostream&amp;gt;using namespace std;int main(){ int num; cin &amp;gt;&amp;gt; num; int arr[num]; int ans[num]; for(int i=0; i &amp;lt; num; i++) cin &amp;gt;&amp;gt; arr[i]; for(int i=0; i &amp;lt; num; i++) { int cnt = 0; for(int j = 0; j &amp;lt; num; j++) { if(arr[i] &amp;gt; arr[j] &amp;amp;&amp;amp; i != j) cnt++; else if(arr[i] == arr[j] &amp;amp;&amp;amp; i != j &amp;amp;&amp;amp; i &amp;gt; j) cnt++; } ans[i] = cnt; } for(auto &amp;amp;el : ans) cout &amp;lt;&amp;lt; el &amp;lt;&amp;lt; &quot; &quot;; cout &amp;lt;&amp;lt; endl; return 0;}SOL 이전에 다뤘던 좌표 압축 문제와 비슷한 문제다. 시간제한이 2초, 배열의 크기가 최대 50 정도로 작은 크기이기 때문에 O(N^2)의 시간 복잡도를 가져도 무방하므로 모든 배열을 확인 하는 방법을 사용하였다. 원소의 값이 같은 경우에는 먼저 등장한 순서대로 정리해야 함으로 처음 등장한 경우를 제외하고 뒤에 등장한 경우만 카운트를 해주었다. else if(arr[i] == arr[j] &amp;amp;&amp;amp; i != j &amp;amp;&amp;amp; i &amp;gt; j) cnt++; Reference &amp;amp; 다른 PS 모음집https://github.com/ggh-png/PS" }, { "title": "BOJ - 2217 - 로프", "url": "/posts/BOJ-2217/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, greedy, 정렬, sort", "date": "2022-06-22 11:10:00 +0900", "snippet": "BOJ - 2217 - 로프문제2217번: 로프문제 개념문제N(1 ≤ N ≤ 100,000)개의 로프가 있다. 이 로프를 이용하여 이런 저런 물체를 들어올릴 수 있다. 각각의 로프는 그 굵기나 길이가 다르기 때문에 들 수 있는 물체의 중량이 서로 다를 수도 있다.하지만 여러 개의 로프를 병렬로 연결하면 각각의 로프에 걸리는 중량을 나눌 수 있다. k개의 로프를 사용하여 중량이 w인 물체를 들어올릴 때, 각각의 로프에는 모두 고르게 w/k 만큼의 중량이 걸리게 된다.각 로프들에 대한 정보가 주어졌을 때, 이 로프들을 이용하여 들어올릴 수 있는 물체의 최대 중량을 구해내는 프로그램을 작성하시오. 모든 로프를 사용해야 할 필요는 없으며, 임의로 몇 개의 로프를 골라서 사용해도 된다.입력첫째 줄에 정수 N이 주어진다. 다음 N개의 줄에는 각 로프가 버틸 수 있는 최대 중량이 주어진다. 이 값은 10,000을 넘지 않는 자연수이다.출력첫째 줄에 답을 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;bool compare(int &amp;amp;a, int &amp;amp;b){ return a &amp;gt; b;}int main(){ int num; cin &amp;gt;&amp;gt; num; int arr[num]; for(int i=0; i &amp;lt; num; i++) cin &amp;gt;&amp;gt; arr[i]; // 내림차순 정렬 sort(arr, arr + num, compare); int answer = 0; for(int i=0; i &amp;lt; num; i++) { int sum = arr[i] * (i+1); if(answer &amp;lt;= sum) answer = sum; } cout &amp;lt;&amp;lt; answer &amp;lt;&amp;lt; endl; return 0;}SOL 내림차순 정렬 [1,2,3,4,5] → [5,4,3,2,1] sum 추출 [5, 8, 9, 8, 5] 추출된 sum 중 최댓값 ~~&amp;gt; answerReference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 start" }, { "title": "BOJ - 2512 - 예산", "url": "/posts/BOJ-2512/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, BinarySearch", "date": "2022-06-20 11:10:00 +0900", "snippet": "BOJ - 2512 - 예산문제2512번: 예산문제국가의 역할 중 하나는 여러 지방의 예산요청을 심사하여 국가의 예산을 분배하는 것이다. 국가예산의 총액은 미리 정해져 있어서 모든 예산요청을 배정해 주기는 어려울 수도 있다. 그래서 정해진 총액 이하에서 가능한 한 최대의 총 예산을 다음과 같은 방법으로 배정한다. 모든 요청이 배정될 수 있는 경우에는 요청한 금액을 그대로 배정한다. 모든 요청이 배정될 수 없는 경우에는 특정한 정수 상한액을 계산하여 그 이상인 예산요청에는 모두 상한액을 배정한다. 상한액 이하의 예산요청에 대해서는 요청한 금액을 그대로 배정한다.예를 들어, 전체 국가예산이 485이고 4개 지방의 예산요청이 각각 120, 110, 140, 150이라고 하자. 이 경우, 상한액을 127로 잡으면, 위의 요청들에 대해서 각각 120, 110, 127, 127을 배정하고 그 합이 484로 가능한 최대가 된다.여러 지방의 예산요청과 국가예산의 총액이 주어졌을 때, 위의 조건을 모두 만족하도록 예산을 배정하는 프로그램을 작성하시오.입력첫째 줄에는 지방의 수를 의미하는 정수 N이 주어진다. N은 3 이상 10,000 이하이다. 다음 줄에는 각 지방의 예산요청을 표현하는 N개의 정수가 빈칸을 사이에 두고 주어진다. 이 값들은 모두 1 이상 100,000 이하이다. 그 다음 줄에는 총 예산을 나타내는 정수 M이 주어진다. M은 N 이상 1,000,000,000 이하이다.출력첫째 줄에는 배정된 예산들 중 최댓값인 정수를 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;int BinarySearch(vector&amp;lt;long long&amp;gt; &amp;amp;arr,long long &amp;amp;k, const long long &amp;amp;begin, const long long &amp;amp;end){ long long m = (begin + end) / 2; if(begin &amp;gt;= end) return m; long long sum = 0; for(auto &amp;amp;el : arr) { if(el &amp;lt; m) sum += el; else sum += m; } if(sum &amp;lt;= k) return BinarySearch(arr, k, m, end + 1); else return BinarySearch(arr, k, begin, m - 1);}int main(){ ios_base :: sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int num; cin &amp;gt;&amp;gt; num; vector&amp;lt;long long&amp;gt; arr(num); long long sum = 0; for(int i=0; i &amp;lt; num; i++) { cin &amp;gt;&amp;gt; arr[i]; sum += arr[i]; } long long m; cin &amp;gt;&amp;gt; m; sort(arr.begin(), arr.end()); //120 110 140 150 if(sum &amp;lt;= m) cout &amp;lt;&amp;lt; arr.back(); else cout &amp;lt;&amp;lt; BinarySearch(arr, m, 1, arr.back()) &amp;lt;&amp;lt; endl; return 0;}SOL 오름차순 정렬 요소들의 합이 m 보다 작을 경우 요소들의 max 값 return 작지 않을 경우 이분탐색 begin : 1 end : 요소들의 max 값 Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startC++ STL lower_bound ( )" }, { "title": "BOJ - 2805 - 나무 자르기", "url": "/posts/BOJ-2805/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, BinarySearch", "date": "2022-06-17 11:10:00 +0900", "snippet": "BOJ - 2805 - 나무 자르기문제2805번: 나무 자르기문제상근이는 나무 M미터가 필요하다. 근처에 나무를 구입할 곳이 모두 망해버렸기 때문에, 정부에 벌목 허가를 요청했다. 정부는 상근이네 집 근처의 나무 한 줄에 대한 벌목 허가를 내주었고, 상근이는 새로 구입한 목재절단기를 이용해서 나무를 구할것이다.목재절단기는 다음과 같이 동작한다. 먼저, 상근이는 절단기에 높이 H를 지정해야 한다. 높이를 지정하면 톱날이 땅으로부터 H미터 위로 올라간다. 그 다음, 한 줄에 연속해있는 나무를 모두 절단해버린다. 따라서, 높이가 H보다 큰 나무는 H 위의 부분이 잘릴 것이고, 낮은 나무는 잘리지 않을 것이다. 예를 들어, 한 줄에 연속해있는 나무의 높이가 20, 15, 10, 17이라고 하자. 상근이가 높이를 15로 지정했다면, 나무를 자른 뒤의 높이는 15, 15, 10, 15가 될 것이고, 상근이는 길이가 5인 나무와 2인 나무를 들고 집에 갈 것이다. (총 7미터를 집에 들고 간다) 절단기에 설정할 수 있는 높이는 양의 정수 또는 0이다.상근이는 환경에 매우 관심이 많기 때문에, 나무를 필요한 만큼만 집으로 가져가려고 한다. 이때, 적어도 M미터의 나무를 집에 가져가기 위해서 절단기에 설정할 수 있는 높이의 최댓값을 구하는 프로그램을 작성하시오.입력첫째 줄에 나무의 수 N과 상근이가 집으로 가져가려고 하는 나무의 길이 M이 주어진다. (1 ≤ N ≤ 1,000,000, 1 ≤ M ≤ 2,000,000,000)둘째 줄에는 나무의 높이가 주어진다. 나무의 높이의 합은 항상 M보다 크거나 같기 때문에, 상근이는 집에 필요한 나무를 항상 가져갈 수 있다. 높이는 1,000,000,000보다 작거나 같은 양의 정수 또는 0이다.출력적어도 M미터의 나무를 집에 가져가기 위해서 절단기에 설정할 수 있는 높이의 최댓값을 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;int BinarySearch(vector&amp;lt;long long&amp;gt; &amp;amp;arr, int &amp;amp;N, const long long &amp;amp;begin, const long long &amp;amp;end){ long long m = (begin + end) / 2; if(begin == end) return m; long long sum = 0; for(auto &amp;amp;el : arr) if(el &amp;gt;= m) sum += el - m; if(sum &amp;gt;= N) return BinarySearch(arr, N, m, end+1); else return BinarySearch(arr, N, begin, m-1);}int main(){ ios_base :: sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int n, m; cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; vector&amp;lt;long long&amp;gt; arr(n); // 나무 입력 받기 long long max = 0; long long min; for(int i=0; i &amp;lt; n; i++) { cin &amp;gt;&amp;gt; arr[i]; if(arr[i] &amp;gt; max) max = arr[i]; } min = max - m; cout &amp;lt;&amp;lt; BinarySearch(arr, m, min, max) &amp;lt;&amp;lt; endl; return 0;}SOL 절단기의 최댓값을 지정한다. 절단기의 최댓값 보다 큰 나무들을 자르고 나머지 값을 모두 더한다. 모두 더한 값이 원하는 M 값 보다 크거나 같으면 오른 범위를 재 탐색하고 작거나 같다면 왼 범위를 재 탐색한다. 이진탐색 범위 지정 begin : 입력받은 나무의 길이 중 가장 큰 값을 입력받은 m값을 뺀 값 end : 입력받은 나무 길이 중 가장 큰 값 최댓 값을 구해야 하기에 랜선의 개수가 나오더라도 랜선의 길이를 기준으로 오른 범위에 있는 값들을 재 탐색한다. int BinarySearch(vector&amp;lt;long long&amp;gt; &amp;amp;arr, int &amp;amp;N, const long long &amp;amp;begin, const long long &amp;amp;end) { long long m = (begin + end) / 2; if(begin == end) return m; long long sum = 0; for(auto &amp;amp;el : arr) if(el &amp;gt;= m) sum += el - m; if(sum &amp;gt;= N) return BinarySearch(arr, N, m, end+1); else return BinarySearch(arr, N, begin, m-1); } Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startC++ STL lower_bound ( )" }, { "title": "BOJ - 1931 - 회의실 배정", "url": "/posts/BOJ-1931/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, greedy, sort, 정렬", "date": "2022-06-13 11:10:00 +0900", "snippet": "BOJ - 1931 - 회의실 배정문제1931번: 회의실 배정문제 개념문제한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.입력첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데 이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다. 시작 시간과 끝나는 시간은 231-1보다 작거나 같은 자연수 또는 0이다.출력첫째 줄에 최대 사용할 수 있는 회의의 최대 개수를 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;// first는 second보다 크면 안댐 class Meeting{public: int open; int close;};bool compare(Meeting a, Meeting b){ if(a.close == b.close) return a.open &amp;lt; b.open; return a.close &amp;lt; b.close;}int main(){ int num; cin &amp;gt;&amp;gt; num; vector&amp;lt;Meeting&amp;gt; v(num); for(int i=0; i &amp;lt; num; i++) cin &amp;gt;&amp;gt; v[i].open &amp;gt;&amp;gt; v[i].close; sort(v.begin(), v.end(), compare); int time=0,cnt=0; for(auto &amp;amp;el : v) if(time &amp;lt;= el.open) { time = el.close; cnt++; } cout &amp;lt;&amp;lt; cnt; return 0;}SOL 퇴실이 늦는 기준으로 정렬 후 퇴실 시간이 같을 경우 입실 시간으로 정렬 한다. 입실 시간이 현재보다 늦을 경우 현재 시간을 퇴실 시간으로 초기화 한다.Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 start" }, { "title": "BOJ - 1654 - 랜선 자르기", "url": "/posts/BOJ-1654/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, BinarySearch", "date": "2022-06-13 11:10:00 +0900", "snippet": "BOJ - 1654 - 랜선 자르기문제1654번: 랜선 자르기문제 개념문제집에서 시간을 보내던 오영식은 박성원의 부름을 받고 급히 달려왔다. 박성원이 캠프 때 쓸 N개의 랜선을 만들어야 하는데 너무 바빠서 영식이에게 도움을 청했다.이미 오영식은 자체적으로 K개의 랜선을 가지고 있다. 그러나 K개의 랜선은 길이가 제각각이다. 박성원은 랜선을 모두 N개의 같은 길이의 랜선으로 만들고 싶었기 때문에 K개의 랜선을 잘라서 만들어야 한다. 예를 들어 300cm 짜리 랜선에서 140cm 짜리 랜선을 두 개 잘라내면 20cm는 버려야 한다. (이미 자른 랜선은 붙일 수 없다.)편의를 위해 랜선을 자르거나 만들 때 손실되는 길이는 없다고 가정하며, 기존의 K개의 랜선으로 N개의 랜선을 만들 수 없는 경우는 없다고 가정하자. 그리고 자를 때는 항상 센티미터 단위로 정수길이만큼 자른다고 가정하자. N개보다 많이 만드는 것도 N개를 만드는 것에 포함된다. 이때 만들 수 있는 최대 랜선의 길이를 구하는 프로그램을 작성하시오.입력첫째 줄에는 오영식이 이미 가지고 있는 랜선의 개수 K, 그리고 필요한 랜선의 개수 N이 입력된다. K는 1이상 10,000이하의 정수이고, N은 1이상 1,000,000이하의 정수이다. 그리고 항상 K ≦ N 이다. 그 후 K줄에 걸쳐 이미 가지고 있는 각 랜선의 길이가 센티미터 단위의 정수로 입력된다. 랜선의 길이는 231-1보다 작거나 같은 자연수이다.출력첫째 줄에 N개를 만들 수 있는 랜선의 최대 길이를 센티미터 단위의 정수로 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;int BinarySearch(vector&amp;lt;long long&amp;gt; &amp;amp;v, int N, long long begin, long long end){ long long m = (begin + end) / 2; if(begin &amp;gt;= end) return m; int cnt = 0; for(int j=0; j &amp;lt; v.size(); j++) { cnt += v[j] / m; if(cnt == N) return BinarySearch(v, N, m, end+1); } if(cnt == N) return BinarySearch(v, N, m, end+1); else if(cnt &amp;lt; N) return BinarySearch(v, N, begin, m-1); else return BinarySearch(v, N, m, end+1);}int main(){ ios_base :: sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); long long K, N; cin &amp;gt;&amp;gt; K &amp;gt;&amp;gt; N; vector&amp;lt;long long&amp;gt; v(K); long long sum=0; for(int i=0; i &amp;lt; K; i++) { cin &amp;gt;&amp;gt; v[i]; sum += v[i]; } sum /= N; // 모두 더한 후 최대공약수를 구한다. cout &amp;lt;&amp;lt; BinarySearch(v, N, 1, sum) &amp;lt;&amp;lt; &#39;\\n&#39;; return 0;}SOL 이진탐색 범위 지정 1부터 모두 더한 값의 N으로 나눈 값 begin : 1 end : sum / N 최댓 값을 구해야 하기에 랜선의 개수가 나오더라도 랜선의 길이를 기준으로 오른 범위에 있는 값들을 재 탐색한다. int BinarySearch(vector&amp;lt;long long&amp;gt; &amp;amp;v, int N, long long begin, long long end) { long long m = (begin + end) / 2; if(begin &amp;gt;= end) return m; int cnt = 0; for(int j=0; j &amp;lt; v.size(); j++) { cnt += v[j] / m; if(cnt == N) return BinarySearch(v, N, m, end+1); } if(cnt == N) return BinarySearch(v, N, m, end+1); else if(cnt &amp;lt; N) return BinarySearch(v, N, begin, m-1); else return BinarySearch(v, N, m, end+1); } Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 startC++ STL lower_bound ( )" }, { "title": "BOJ - 1541 - 잃어버린 괄호", "url": "/posts/BOJ-1541/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, greedy", "date": "2022-06-10 11:10:00 +0900", "snippet": "BOJ - 1541 - 잃어버린 괄호문제1541번: 잃어버린 괄호문제 개념문제세준이는 양수와 +, -, 그리고 괄호를 가지고 식을 만들었다. 그리고 나서 세준이는 괄호를 모두 지웠다.그리고 나서 세준이는 괄호를 적절히 쳐서 이 식의 값을 최소로 만들려고 한다.괄호를 적절히 쳐서 이 식의 값을 최소로 만드는 프로그램을 작성하시오.입력첫째 줄에 식이 주어진다. 식은 ‘0’~‘9’, ‘+’, 그리고 ‘-’만으로 이루어져 있고, 가장 처음과 마지막 문자는 숫자이다. 그리고 연속해서 두 개 이상의 연산자가 나타나지 않고, 5자리보다 많이 연속되는 숫자는 없다. 수는 0으로 시작할 수 있다. 입력으로 주어지는 식의 길이는 50보다 작거나 같다.출력첫째 줄에 정답을 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;// 주어진 식에서 괄호를 치는 행위를 통해 최솟값을 구하여라 // 1. 순서는 바뀔 수 없으며 오로지 괄호를 이용한다. // 2. (-)가 존재하면 (+)끼리 묶어 먼저 계산한다. int main(){ // 식 입력 받기 string str; cin &amp;gt;&amp;gt; str; vector&amp;lt;int&amp;gt; iv; vector&amp;lt;char&amp;gt; ic; string temp = &quot;&quot;; for(int i=0; i &amp;lt;= str.size(); i++) { if(str[i] == &#39;-&#39; || str[i] == &#39;+&#39; || i == str.size()) { iv.push_back(stoi(temp)); temp = &quot;&quot;; ic.push_back(str[i]); } else temp += str[i]; } // 양의 부호를 가지면 묶는다. for(int i=0; i &amp;lt; ic.size(); i++) { if(ic[i] == &#39;+&#39;) { iv[i] += iv[i+1]; iv.erase(iv.begin() + i+1); ic.erase(ic.begin() + i); i--; } } // 이후 음의 부호를 가지는 것들을 해결한다. for(int i=0; i &amp;lt; ic.size(); i++) { if(ic[i] == &#39;-&#39;) { iv[i] -= iv[i+1]; iv.erase(iv.begin() + i+1); ic.erase(ic.begin() + i); i--; } } int answer = iv[0]; cout &amp;lt;&amp;lt; answer &amp;lt;&amp;lt; endl; return 0;}SOL ( + )인 경우들을 먼저 묶어 계산 후 ( - )를 처리한다.Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 start" }, { "title": "greedy", "url": "/posts/greedy/", "categories": "algorithm, greedy", "tags": "algorithm, greedy", "date": "2022-06-09 11:10:00 +0900", "snippet": "greedy개요이번 포스팅에선 알고리즘의 탐욕법(greedy), 완전탐색(brute force)에 대해 알아보도록 하겠다.탐욕법(greedy) 문제 풀이를 위한 아이디어를 추출하고, 정당한지 확인하자.특징 문제 풀이를 위한 아이디어를 추출한다. 추출된 아이디어가 문제 상황에 적합한지 판단 후 적용한다.예시문제 거스름돈 문제5585번: 거스름돈조건문제타로는 자주 JOI잡화점에서 물건을 산다. JOI잡화점에는 잔돈으로 500엔, 100엔, 50엔, 10엔, 5엔, 1엔이 충분히 있고, 언제나 거스름돈 개수가 가장 적게 잔돈을 준다. 타로가 JOI잡화점에서 물건을 사고 카운터에서 1000엔 지폐를 한장 냈을 때, 받을 잔돈에 포함된 잔돈의 개수를 구하는 프로그램을 작성하시오.입력입력은 한줄로 이루어져있고, 타로가 지불할 돈(1 이상 1000미만의 정수) 1개가 쓰여져있다.출력제출할 출력 파일은 1행으로만 되어 있다. 잔돈에 포함된 매수를 출력하시오.SOL위 문제의 조건을 통해 우리는 1000엔에서 입력받은 금액을 뺀 거스름 돈을 추출하면 되는 것이다.단. 최소한의 동전을 이용하여.. 문제풀이를 위한 아이디어 추출 큰 단위의 동전부터 거슬러 주기 추출된 아이디어가 문제 상황에 정단한지 판단 후 적용 주어진 동전간의 관계는 각각의 배수로 이루어져 있기에 정당하다. 구현#include &amp;lt;iostream&amp;gt;using namespace std;/* 동전 500, 100, 50, 10, 5, 1존재할 때 거스름돈을 만들 수 있는최소한의 동전의 개수를 구하여라.동전들의 관계를 보았을 때 서로 배수가 되는것을 확인 할 수 있다. 이를 통해 큰 동전의 개수부터 구하는 방법을 이용하면문제를 해결할 수 있을 것이다. */int main(){ int num; // 거스름돈 입력 cin &amp;gt;&amp;gt; num; // 동전의 개수 num = 1000 - num; int answer = 0; int coin[6] = {500, 100, 50, 10, 5, 1}; for(int i=0 ; i &amp;lt; 6; i++) { int tmp = num / coin[i]; num -= (num / coin[i]) * coin[i]; if(num != 0) answer += tmp; else { answer += tmp; break; } } cout &amp;lt;&amp;lt; answer; return 0;}Reference(이코테 2021 강의 몰아보기) 2. 그리디 &amp;amp; 구현" }, { "title": "BOJ - 10825 - 국영수", "url": "/posts/BOJ-10825/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, 정렬", "date": "2022-05-31 11:10:00 +0900", "snippet": "BOJ - 10825 - 국영수문제10825번: 국영수문제 개념문제도현이네 반 학생 N명의 이름과 국어, 영어, 수학 점수가 주어진다. 이때, 다음과 같은 조건으로 학생의 성적을 정렬하는 프로그램을 작성하시오. 국어 점수가 감소하는 순서로 국어 점수가 같으면 영어 점수가 증가하는 순서로 국어 점수와 영어 점수가 같으면 수학 점수가 감소하는 순서로 모든 점수가 같으면 이름이 사전 순으로 증가하는 순서로 (단, 아스키 코드에서 대문자는 소문자보다 작으므로 사전순으로 앞에 온다.)입력첫째 줄에 도현이네 반의 학생의 수 N (1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 한 줄에 하나씩 각 학생의 이름, 국어, 영어, 수학 점수가 공백으로 구분해 주어진다. 점수는 1보다 크거나 같고, 100보다 작거나 같은 자연수이다. 이름은 알파벳 대소문자로 이루어진 문자열이고, 길이는 10자리를 넘지 않는다.출력문제에 나와있는 정렬 기준으로 정렬한 후 첫째 줄부터 N개의 줄에 걸쳐 각 학생의 이름을 출력한다.구현 - class 사용#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;class Student{public: string m_name; // 국 영 수 int m_k; int m_y; int m_s; Student(string &amp;amp;name, int &amp;amp;k, int &amp;amp;y, int &amp;amp;s) { this-&amp;gt;m_name = name; this-&amp;gt;m_k = k; this-&amp;gt;m_y = y; this-&amp;gt;m_s = s; } bool operator &amp;lt; (Student &amp;amp;stu) { if(this-&amp;gt;m_k == stu.m_k) { if(this-&amp;gt;m_y == stu.m_y) { if(this-&amp;gt;m_s == stu.m_s) return this-&amp;gt;m_name &amp;lt; stu.m_name; return this-&amp;gt;m_s &amp;gt; stu.m_s; } return this-&amp;gt;m_y &amp;lt; stu.m_y; } return this-&amp;gt;m_k &amp;gt; stu.m_k; }};int main(){ ios::sync_with_stdio(false); cin.tie(NULL); int num; cin &amp;gt;&amp;gt; num; vector&amp;lt;Student&amp;gt; v; for(int i=0; i &amp;lt; num; i++) { string name; int k, y, s; cin &amp;gt;&amp;gt; name &amp;gt;&amp;gt; k &amp;gt;&amp;gt; y &amp;gt;&amp;gt; s; Student st = {name, k, y, s}; v.push_back(st); } sort(v.begin(), v.end()); for(auto &amp;amp;el : v) cout &amp;lt;&amp;lt; el.m_name &amp;lt;&amp;lt; &#39;\\n&#39;; return 0;}구현 - struct 사용#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;struct Student{ string m_name; // 국 영 수 int m_k; int m_y; int m_s;};bool compare(const Student&amp;amp; now, const Student&amp;amp; last){ if(now.m_k != last.m_k) return now.m_k &amp;gt; last.m_k; else { if(now.m_y != last.m_y) return now.m_y &amp;lt; last.m_y; else { if(now.m_s != last.m_s) return now.m_s &amp;gt; last.m_s; return now.m_name &amp;lt; last.m_name; } }}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); int num; cin &amp;gt;&amp;gt; num; vector&amp;lt;Student&amp;gt; v(num); for(int i=0; i &amp;lt; num; i++) cin &amp;gt;&amp;gt; v[i].m_name &amp;gt;&amp;gt; v[i].m_k &amp;gt;&amp;gt; v[i].m_y &amp;gt;&amp;gt; v[i].m_s; sort(v.begin(), v.end(), compare); for(auto &amp;amp;el : v) cout &amp;lt;&amp;lt; el.m_name &amp;lt;&amp;lt; &#39;\\n&#39;; return 0;}SOL 비교해야 할 대상이 3개 이상이기에 pair를 사용하기 보단 조금 번거롭더라도 사용자 정의 자료형 class student와 operator의 개념을 이용하여 해결한다.Reference &amp;amp; 다른 PS 모음집https://github.com/ggh-png/PSC++ STL sort ( )" }, { "title": "BOJ - 1676 - 팩토리얼 0의 개수", "url": "/posts/BOJ-1676/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, math", "date": "2022-05-28 11:10:00 +0900", "snippet": "BOJ - 1676 - 팩토리얼 0의 개수문제1676번: 팩토리얼 0의 개수문제 개념문제N!에서 뒤에서부터 처음 0이 아닌 숫자가 나올 때까지 0의 개수를 구하는 프로그램을 작성하시오. 10!이 12314400 이라 할 때 2가 출력 되어야 한다.입력첫째 줄에 N이 주어진다. (0 ≤ N ≤ 500)출력첫째 줄에 구한 0의 개수를 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt; using namespace std;int main(){ int num; cin &amp;gt;&amp;gt; num; int tmp1, tmp2, tmp3; tmp1 = num / 5; tmp2 = num / 25; tmp3 = num / 125; cout &amp;lt;&amp;lt; tmp1 + tmp2 + tmp3; return 0;}SOL 뒤에서 0이 나올 경우는 10의 제곱일 경우 뿐이다. 따라서 5 그리고 2로 나눠지는 경우를 구한다. N이 500까지기에 5, 25, 125의 개수를 구한 후 더해 문제를 해결한다. Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 start" }, { "title": "BOJ - 6588 - 골드바흐의 추측", "url": "/posts/BOJ-6588/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, math", "date": "2022-05-25 11:10:00 +0900", "snippet": "BOJ - 6588 - 골드바흐의 추측문제6588번: 골드바흐의 추측문제 개념문제1742년, 독일의 아마추어 수학가 크리스티안 골드바흐는 레온하르트 오일러에게 다음과 같은 추측을 제안하는 편지를 보냈다. 4보다 큰 모든 짝수는 두 홀수 소수의 합으로 나타낼 수 있다.예를 들어 8은 3 + 5로 나타낼 수 있고, 3과 5는 모두 홀수인 소수이다. 또, 20 = 3 + 17 = 7 + 13, 42 = 5 + 37 = 11 + 31 = 13 + 29 = 19 + 23 이다.이 추측은 아직도 해결되지 않은 문제이다.백만 이하의 모든 짝수에 대해서, 이 추측을 검증하는 프로그램을 작성하시오.입력입력은 하나 또는 그 이상의 테스트 케이스로 이루어져 있다. 테스트 케이스의 개수는 100,000개를 넘지 않는다.각 테스트 케이스는 짝수 정수 n 하나로 이루어져 있다. (6 ≤ n ≤ 1000000)입력의 마지막 줄에는 0이 하나 주어진다.출력각 테스트 케이스에 대해서, n = a + b 형태로 출력한다. 이때, a와 b는 홀수 소수이다. 숫자와 연산자는 공백 하나로 구분되어져 있다. 만약, n을 만들 수 있는 방법이 여러 가지라면, b-a가 가장 큰 것을 출력한다. 또, 두 홀수 소수의 합으로 n을 나타낼 수 없는 경우에는 “Goldbach’s conjecture is wrong.”을 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;cmath&amp;gt;using namespace std;int main(){ ios_base :: sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); vector&amp;lt;bool&amp;gt; arr(1000001, 0); arr[0] = true; arr[1] = true; // 소수 추출 int cnt = 2; for(int i=0; i &amp;lt;= sqrt(1000001); i++) if(!arr[i]) for(int j=i+i; j &amp;lt;= 1000001; j+=i) { arr[j] = true; cnt++; } // test case while(1) { int N; cin &amp;gt;&amp;gt; N; if(N == 0) break; int a=0, b=0; for(int j=3; j &amp;lt;= N; j+=2) if(!arr[j] &amp;amp;&amp;amp; !arr[N-j]) { a = j; b = N-j; cout &amp;lt;&amp;lt; N &amp;lt;&amp;lt; &quot; = &quot; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &quot; + &quot; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; &#39;\\n&#39;; break; } if(!a &amp;amp;&amp;amp; !b) cout &amp;lt;&amp;lt; &quot;Goldbach&#39;s conjecture is wrong.\\n&quot;; } return 0;}SOL 소수 추출 합한 값이 조건에 맞을 경우 (위 문제는 2중 for문을 사용할 시 시간 초과가 발생함.) 때문에 조건을 걸어두어 1중 for문으로 해결.Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 start" }, { "title": "BOJ - 9020 - 골드바흐의 추측", "url": "/posts/BOJ-9020/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, math", "date": "2022-05-23 11:10:00 +0900", "snippet": "BOJ - 9020 - 골드바흐의 추측문제9020번: 골드바흐의 추측문제 개념문제1보다 큰 자연수 중에서  1과 자기 자신을 제외한 약수가 없는 자연수를 소수라고 한다. 예를 들어, 5는 1과 5를 제외한 약수가 없기 때문에 소수이다. 하지만, 6은 6 = 2 × 3 이기 때문에 소수가 아니다.골드바흐의 추측은 유명한 정수론의 미해결 문제로, 2보다 큰 모든 짝수는 두 소수의 합으로 나타낼 수 있다는 것이다. 이러한 수를 골드바흐 수라고 한다. 또, 짝수를 두 소수의 합으로 나타내는 표현을 그 수의 골드바흐 파티션이라고 한다. 예를 들면, 4 = 2 + 2, 6 = 3 + 3, 8 = 3 + 5, 10 = 5 + 5, 12 = 5 + 7, 14 = 3 + 11, 14 = 7 + 7이다. 10000보다 작거나 같은 모든 짝수 n에 대한 골드바흐 파티션은 존재한다.2보다 큰 짝수 n이 주어졌을 때, n의 골드바흐 파티션을 출력하는 프로그램을 작성하시오. 만약 가능한 n의 골드바흐 파티션이 여러 가지인 경우에는 두 소수의 차이가 가장 작은 것을 출력한다.입력첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고 짝수 n이 주어진다.출력각 테스트 케이스에 대해서 주어진 n의 골드바흐 파티션을 출력한다. 출력하는 소수는 작은 것부터 먼저 출력하며, 공백으로 구분한다.제한 4 ≤ n ≤ 10,000구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;cmath&amp;gt;using namespace std;int main(){ ios_base :: sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); vector&amp;lt;bool&amp;gt; arr(10001, 0); arr[0] = true; arr[1] = true; // 소수 추출 for(int i=0; i &amp;lt;= sqrt(10001); i++) if(!arr[i]) for(int j=i+i; j &amp;lt;= 10001; j+=i) arr[j] = true; vector&amp;lt;int&amp;gt; v; for(int i=0; i &amp;lt;= 10001; i++) if(!arr[i]) v.push_back(i); int num; cin &amp;gt;&amp;gt; num; for(int i=0; i &amp;lt; num; i++) { int N; cin &amp;gt;&amp;gt; N; int a, b; for(int j=0; j &amp;lt; v.size(); j++) for(int k=j; k &amp;lt; v.size(); k++) if((N-v[j]) == v[k]) { a = v[j]; b = v[k]; break; } cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; &#39;\\n&#39;; } return 0;}SOL 소수 추출 vector에 입력 for문의 마지막 값 출력 Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 start" }, { "title": "BOJ - 2231 - 분해합", "url": "/posts/BOJ-2231/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, BruteForce", "date": "2022-05-19 11:10:00 +0900", "snippet": "BOJ - 2231 - 분해합문제2231번: 분해합문제 개념문제어떤 자연수 N이 있을 때, 그 자연수 N의 분해합은 N과 N을 이루는 각 자리수의 합을 의미한다. 어떤 자연수 M의 분해합이 N인 경우, M을 N의 생성자라 한다. 예를 들어, 245의 분해합은 256(=245+2+4+5)이 된다. 따라서 245는 256의 생성자가 된다. 물론, 어떤 자연수의 경우에는 생성자가 없을 수도 있다. 반대로, 생성자가 여러 개인 자연수도 있을 수 있다.자연수 N이 주어졌을 때, N의 가장 작은 생성자를 구해내는 프로그램을 작성하시오.입력첫째 줄에 자연수 N(1 ≤ N ≤ 1,000,000)이 주어진다.출력첫째 줄에 답을 출력한다. 생성자가 없는 경우에는 0을 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;int main(){ int num; cin &amp;gt;&amp;gt; num; // 10 int cnt = num; vector&amp;lt;int&amp;gt; v; while(cnt &amp;gt; 0) { cnt--; int temp = cnt; string str = to_string(cnt); for(auto &amp;amp;el : str) temp += el - 48; // 분해합 조건이 맞을 경우 if(temp == num) v.push_back(cnt); } // 분해합의 요소가 있으면 가장 작은 값을 출력 if(!v.empty()) cout &amp;lt;&amp;lt; v.back(); else cout &amp;lt;&amp;lt; &quot;0&quot;; return 0;}SOL 분해합의 조건이 맞으면 v.push_back(cnt) 분해합의 조건을 만족한 벡터 중 가장 작은 값을 출력 (큐 성질 사용) Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 start" }, { "title": "BOJ - 4673 - 셀프 넘버", "url": "/posts/BOJ-4673/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, 함수", "date": "2022-05-18 11:10:00 +0900", "snippet": "BOJ - 4673 - 셀프 넘버문제4673번: 셀프 넘버문제 개념문제셀프 넘버는 1949년 인도 수학자 D.R. Kaprekar가 이름 붙였다. 양의 정수 n에 대해서 d(n)을 n과 n의 각 자리수를 더하는 함수라고 정의하자. 예를 들어, d(75) = 75+7+5 = 87이다.양의 정수 n이 주어졌을 때, 이 수를 시작해서 n, d(n), d(d(n)), d(d(d(n))), …과 같은 무한 수열을 만들 수 있다.예를 들어, 33으로 시작한다면 다음 수는 33 + 3 + 3 = 39이고, 그 다음 수는 39 + 3 + 9 = 51, 다음 수는 51 + 5 + 1 = 57이다. 이런식으로 다음과 같은 수열을 만들 수 있다.33, 39, 51, 57, 69, 84, 96, 111, 114, 120, 123, 129, 141, …n을 d(n)의 생성자라고 한다. 위의 수열에서 33은 39의 생성자이고, 39는 51의 생성자, 51은 57의 생성자이다. 생성자가 한 개보다 많은 경우도 있다. 예를 들어, 101은 생성자가 2개(91과 100) 있다.생성자가 없는 숫자를 셀프 넘버라고 한다. 100보다 작은 셀프 넘버는 총 13개가 있다. 1, 3, 5, 7, 9, 20, 31, 42, 53, 64, 75, 86, 9710000보다 작거나 같은 셀프 넘버를 한 줄에 하나씩 출력하는 프로그램을 작성하시오.입력입력은 없다.출력10,000보다 작거나 같은 셀프 넘버를 한 줄에 하나씩 증가하는 순서로 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;int solution(string n){ int sum = stoi(n); for(auto &amp;amp;el : n) sum += el - 48; return sum;}int main(){ vector&amp;lt;bool&amp;gt; v(10000, false); for(int i=0; i &amp;lt; 10001; i++) { int temp = solution(to_string(i)); if(temp &amp;lt;= 10000) v[temp] = true; } for(int i=0; i &amp;lt; v.size(); i++) if(!v[i]) cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &#39;\\n&#39;; return 0;}SOL 문자열로 변환 후 셀프넘버 추출 중복값 제거 출력 Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 start" }, { "title": "BOJ - 2941 - 크로아티아 알파벳", "url": "/posts/BOJ-2941/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, 구현", "date": "2022-05-16 11:10:00 +0900", "snippet": "BOJ - 2941 - 크로아티아 알파벳문제2941번: 크로아티아 알파벳문제 개념문제예전에는 운영체제에서 크로아티아 알파벳을 입력할 수가 없었다. 따라서, 다음과 같이 크로아티아 알파벳을 변경해서 입력했다.예를 들어, ljes=njak은 크로아티아 알파벳 6개(lj, e, š, nj, a, k)로 이루어져 있다. 단어가 주어졌을 때, 몇 개의 크로아티아 알파벳으로 이루어져 있는지 출력한다.dž는 무조건 하나의 알파벳으로 쓰이고, d와 ž가 분리된 것으로 보지 않는다. lj와 nj도 마찬가지이다. 위 목록에 없는 알파벳은 한 글자씩 센다.입력첫째 줄에 최대 100글자의 단어가 주어진다. 알파벳 소문자와 ‘-‘, ‘=’로만 이루어져 있다.단어는 크로아티아 알파벳으로 이루어져 있다. 문제 설명의 표에 나와있는 알파벳은 변경된 형태로 입력된다.출력입력으로 주어진 단어가 몇 개의 크로아티아 알파벳으로 이루어져 있는지 출력한다.구현#include&amp;lt;iostream&amp;gt;#include&amp;lt;string&amp;gt;#include&amp;lt;vector&amp;gt;using namespace std;int main() { cin.tie(NULL); ios::sync_with_stdio(false); vector&amp;lt;string&amp;gt; v = {&quot;c=&quot;,&quot;c-&quot;, &quot;dz=&quot;, &quot;d-&quot;, &quot;lj&quot;, &quot;nj&quot;, &quot;s=&quot;, &quot;z=&quot;}; string str; cin &amp;gt;&amp;gt; str; int index; for (int i = 0; i &amp;lt; v.size(); i++) while (1) { // iterator 반환 // 찾지 못하면 -1 반환 index = str.find(v[i]); if (index == string::npos) break; str.replace(index, v[i].length(), &quot;#&quot;); } cout &amp;lt;&amp;lt; str.size(); return 0;}SOL 크로아티아 알파벳이 있으면 #으로 replace Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 start" }, { "title": "BOJ - 1316 - 그룹 단어 체커", "url": "/posts/BOJ-1316/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, 구현", "date": "2022-05-16 11:10:00 +0900", "snippet": "BOJ - 2941 - 크로아티아 알파벳문제1316번: 그룹 단어 체커문제 개념문제그룹 단어란 단어에 존재하는 모든 문자에 대해서, 각 문자가 연속해서 나타나는 경우만을 말한다. 예를 들면, ccazzzzbb는 c, a, z, b가 모두 연속해서 나타나고, kin도 k, i, n이 연속해서 나타나기 때문에 그룹 단어이지만, aabbbccb는 b가 떨어져서 나타나기 때문에 그룹 단어가 아니다.단어 N개를 입력으로 받아 그룹 단어의 개수를 출력하는 프로그램을 작성하시오.입력첫째 줄에 단어의 개수 N이 들어온다. N은 100보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 단어가 들어온다. 단어는 알파벳 소문자로만 되어있고 중복되지 않으며, 길이는 최대 100이다.출력첫째 줄에 그룹 단어의 개수를 출력한다.구현#include&amp;lt;iostream&amp;gt;#include&amp;lt;string&amp;gt;#include&amp;lt;vector&amp;gt;using namespace std;int main() { cin.tie(NULL); ios::sync_with_stdio(false); vector&amp;lt;string&amp;gt; v = {&quot;c=&quot;,&quot;c-&quot;, &quot;dz=&quot;, &quot;d-&quot;, &quot;lj&quot;, &quot;nj&quot;, &quot;s=&quot;, &quot;z=&quot;}; string str; cin &amp;gt;&amp;gt; str; int index; for (int i = 0; i &amp;lt; v.size(); i++) while (1) { // iterator 반환 // 찾지 못하면 -1 반환 index = str.find(v[i]); if (index == string::npos) break; str.replace(index, v[i].length(), &quot;#&quot;); } cout &amp;lt;&amp;lt; str.size(); return 0;}SOL 연속되는 중복값 제거. count sort 의 개념을 이용하여 2회 이상 사용된 알파벳 탐색. 그룹 단어 판단. Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 start" }, { "title": "BOJ - 11047 - 동전 0", "url": "/posts/BOJ-11047/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, greedy", "date": "2022-05-12 11:10:00 +0900", "snippet": "BOJ - 11047 - 동전 0문제11047번: 동전 0문제 개념문제준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다.동전을 적절히 사용해서 그 가치의 합을 K로 만들려고 한다. 이때 필요한 동전 개수의 최솟값을 구하는 프로그램을 작성하시오.입력첫째 줄에 N과 K가 주어진다. (1 ≤ N ≤ 10, 1 ≤ K ≤ 100,000,000)둘째 줄부터 N개의 줄에 동전의 가치 Ai가 오름차순으로 주어진다. (1 ≤ Ai ≤ 1,000,000, A1 = 1, i ≥ 2인 경우에 Ai는 Ai-1의 배수)출력첫째 줄에 K원을 만드는데 필요한 동전 개수의 최솟값을 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;int main(){ int num, money, answer=0; cin &amp;gt;&amp;gt; num &amp;gt;&amp;gt; money; vector&amp;lt;int&amp;gt; coin(num); // 동전 입력 for(int i=0; i &amp;lt; num; i++) cin &amp;gt;&amp;gt; coin[i]; // 잔액이 양수이고, 최대코인보다 많을 때 while(money != 0) for(int i = num-1; i &amp;gt;= 0; i--) while(money &amp;gt;= coin[i]) { money -= coin[i]; answer++; } cout &amp;lt;&amp;lt; answer; return 0;}SOL 남은 잔액이 양수고, 최대코인보다 많을 경우 동전사용 Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 start" }, { "title": "BOJ - 1747 - 소수&amp;팰린드롬", "url": "/posts/BOJ-1747/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, BruteForce", "date": "2022-05-10 11:10:00 +0900", "snippet": "BOJ - 1747 - 소수&amp;amp;팰린드롬문제1747번: 소수&amp;amp;팰린드롬문제 개념문제어떤 수와 그 수의 숫자 순서를 뒤집은 수가 일치하는 수를 팰린드롬이라 부른다. 예를 들어 79,197과 324,423 등이 팰린드롬 수이다.어떤 수 N (1 ≤ N ≤ 1,000,000)이 주어졌을 때, N보다 크거나 같고, 소수이면서 팰린드롬인 수 중에서, 가장 작은 수를 구하는 프로그램을 작성하시오.입력첫째 줄에 N이 주어진다.출력첫째 줄에 조건을 만족하는 수를 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;int main(){ int num; int answer; cin &amp;gt;&amp;gt; num; vector&amp;lt;bool&amp;gt; arr(10000001, 0); arr[1] = true; for(int i=2; i &amp;lt;= sqrt(10000000); i++) { if(!arr[i]) for(int j=i+i; j &amp;lt;= 10000000; j+=i) arr[j] = true; } for(int i=0; i &amp;lt; 10000001; i++) { if(!arr[i] &amp;amp;&amp;amp; i &amp;gt;= num)// 소수 이면서 { // 문자열로 변환 후 revese시에도 같은수면 string temp = to_string(i); reverse(temp.begin(), temp.end()); if(temp == to_string(i)) { answer = i; break; } } } cout &amp;lt;&amp;lt; answer &amp;lt;&amp;lt; endl; return 0;}SOL 에라토스테네스의 체 알고리즘을 통해 10,000,000까지의 소수 추출 후 추출된 요소들 중 소수이면서 문자열로 변환 후 reverse시에도 같은 경우를 구함.Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 start[알고리즘] 에라토스테네스의 체 (C++) - 소수 찾기" }, { "title": "BOJ - 1449 - 수리공 항승", "url": "/posts/BOJ-1449/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, greedy", "date": "2022-05-09 11:10:00 +0900", "snippet": "BOJ - 1449 - 수리공 항승문제1449번: 수리공 항승문제 개념문제항승이는 품질이 심각하게 나쁜 수도 파이프 회사의 수리공이다. 항승이는 세준 지하철 공사에서 물이 샌다는 소식을 듣고 수리를 하러 갔다.파이프에서 물이 새는 곳은 신기하게도 가장 왼쪽에서 정수만큼 떨어진 거리만 물이 샌다.항승이는 길이가 L인 테이프를 무한개 가지고 있다.항승이는 테이프를 이용해서 물을 막으려고 한다. 항승이는 항상 물을 막을 때, 적어도 그 위치의 좌우 0.5만큼 간격을 줘야 물이 다시는 안 샌다고 생각한다.물이 새는 곳의 위치와, 항승이가 가지고 있는 테이프의 길이 L이 주어졌을 때, 항승이가 필요한 테이프의 최소 개수를 구하는 프로그램을 작성하시오. 테이프를 자를 수 없고, 테이프를 겹쳐서 붙이는 것도 가능하다.입력첫째 줄에 물이 새는 곳의 개수 N과 테이프의 길이 L이 주어진다. 둘째 줄에는 물이 새는 곳의 위치가 주어진다. N과 L은 1,000보다 작거나 같은 자연수이고, 물이 새는 곳의 위치는 1,000보다 작거나 같은 자연수이다.출력첫째 줄에 항승이가 필요한 테이프의 개수를 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std; int main(){ // 구멍의 개수, 테이프의 길이 // 구멍의 위치 // 구멍을 막기위한 최소의 테이프의 개수를 구하여라. int num, L; cin &amp;gt;&amp;gt; num &amp;gt;&amp;gt; L; vector&amp;lt;int&amp;gt; x(num); for(int i=0; i &amp;lt; num; i++) cin &amp;gt;&amp;gt; x[i]; // 오름차순 정렬 // 1 2 5 6 8 // L 2 // answer 3 // a - b + 1 == 구멍의 크기 sort(x.begin(), x.end()); // 구멍의 크기 int answer = 0; while(!x.empty()) { int len = L; // 테잎 길이 int idx = 0; int temp = 0; while(temp &amp;lt;= len) // 구멍의 크기가 테잎의 길이보다 길어지면 { temp = x[idx] - x[0] + 1; idx++; if(idx == x.size()) break; } answer++; // 구멍 크기를 막고, 테잎의 개수 증가 if(temp &amp;gt; len) x.erase(x.begin(), x.begin() + idx - 1); else if(idx == x.size() &amp;amp;&amp;amp; temp &amp;lt;= len) x.clear(); } cout &amp;lt;&amp;lt; answer &amp;lt;&amp;lt; endl; return 0;}SOL 구멍위치를 벡터로 저장 후 오름차순 정렬 구멍 크기가 테잎 길이보다 크면 테이프 추가사용 구멍 크기가 테잎 길이보다 작거나 같으면 마무리 Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 start" }, { "title": "BOJ - 7568 - 덩치", "url": "/posts/BOJ-7568/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, BruteForce", "date": "2022-05-08 11:10:00 +0900", "snippet": "BOJ - 7568 - 덩치문제https://www.acmicpc.net/problem/7568문제 개념문제우리는 사람의 덩치를 키와 몸무게, 이 두 개의 값으로 표현하여 그 등수를 매겨보려고 한다. 어떤 사람의 몸무게가 x kg이고 키가 y cm라면 이 사람의 덩치는 (x, y)로 표시된다. 두 사람 A 와 B의 덩치가 각각 (x, y), (p, q)라고 할 때 x &amp;gt; p 그리고 y &amp;gt; q 이라면 우리는 A의 덩치가 B의 덩치보다 “더 크다”고 말한다. 예를 들어 어떤 A, B 두 사람의 덩치가 각각 (56, 177), (45, 165) 라고 한다면 A의 덩치가 B보다 큰 셈이 된다. 그런데 서로 다른 덩치끼리 크기를 정할 수 없는 경우도 있다. 예를 들어 두 사람 C와 D의 덩치가 각각 (45, 181), (55, 173)이라면 몸무게는 D가 C보다 더 무겁고, 키는 C가 더 크므로, “덩치”로만 볼 때 C와 D는 누구도 상대방보다 더 크다고 말할 수 없다.N명의 집단에서 각 사람의 덩치 등수는 자신보다 더 “큰 덩치”의 사람의 수로 정해진다. 만일 자신보다 더 큰 덩치의 사람이 k명이라면 그 사람의 덩치 등수는 k+1이 된다. 이렇게 등수를 결정하면 같은 덩치 등수를 가진 사람은 여러 명도 가능하다. 아래는 5명으로 이루어진 집단에서 각 사람의 덩치와 그 등수가 표시된 표이다.위 표에서 C보다 더 큰 덩치의 사람이 없으므로 C는 1등이 된다. 그리고 A, B, D 각각의 덩치보다 큰 사람은 C뿐이므로 이들은 모두 2등이 된다. 그리고 E보다 큰 덩치는 A, B, C, D 이렇게 4명이므로 E의 덩치는 5등이 된다. 위 경우에 3등과 4등은 존재하지 않는다. 여러분은 학생 N명의 몸무게와 키가 담긴 입력을 읽어서 각 사람의 덩치 등수를 계산하여 출력해야 한다.입력첫 줄에는 전체 사람의 수 N이 주어진다. 그리고 이어지는 N개의 줄에는 각 사람의 몸무게와 키를 나타내는 양의 정수 x와 y가 하나의 공백을 두고 각각 나타난다.출력여러분은 입력에 나열된 사람의 덩치 등수를 구해서 그 순서대로 첫 줄에 출력해야 한다. 단, 각 덩치 등수는 공백문자로 분리되어야 한다.제한 2 ≤ N ≤ 50 10 ≤ x, y ≤ 200구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;int main(){ int num, x, y; cin &amp;gt;&amp;gt; num; vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; xy; vector&amp;lt;int&amp;gt; rank(num, 1); for(int i=0; i &amp;lt; num; i++) { cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y; xy.push_back(pair&amp;lt;int, int&amp;gt;(x, y)); } for(int i=0; i &amp;lt; num; i++) for(int j=0; j &amp;lt; num; j++) { // 덩치가 확실히 비교가 된다면. if((i != j) &amp;amp;&amp;amp; xy[i].first &amp;lt; xy[j].first &amp;amp;&amp;amp; xy[i].second &amp;lt; xy[j].second) rank[i]++; } for(auto &amp;amp;el : rank) cout &amp;lt;&amp;lt; el &amp;lt;&amp;lt; &quot; &quot;; return 0;}SOL rank vector를 1로 초기화 후 first &amp;amp;&amp;amp; second의 조건이 모두 충족할 때만 count 하는 방식으로 해결.Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 start" }, { "title": "BOJ - 5635- 생일", "url": "/posts/BOJ-5635/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, 정렬", "date": "2022-05-08 11:10:00 +0900", "snippet": "BOJ - 5635- 생일문제5635번: 생일문제 개념문제어떤 반에 있는 학생들의 생일이 주어졌을 때, 가장 나이가 적은 사람과 가장 많은 사람을 구하는 프로그램을 작성하시오.입력첫째 줄에 반에 있는 학생의 수 n이 주어진다. (1 ≤ n ≤ 100)다음 n개 줄에는 각 학생의 이름과 생일이 “이름 dd mm yyyy”와 같은 형식으로 주어진다. 이름은 그 학생의 이름이며, 최대 15글자로 이루어져 있다. dd mm yyyy는 생일 일, 월, 연도이다. (1990 ≤ yyyy ≤ 2010, 1 ≤ mm ≤ 12, 1 ≤ dd ≤ 31) 주어지는 생일은 올바른 날짜이며, 연, 월 일은 0으로 시작하지 않는다.이름이 같거나, 생일이 같은 사람은 없다.출력첫째 줄에 가장 나이가 적은 사람의 이름, 둘째 줄에 가장 나이가 많은 사람 이름을 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;class Student{public: string m_name; int m_years, m_month, m_days; Student(string name, int years, int month, int days) { this-&amp;gt;m_name = name; this-&amp;gt;m_years = years; this-&amp;gt;m_month = month; this-&amp;gt;m_days = days; } bool operator &amp;lt; (Student &amp;amp;student) { if(this-&amp;gt;m_years == student.m_years) { if(this-&amp;gt;m_month == student.m_month) return this-&amp;gt;m_days &amp;lt; student.m_days; else return this-&amp;gt;m_month &amp;lt; student.m_month; } else return this-&amp;gt;m_years &amp;lt; student.m_years; }};int main(){ int num; string name; int years, month, days; cin &amp;gt;&amp;gt; num; vector&amp;lt;Student&amp;gt; v; for(int i=0; i &amp;lt; num; i++) { cin &amp;gt;&amp;gt; name &amp;gt;&amp;gt; days &amp;gt;&amp;gt; month &amp;gt;&amp;gt; years; Student stu(name, years, month, days); v.push_back(stu); } sort(v.rbegin(), v.rend()); cout &amp;lt;&amp;lt; v[0].m_name &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; v[num-1].m_name; return 0;}SOL 비교해야 할 대상이 3개 이상이기에 pair를 사용하기 보단 조금 번거롭더라도 사용자 정의 자료형 class student와 operator의 개념을 이용하여 해결한다.Reference &amp;amp; 다른 PS 모음집https://github.com/ggh-png/PSC++ STL sort ( )" }, { "title": "BOJ - 11170 - 0의 개수", "url": "/posts/BOJ-11170/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, math, BruteForce", "date": "2022-05-07 11:10:00 +0900", "snippet": "BOJ - 11170 - 0의 개수문제11170번: 0의 개수문제 개념문제N부터 M까지의 수들을 종이에 적었을 때 종이에 적힌 0들을 세는 프로그램을 작성하라.예를 들어, N, M이 각각 0, 10일 때 0을 세면 0에 하나, 10에 하나가 있으므로 답은 2이다.입력첫 번째 줄에 테스트 케이스의 수 T가 주어진다.각 줄에는 N과 M이 주어진다. 1 ≤ T ≤ 20 0 ≤ N ≤ M ≤ 1,000,000출력각각의 테스트 케이스마다 N부터 M까지의 0의 개수를 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;// m n까지의 수중 0이 포함되어있는 경우의 개수를 구해라.int main(){ int num, M, N; cin &amp;gt;&amp;gt; num; for(int i=0; i &amp;lt; num; i++) { int cnt=0; cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M; for(int j=N; j &amp;lt;= M; j++) { // 1004 string temp = to_string(j); for(auto &amp;amp;el : temp) { if(el == &#39;0&#39;) cnt++; } } cout &amp;lt;&amp;lt; cnt &amp;lt;&amp;lt; &#39;\\n&#39;; } return 0;}SOL string 형으로 변환 후 ‘0’ 탐색Reference &amp;amp; 다른 PS 모음집GitHub - ggh-png/PS: 2021.01.11 start" }, { "title": "BOJ - 1021 - 회전하는 큐", "url": "/posts/BOJ-1021/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, deque, queue", "date": "2022-05-04 11:10:00 +0900", "snippet": "BOJ - 1021 - 회전하는 큐문제1021번: 회전하는 큐문제 개념문제지민이는 N개의 원소를 포함하고 있는 양방향 순환 큐를 가지고 있다. 지민이는 이 큐에서 몇 개의 원소를 뽑아내려고 한다.지민이는 이 큐에서 다음과 같은 3가지 연산을 수행할 수 있다. 첫 번째 원소를 뽑아낸다. 왼쪽으로 한 칸 이동시킨다. 오른쪽으로 한 칸 이동시킨다.큐에 처음에 포함되어 있던 수 N이 주어진다. 그리고 지민이가 뽑아내려고 하는 원소의 위치가 주어진다. (이 위치는 가장 처음 큐에서의 위치이다.) 이때, 그 원소를 주어진 순서대로 뽑아내는데 드는 2번, 3번 연산의 최솟값을 출력하는 프로그램을 작성하시오.입력첫째 줄에 큐의 크기 N과 뽑아내려고 하는 수의 개수 M이 주어진다. N은 50보다 작거나 같은 자연수이고, M은 N보다 작거나 같은 자연수이다. 둘째 줄에는 지민이가 뽑아내려고 하는 수의 위치가 순서대로 주어진다. 위치는 1보다 크거나 같고, N보다 작거나 같은 자연수이다.출력첫째 줄에 문제의 정답을 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;deque&amp;gt;using namespace std;/* 문제지민이는 N개의 원소를 포함하고 있는 양방향 순환 큐를 가지고 있다.지민이는 이 큐에서 몇 개의 원소를 뽑아내려고 한다.지민이는 이 큐에서 다음과 같은 3가지 연산을 수행할 수 있다.1. 첫 번째 원소를 뽑아낸다.2. 왼쪽으로 한 칸 이동시킨다.3. 오른쪽으로 한 칸 이동시킨다.큐에 처음에 포함되어 있던 수 N이 주어진다.N 0 ~ N 까지의 큐가 존재하는듯 함. 그리고 지민이가 뽑아내려고 하는 원소의 위치가 주어진다. (이 위치는 가장 처음 큐에서의 위치이다.)M 이때, 그 원소를 주어진 순서대로 뽑아내는데 드는 2번, 3번 연산의 최솟값을 출력하는 프로그램을 작성하시오.입력첫째 줄에 큐의 크기 N과 뽑아내려고 하는 수의 개수 M이 주어진다.N 10, M 310개의 큐 중 3개를 뽑는데 두번째 줄에는 뽑으려고 하는 수의 인덱스가 주어져 있다. N은 50보다 작거나 같은 자연수이고, M은 N보다 작거나 같은 자연수이다.둘째 줄에는 지민이가 뽑아내려고 하는 수의 위치가 순서대로 주어진다.1 2 3위치는 1보다 크거나 같고, N보다 작거나 같은 자연수이다.10 3 2 9 5work flow1 2 3 4 5 6 7 8 9 10L 12 3 4 5 6 7 8 9 10 1O 13 4 5 6 7 8 9 10 1 - 2R 21 3 4 5 6 7 8 9 10 - 2R 310 1 3 4 5 6 7 8 9 - 2R 49 10 1 3 4 5 6 7 8 - 2 O 410 1 3 4 5 6 7 8 - 2 9L 58 10 1 3 4 5 6 7 - 2 9L 67 8 10 1 3 4 5 6 - 2 9L 7 6 7 8 10 1 3 4 5 - 2 9L 85 6 7 8 10 1 3 4 - 2 9O 86 7 8 10 1 3 4 - 2 9 5*/int main(){ ios_base :: sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int N, M; cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M; // 찾을 idx deque&amp;lt;int&amp;gt; dq; // N개의 dq 생성 for(int i=1; i &amp;lt;= N; i++) dq.push_back(i); deque&amp;lt;int&amp;gt; idx; int count = 0; for(int i=0; i &amp;lt; M; i++) { int num; cin &amp;gt;&amp;gt; num; int L=0, R=0; for(int i=0; i &amp;lt; dq.size(); i++) { if(dq[i] == num) { L = i; R = dq.size() - L; break; } } if(L &amp;lt;= R) while(1) { if(num == dq.front()) { dq.pop_front(); break; } dq.push_back(dq.front()); dq.pop_front(); count++; } else while(1) { if(num == dq.front()) { dq.pop_front(); break; } dq.push_front(dq.back()); dq.pop_back(); count++; } } cout &amp;lt;&amp;lt; count; return 0;}SOL2번 연산과 3번 연산을 모두 해본 후 효율성을 따져 최솟 값을 구할 수 있는 연산을 이용하여 최적의 해를 구한다.Reference &amp;amp; 다른 PS 모음집https://github.com/ggh-png/PSSTACK &amp;amp; QUEUE" }, { "title": "BOJ - 5430 - AC", "url": "/posts/BOJ-5430/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, deque", "date": "2022-05-03 11:10:00 +0900", "snippet": "BOJ - 5430 - AC문제5430번: AC문제 개념문제선영이는 주말에 할 일이 없어서 새로운 언어 AC를 만들었다. AC는 정수 배열에 연산을 하기 위해 만든 언어이다. 이 언어에는 두 가지 함수 R(뒤집기)과 D(버리기)가 있다.함수 R은 배열에 있는 수의 순서를 뒤집는 함수이고, D는 첫 번째 수를 버리는 함수이다. 배열이 비어있는데 D를 사용한 경우에는 에러가 발생한다.함수는 조합해서 한 번에 사용할 수 있다. 예를 들어, “AB”는 A를 수행한 다음에 바로 이어서 B를 수행하는 함수이다. 예를 들어, “RDD”는 배열을 뒤집은 다음 처음 두 수를 버리는 함수이다.배열의 초기값과 수행할 함수가 주어졌을 때, 최종 결과를 구하는 프로그램을 작성하시오.입력첫째 줄에 테스트 케이스의 개수 T가 주어진다. T는 최대 100이다.각 테스트 케이스의 첫째 줄에는 수행할 함수 p가 주어진다. p의 길이는 1보다 크거나 같고, 100,000보다 작거나 같다.다음 줄에는 배열에 들어있는 수의 개수 n이 주어진다. (0 ≤ n ≤ 100,000)다음 줄에는 [x1,…,xn]과 같은 형태로 배열에 들어있는 정수가 주어진다. (1 ≤ xi ≤ 100)전체 테스트 케이스에 주어지는 p의 길이의 합과 n의 합은 70만을 넘지 않는다.출력각 테스트 케이스에 대해서, 입력으로 주어진 정수 배열에 함수를 수행한 결과를 출력한다. 만약, 에러가 발생한 경우에는 error를 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;deque&amp;gt;using namespace std; /* test case num order test resource*/int main(){ ios_base :: sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int num; cin &amp;gt;&amp;gt; num; deque&amp;lt;string&amp;gt; answer; for(int i=0; i &amp;lt; num; i++) { string OrderList; string tmp=&quot;&quot;; int N; deque&amp;lt;int&amp;gt; L; string gb; cin &amp;gt;&amp;gt; OrderList &amp;gt;&amp;gt; N &amp;gt;&amp;gt; gb; // 리스트 추출 // [1,2,3,4] -&amp;gt; 1 2 3 4 for(int j=1; j &amp;lt; gb.size()-1; j++) { if(gb[j] != &#39;,&#39;) { if(gb[j+1] == &#39;]&#39;) { tmp += gb[j]; L.push_back(stoi(tmp)); } else tmp += gb[j]; } else if(tmp != &quot;&quot;) { L.push_back(stoi(tmp)); tmp = &quot;&quot;; } } // 명령어 처리 // 매번마다 reverse를 해주면 시간초과가 발생하기에 // 덱의 특성을 이용한다. int R_count = 0; bool err = false; for(auto &amp;amp;el : OrderList) { if(!L.empty() &amp;amp;&amp;amp; el == &#39;R&#39;) R_count++; else if(!L.empty() &amp;amp;&amp;amp; el == &#39;D&#39;) { if(R_count%2 == 0) L.pop_front(); else L.pop_back(); } // 에러가 발생하는 경우 else if(L.empty() &amp;amp;&amp;amp; el == &#39;D&#39;) { err = true; answer.push_back(&quot;error&quot;); break; } } if(!L.empty()) { string temp = &quot;[&quot;; if(R_count%2 == 0) { while(!L.empty()) { temp += to_string(L.front()) + &quot;,&quot;; L.pop_front(); } temp.pop_back(); temp += &quot;]&quot;; answer.push_back(temp); } else { while(!L.empty()) { temp += to_string(L.back()) + &quot;,&quot;; L.pop_back(); } temp.pop_back(); temp += &quot;]&quot;; answer.push_back(temp); } } else if(L.empty() &amp;amp;&amp;amp; err == false) answer.push_back(&quot;[]&quot;); else continue; } while(!answer.empty()) { cout &amp;lt;&amp;lt; answer.front() &amp;lt;&amp;lt; &#39;\\n&#39;; answer.pop_front(); } return 0;}SOL 명령어 처리 R 수행시 reverse를 매번 해줄 시 시간초과가 발생하기 때문에 덱의 특성을 이용하여 해결한다. D 수행시 또한 R의 홀짝에 따라 처리를 해주어 해결한다. 짝 pop_front 홀 pop_back Reference &amp;amp; 다른 PS 모음집https://github.com/ggh-png/PSC++ STL 프로그래밍: 덱(deque)" }, { "title": "BOJ - 1406 - 에디터", "url": "/posts/BOJ-1406/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, list", "date": "2022-05-02 08:10:00 +0900", "snippet": "BOJ - 1406 - 에디터문제1406번: 에디터문제 개념문제한 줄로 된 간단한 에디터를 구현하려고 한다. 이 편집기는 영어 소문자만을 기록할 수 있는 편집기로, 최대 600,000글자까지 입력할 수 있다.이 편집기에는 ‘커서’라는 것이 있는데, 커서는 문장의 맨 앞(첫 번째 문자의 왼쪽), 문장의 맨 뒤(마지막 문자의 오른쪽), 또는 문장 중간 임의의 곳(모든 연속된 두 문자 사이)에 위치할 수 있다. 즉 길이가 L인 문자열이 현재 편집기에 입력되어 있으면, 커서가 위치할 수 있는 곳은 L+1가지 경우가 있다.이 편집기가 지원하는 명령어는 다음과 같다.L 커서를 왼쪽으로 한 칸 옮김 (커서가 문장의 맨 앞이면 무시됨)D 커서를 오른쪽으로 한 칸 옮김 (커서가 문장의 맨 뒤이면 무시됨)B 커서 왼쪽에 있는 문자를 삭제함 (커서가 문장의 맨 앞이면 무시됨) 삭제로 인해 커서는 한 칸 왼쪽으로 이동한 것처럼 나타나지만, 실제로 커서의 오른쪽에 있던 문자는 그대로임P $ $라는 문자를 커서 왼쪽에 추가함초기에 편집기에 입력되어 있는 문자열이 주어지고, 그 이후 입력한 명령어가 차례로 주어졌을 때, 모든 명령어를 수행하고 난 후 편집기에 입력되어 있는 문자열을 구하는 프로그램을 작성하시오. 단, 명령어가 수행되기 전에 커서는 문장의 맨 뒤에 위치하고 있다고 한다.입력첫째 줄에는 초기에 편집기에 입력되어 있는 문자열이 주어진다. 이 문자열은 길이가 N이고, 영어 소문자로만 이루어져 있으며, 길이는 100,000을 넘지 않는다. 둘째 줄에는 입력할 명령어의 개수를 나타내는 정수 M(1 ≤ M ≤ 500,000)이 주어진다. 셋째 줄부터 M개의 줄에 걸쳐 입력할 명령어가 순서대로 주어진다. 명령어는 위의 네 가지 중 하나의 형태로만 주어진다.출력첫째 줄에 모든 명령어를 수행하고 난 후 편집기에 입력되어 있는 문자열을 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;list&amp;gt;using namespace std; int main(){ ios_base :: sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); string str; list&amp;lt;char&amp;gt; L; int num; char temp; cin &amp;gt;&amp;gt; str &amp;gt;&amp;gt; num; // list에 삽입 for(auto &amp;amp;el : str) L.push_back(el); // list&amp;lt;char&amp;gt;::iterator idx auto idx = L.end(); for(int i=0; i &amp;lt; num; i++) { cin &amp;gt;&amp;gt; temp; if(idx != L.begin() &amp;amp;&amp;amp; temp == &#39;L&#39;) idx--; else if(idx != L.end() &amp;amp;&amp;amp; temp == &#39;D&#39;) idx++; else if(idx != L.begin() &amp;amp;&amp;amp; temp == &#39;B&#39;) { idx = L.erase(--idx); } else if(temp == &#39;P&#39;) { cin &amp;gt;&amp;gt; temp; L.insert(idx, temp); } } for(auto &amp;amp;el : L) cout &amp;lt;&amp;lt; el; cout &amp;lt;&amp;lt; &#39;\\n&#39;; return 0;}SOL list의 반복자(iterator)를 이용하여 커서의 위치를 구한다. L.erase(iterator)의 반환 값 또한 반복자 이기에 커서의 위치를 구할 수 있다. erase( )로 삭제한 바로 다음 원소의 반복자(iterator)를 반환한다. 2번째 원소를 삭제 하였으면, 3번째 원소의 iterator를 반환한다. Reference &amp;amp; 다른 PS 모음집https://github.com/ggh-png/PShttps://blossoming-man.tistory.com/entry/cstdlisterase-함수-사용-시-반환-값을-사용하자#:~:text=list에 정의되어 있는,리턴값으로 주는 것이다." }, { "title": "BOJ - 10866 - 덱", "url": "/posts/BOJ-10866/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, deque", "date": "2022-04-29 11:10:00 +0900", "snippet": "BOJ - 10866 - 덱문제10866번: 덱문제 개념문제정수를 저장하는 덱(Deque)를 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오.명령은 총 여덟 가지이다. push_front X: 정수 X를 덱의 앞에 넣는다. push_back X: 정수 X를 덱의 뒤에 넣는다. pop_front: 덱의 가장 앞에 있는 수를 빼고, 그 수를 출력한다. 만약, 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다. pop_back: 덱의 가장 뒤에 있는 수를 빼고, 그 수를 출력한다. 만약, 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다. size: 덱에 들어있는 정수의 개수를 출력한다. empty: 덱이 비어있으면 1을, 아니면 0을 출력한다. front: 덱의 가장 앞에 있는 정수를 출력한다. 만약 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다. back: 덱의 가장 뒤에 있는 정수를 출력한다. 만약 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다.입력첫째 줄에 주어지는 명령의 수 N (1 ≤ N ≤ 10,000)이 주어진다. 둘째 줄부터 N개의 줄에는 명령이 하나씩 주어진다. 주어지는 정수는 1보다 크거나 같고, 100,000보다 작거나 같다. 문제에 나와있지 않은 명령이 주어지는 경우는 없다.출력출력해야하는 명령이 주어질 때마다, 한 줄에 하나씩 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;deque&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;/* 정수를 저장하는 덱(Deque)를 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오.명령은 총 여덟 가지이다.push_front X: 정수 X를 덱의 앞에 넣는다.push_back X: 정수 X를 덱의 뒤에 넣는다.pop_front: 덱의 가장 앞에 있는 수를 빼고, 그 수를 출력한다. 만약, 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다.pop_back: 덱의 가장 뒤에 있는 수를 빼고, 그 수를 출력한다. 만약, 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다.size: 덱에 들어있는 정수의 개수를 출력한다.empty: 덱이 비어있으면 1을, 아니면 0을 출력한다.front: 덱의 가장 앞에 있는 정수를 출력한다. 만약 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다.back: 덱의 가장 뒤에 있는 정수를 출력한다. 만약 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다.*/int main(){ ios_base :: sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int num; cin &amp;gt;&amp;gt; num; deque&amp;lt;int&amp;gt; dq; queue&amp;lt;int&amp;gt; answer; for(int i=0; i &amp;lt; num; i++) { string temp; cin &amp;gt;&amp;gt; temp; if(temp == &quot;push_front&quot;) { int tmp; cin &amp;gt;&amp;gt; tmp; dq.push_front(tmp); } else if(temp == &quot;push_back&quot;) { int tmp; cin &amp;gt;&amp;gt; tmp; dq.push_back(tmp); } else if(temp == &quot;pop_front&quot;) { if(dq.empty()) answer.push(-1); else { answer.push(dq.front()); dq.pop_front(); } } else if(temp == &quot;pop_back&quot;) { if(dq.empty()) answer.push(-1); else { answer.push(dq.back()); dq.pop_back(); } } else if(temp == &quot;size&quot;) answer.push(dq.size()); else if(temp == &quot;empty&quot;) answer.push(dq.empty()); else if(temp == &quot;front&quot;) { if(dq.empty()) answer.push(-1); else answer.push(dq.front()); } else if(temp == &quot;back&quot;) { if(dq.empty()) answer.push(-1); else answer.push(dq.back()); } } // 출력 while (!answer.empty()) { cout &amp;lt;&amp;lt; answer.front() &amp;lt;&amp;lt; &#39;\\n&#39;; answer.pop(); } return 0;}SOL 덱의 명령을 수행할 덱 명령을 수행한 결과 값을 저장할 큐Reference &amp;amp; 다른 PS 모음집https://github.com/ggh-png/PSC++ STL 프로그래밍: 덱(deque)" }, { "title": "BOJ - 10816 - 숫자 카드 2", "url": "/posts/BOJ-10816/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, BinarySearch", "date": "2022-04-29 11:10:00 +0900", "snippet": "BOJ - 1081 - 숫자 카드문제10816번: 숫자 카드 2문제 개념문제 숫자 카드는 정수 하나가 적혀져 있는 카드이다. 상근이는 숫자 카드 N개를 가지고 있다. 정수 M개가 주어졌을 때, 이 수가 적혀있는 숫자 카드를 상근이가 몇 개 가지고 있는지 구하는 프로그램을 작성하시오.입력 첫째 줄에 상근이가 가지고 있는 숫자 카드의 개수 N(1 ≤ N ≤ 500,000)이 주어진다. 둘째 줄에는 숫자 카드에 적혀있는 정수가 주어진다. 숫자 카드에 적혀있는 수는 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다. 셋째 줄에는 M(1 ≤ M ≤ 500,000)이 주어진다. 넷째 줄에는 상근이가 몇 개 가지고 있는 숫자 카드인지 구해야 할 M개의 정수가 주어지며, 이 수는 공백으로 구분되어져 있다. 이 수도 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다.구현#define _CRT_SECURE_NO_WARNINGS#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;int main(){ ios_base :: sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int A_num, M_num; cin &amp;gt;&amp;gt; A_num; int A[A_num]; for(int i=0; i &amp;lt; A_num; i++) cin &amp;gt;&amp;gt; A[i]; // 기준 리스트 오름차순 정렬 sort(A, A + A_num); cin &amp;gt;&amp;gt; M_num; int answer[M_num]; for(int i=0; i &amp;lt; M_num; i++) { int temp; cin &amp;gt;&amp;gt; temp; // 이진탐색을 통한 존재유무 탐색 때문에 오름차순 정렬이 필요. int cnt = upper_bound(A, A + A_num, temp) - lower_bound(A, A + A_num, temp); answer[i] = cnt; } for(int i=0; i &amp;lt; M_num; i++) cout &amp;lt;&amp;lt; answer[i] &amp;lt;&amp;lt; &quot; &quot;; return 0;}SOL lower_bound 찾으려는 요소와 같거나 초과하는 index를 반환함. upper_bound 찾으려는 요소를 초과하는 첫번째 index를 반환함. 위 특성을 이용하면, 두 index의 차는 찾으려는 요소의 중복된 개수를 구할 수 있다. 찾으려는 값 [ 10 ] 확인 리스트 [ 1 2 3 10 10 10 ] lower_bound : 3 upper_bound : 6 [ 10 ]의 개수 : abs(lower_bound - upper_bound) Reference &amp;amp; 다른 PS 모음집https://github.com/ggh-png/PSC++ STL lower_bound ( )" }, { "title": "BOJ - 10815 - 숫자 카드", "url": "/posts/BOJ-10815/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, BinarySearch", "date": "2022-04-27 11:10:00 +0900", "snippet": "BOJ - 10815 - 숫자 카드문제10815번: 숫자 카드문제 개념문제 숫자 카드는 정수 하나가 적혀져 있는 카드이다. 상근이는 숫자 카드 N개를 가지고 있다. 정수 M개가 주어졌을 때, 이 수가 적혀있는 숫자 카드를 상근이가 가지고 있는지 아닌지를 구하는 프로그램을 작성하시오.입력 첫째 줄에 상근이가 가지고 있는 숫자 카드의 개수 N(1 ≤ N ≤ 500,000)이 주어진다. 둘째 줄에는 숫자 카드에 적혀있는 정수가 주어진다. 숫자 카드에 적혀있는 수는 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다. 두 숫자 카드에 같은 수가 적혀있는 경우는 없다. 수가 너무 크기에 string으로 받도록 한다. 셋째 줄에는 M(1 ≤ M ≤ 500,000)이 주어진다. 넷째 줄에는 상근이가 가지고 있는 숫자 카드인지 아닌지를 구해야 할 M개의 정수가 주어지며, 이 수는 공백으로 구분되어져 있다. 이 수도 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다이전 포스팅에서 풀어본 수 찾기 문제와 매우 유사하다.1920번: 수 찾기BOJ - 1920 - 수찾기구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;/* N개의 정수 A[1], A[2], …, A[N]이 주어져 있을 때,이 안에 X라는 정수가 존재하는지 알아내는 프로그램을 작성하시오.단모든 정수의 범위는 -231 보다 크거나 같고 231보다 작다. int로 받는것이 아닌 string으로 받도록 하자.*/int main(){ // 존재 기준 리스트 // 확인할 리스트 ios::sync_with_stdio(false); cin.tie(nullptr); int A_num, M_num; cin &amp;gt;&amp;gt; A_num; vector&amp;lt;string&amp;gt; A(A_num); for(int i=0; i &amp;lt; A_num; i++) cin &amp;gt;&amp;gt; A[i]; // 기준 리스트 오름차순 정렬 sort(A.begin(), A.end()); cin &amp;gt;&amp;gt; M_num; vector&amp;lt;int&amp;gt; answer; for(int i=0; i &amp;lt; M_num; i++) { string temp; cin &amp;gt;&amp;gt; temp; // 이진탐색을 통한 존재유무 탐색 때문에 오름차순 정렬이 필요. int index = lower_bound(A.begin(), A.end(), temp) - A.begin(); // 요소가 존재하면 if(temp == A[index]) answer.push_back(1); else answer.push_back(0); } for(auto el : answer) cout &amp;lt;&amp;lt; el &amp;lt;&amp;lt; &#39;\\n&#39;; return 0;}SOL string으로 요소를 받는다. 비교할 땐 이진탐색 기반인 lower_bound를 사용 lower_bound를 사용하기 위해 기준 리스트 오름차순 정렬 Reference &amp;amp; 다른 PS 모음집https://github.com/ggh-png/PSC++ STL lower_bound ( )" }, { "title": "BOJ - 1966 - 프린터 큐", "url": "/posts/BOJ-1966/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, queue", "date": "2022-04-26 11:10:00 +0900", "snippet": "BOJ - 1966 - 프린터 큐문제1966번: 프린터 큐문제 개념여러분도 알다시피 여러분의 프린터 기기는 여러분이 인쇄하고자 하는 문서를 인쇄 명령을 받은 ‘순서대로’, 즉 먼저 요청된 것을 먼저 인쇄한다. 여러 개의 문서가 쌓인다면 Queue 자료구조에 쌓여서 FIFO - First In First Out - 에 따라 인쇄가 되게 된다. 하지만 상근이는 새로운 프린터기 내부 소프트웨어를 개발하였는데, 이 프린터기는 다음과 같은 조건에 따라 인쇄를 하게 된다. 현재 Queue의 가장 앞에 있는 문서의 ‘중요도’를 확인한다. 나머지 문서들 중 현재 문서보다 중요도가 높은 문서가 하나라도 있다면, 이 문서를 인쇄하지 않고 Queue의 가장 뒤에 재배치 한다. 그렇지 않다면 바로 인쇄를 한다.예를 들어 Queue에 4개의 문서(A B C D)가 있고, 중요도가 2 1 4 3 라면 C를 인쇄하고, 다음으로 D를 인쇄하고 A, B를 인쇄하게 된다.여러분이 할 일은, 현재 Queue에 있는 문서의 수와 중요도가 주어졌을 때, 어떤 한 문서가 몇 번째로 인쇄되는지 알아내는 것이다. 예를 들어 위의 예에서 C문서는 1번째로, A문서는 3번째로 인쇄되게 된다.input 4 2 1 2 [3] 4work flow 1 2 [3] 4 2 [3] 4 1 [3] 4 1 2 4 1 2 [3] 4 2 [3] 1 4 [3] 2 1output 2구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;/*N테스트케이스의 첫 번째 줄에는 문서의 개수 N(1 ≤ N ≤ 100)M몇 번째로 인쇄되었는지 궁금한 문서가 현재 Queue에서 몇 번째에 놓여 있는지를 나타내는 정수 M(0 ≤ M &amp;lt; N)이 주어진다. output궁금 문서의 입쇄 번수input31 0 - N = 1, M = 0 5 output = 14 2 - N = 4, M = 21 2 [3] 4 output = 24 [3] 2 1 6 0 - N = 6, M = 01 1 9 1 1 1 output = 5workflow[A] B C D E FC D E F [A] B1 2 3 4 [5] 6output 1 2 5*/int a = 0;int main(){ int num; // test case int N; // list size int M; // 확인할 요소의 index 값 cin &amp;gt;&amp;gt; num; vector&amp;lt;int&amp;gt; answer; for(int i=0; i &amp;lt; num; i++) { cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M; vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; q; for(int j=0; j &amp;lt; N; j++) { int temp; cin &amp;gt;&amp;gt; temp; // 우선순위, 초기 순서 q.push_back(pair&amp;lt;int, int&amp;gt;(temp, j)); } /* work flow 1 2 3 4 2 3 4 1 3 4 1 2 4 1 2 3 4 2 3 1 4 3 2 1 */ for(int j=0; j &amp;lt; q.size(); j++) { for(int k=j; k &amp;lt; q.size(); k++) { // 보다 큰 수를 찾으면 if(q[j].first &amp;lt; q[k].first) { // j번째 값보다 큰수가 나올때 까지 pop후 맨 뒤 요소에 push for(int l=0; l &amp;lt; abs(k - j); l++) { // 확인을 하지 않은 앞 요소 저장 int fir = q[j].first; int sec = q[j].second; // 큐 pop q.erase(q.begin()+j); q.push_back(pair&amp;lt;int, int&amp;gt;(fir, sec)); // work flow 출력 // for(auto el : q) // cout &amp;lt;&amp;lt; el.first &amp;lt;&amp;lt; &quot; &quot;; // cout &amp;lt;&amp;lt; &quot;,&quot; &amp;lt;&amp;lt; k-j &amp;lt;&amp;lt; endl; } // j번 째 값보다 큰 수가 뒤에도 있을 경우를 대비하여 k값 초기화.. k = j; } } } // 문서의 출력순서 int count=0; for(int j=0; j &amp;lt; q.size(); j++) { if(q[j].second == M) { count++; answer.push_back(count); } else count++; } } //answer for(auto &amp;amp;el : answer) cout &amp;lt;&amp;lt; el &amp;lt;&amp;lt; &#39;\\n&#39;; return 0;}SOL 맨 앞 요소부터 오름차순으로 정렬하되 큐의 개념을 이용한다. work flow 1 2 [3] 4 2 [3] 4 1 [3] 4 1 2 4 1 2 [3] 0번째 index값을 리스트의 가장 큰 요소로 만들면 - 즉 오름차순이 된다면 다음 요소로 넘어감.. 4 2 [3] 1 4 [3] 2 1 Reference &amp;amp; 다른 PS 모음집https://github.com/ggh-png/PSSTACK &amp;amp; QUEUE" }, { "title": "BOJ - 1920 - 수찾기", "url": "/posts/BOJ-1920/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, BinarySearch", "date": "2022-04-26 11:10:00 +0900", "snippet": "BOJ - 1920 - 수찾기문제1920번: 수 찾기문제 개념 첫째 줄에 자연수 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 줄에는 N개의 정수 A[1], A[2], …, A[N]이 주어진다. 다음 줄에는 M(1 ≤ M ≤ 100,000)이 주어진다. 다음 줄에는 M개의 수들이 주어지는데, 이 수들이 A안에 존재하는지 알아내면 된다. 즉, M의 요소를 리스트 A에 있는지 유무를 판단하는 것 모든 정수의 범위는 -2^31 보다 크거나 같고 2^31 보다 작다. int로 받는것이 아닌 string으로 받아야 된다. 구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;/* N개의 정수 A[1], A[2], …, A[N]이 주어져 있을 때,이 안에 X라는 정수가 존재하는지 알아내는 프로그램을 작성하시오.단모든 정수의 범위는 -231 보다 크거나 같고 231보다 작다. int로 받는것이 아닌 string으로 받도록 하자.*/int main(){ // 존재 기준 리스트 // 확인할 리스트 ios::sync_with_stdio(false); cin.tie(nullptr); int A_num, M_num; cin &amp;gt;&amp;gt; A_num; vector&amp;lt;string&amp;gt; A(A_num); for(int i=0; i &amp;lt; A_num; i++) cin &amp;gt;&amp;gt; A[i]; // 기준 리스트 오름차순 정렬 sort(A.begin(), A.end()); cin &amp;gt;&amp;gt; M_num; vector&amp;lt;int&amp;gt; answer; for(int i=0; i &amp;lt; M_num; i++) { string temp; cin &amp;gt;&amp;gt; temp; // 이진탐색을 통한 존재유무 탐색 때문에 오름차순 정렬이 필요. int index = lower_bound(A.begin(), A.end(), temp) - A.begin(); // 요소가 존재하면 if(temp == A[index]) answer.push_back(1); else answer.push_back(0); } for(auto el : answer) cout &amp;lt;&amp;lt; el &amp;lt;&amp;lt; &#39;\\n&#39;; return 0;}SOL string으로 요소를 받는다. 비교할 땐 이진탐색 기반인 lower_bound를 사용 lower_bound를 사용하기 위해 기준 리스트 오름차순 정렬 Reference &amp;amp; 다른 PS 모음집https://github.com/ggh-png/PSC++ STL lower_bound ( )" }, { "title": "BOJ - 11866 - 요세푸스 문제 0", "url": "/posts/BOJ-11866/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, queue", "date": "2022-04-21 11:10:00 +0900", "snippet": "BOJ - 11866 - 요세푸스 문제 0문제11866번: 요세푸스 문제 0문제 개념 1번부터 N번까지 N명의 사람이 원을 이루면서 앉아있고, 양의 정수 K(≤ N)가 주어진다. 이제 순서대로 K번째 사람을 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다. 이 과정은 N명의 사람이 모두 제거될 때까지 계속된다. 원에서 사람들이 제거되는 순서를 (N, K)-요세푸스 순열이라고 한다. 예를 들어 (7, 3)-요세푸스 순열은 &amp;lt;3, 6, 2, 7, 5, 1, 4&amp;gt;이다. N과 K가 주어지면 (N, K)-요세푸스 순열을 구하는 프로그램을 작성하시오. 구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;/*work flow7 31 2 3 4 5 6 7 - 1 2 4 5 6 7 - 31 2 4 5 7 - 3 61 4 5 7 - 3 6 21 4 5 - 3 6 2 71 4 - 3 6 2 7 54 - 3 6 2 7 5 1- 3 6 2 7 5 1 4*/int main(){ ios_base :: sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int N, K; int idx=0; queue&amp;lt;int&amp;gt; q; queue&amp;lt;int&amp;gt; answer; cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; K; for(int i=1; i &amp;lt;= N; i++) q.push(i); while (!q.empty()) { for(int i=1; i &amp;lt; K; i++) { // k번째 자리까지 큐에 담기 int temp = q.front(); q.pop(); q.push(temp); } answer.push(q.front()); q.pop(); } cout &amp;lt;&amp;lt; &quot;&amp;lt;&quot;; while (!answer.empty()) { if(answer.size() == 1) cout &amp;lt;&amp;lt; answer.front() &amp;lt;&amp;lt; &quot;&amp;gt;&quot;; else cout &amp;lt;&amp;lt; answer.front() &amp;lt;&amp;lt; &quot;, &quot;; answer.pop(); }}SOL K번째 자리까지가 front일 때까지 front요소를 큐에 다시 삽입하기 for(int i=1; i &amp;lt; K; i++) { // k번째 자리까지 큐에 담기 int temp = q.front(); q.pop(); q.push(temp); } Reference &amp;amp; 다른 PS 모음집https://github.com/ggh-png/PSSTACK &amp;amp; QUEUE" }, { "title": "BOJ - 2164 - 카드2", "url": "/posts/BOJ-2164/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, queue", "date": "2022-04-20 11:10:00 +0900", "snippet": "BOJ - 2164 - 카드 2문제2164번: 카드2문제 개념 N장의 카드가 있다. 각각의 카드는 차례로 1부터 N까지의 번호가 붙어 있으며, 1번 카드가 제일 위에, N번 카드가 제일 아래인 상태로 순서대로 카드가 놓여 있다. [ 1 2 3 4 ] 이제 다음과 같은 동작을 카드가 한 장 남을 때까지 반복하게 된다. 우선, 제일 위에 있는 카드를 바닥에 버린다. 그 다음, 제일 위에 있는 카드를 제일 아래에 있는 카드 밑으로 옮긴다. [ 2 3 4 ] - pop [ 1 ] 예를 들어 N=4인 경우를 생각해 보자. 카드는 제일 위에서부터 1234 의 순서로 놓여있다. 1을 버리면 234가 남는다. 여기서 2를 제일 아래로 옮기면 342가 된다. 3을 버리면 42가 되고, 4를 밑으로 옮기면 24가 된다. 마지막으로 2를 버리고 나면, 남는 카드는 4가 된다. [ 3 4 2 ] - swap N이 주어졌을 때, 제일 마지막에 남게 되는 카드를 구하는 프로그램을 작성하시오.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std;/*하단의 요소를 삭제, 첫 요소와 끝 요소의 스왑 work flow1 2 3 42 3 43 4 24 2 2 44*/int main(){ ios_base :: sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int num; queue&amp;lt;int&amp;gt; q; cin &amp;gt;&amp;gt; num; for(int i=1; i &amp;lt;= num; i++) q.push(i); // 1 2 3 4 while (!(q.size() == 1)) { q.pop(); int temp = q.front(); q.pop(); q.push(temp); } cout &amp;lt;&amp;lt; q.front() &amp;lt;&amp;lt; &#39;\\n&#39;; return 0;}SOL 하단의 요소를 삭제, 첫 요소와 끝 요소의 스왑 while (!(q.size() == 1)) { // 첫 요소 삭제 q.pop(); // swap(begin, end) int temp = q.front(); q.pop(); q.push(temp); } Reference &amp;amp; 다른 PS 모음집https://github.com/ggh-png/PSSTACK &amp;amp; QUEUE" }, { "title": "BOJ - 18258 - 큐 2", "url": "/posts/BOJ-18258/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, queue", "date": "2022-04-20 11:10:00 +0900", "snippet": "BOJ - 18258 - 큐 2문제18258번: 큐 2문제 개념 첫째 줄에 주어지는 명령의 수 N (1 ≤ N ≤ 2,000,000)이 주어진다. 큐로 입력 받기 둘째 줄부터 N개의 줄에는 명령이 하나씩 주어진다. 주어지는 정수는 1보다 크거나 같고, 100,000보다 작거나 같다. 마찬가지 큐로 입력받기 구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;/* push X: 정수 X를 큐에 넣는 연산이다.pop: 큐에서 가장 앞에 있는 정수를 빼고, 그 수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다.size: 큐에 들어있는 정수의 개수를 출력한다.empty: 큐가 비어있으면 1, 아니면 0을 출력한다.front: 큐의 가장 앞에 있는 정수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다.back: 큐의 가장 뒤에 있는 정수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다.첫째 줄에 주어지는 명령의 수 N (1 ≤ N ≤ 2,000,000)이 주어진다. ()둘째 줄부터 N개의 줄에는 명령이 하나씩 주어진다. 주어지는 정수는 1보다 크거나 같고, 100,000보다 작거나 같다.문제에 나와있지 않은 명령이 주어지는 경우는 없다.*/int main(){ ios_base :: sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int num; cin &amp;gt;&amp;gt; num; queue&amp;lt;int&amp;gt; q; queue&amp;lt;int&amp;gt; answer; for(int i=0; i &amp;lt; num; i++) { string temp; cin &amp;gt;&amp;gt; temp; if(temp == &quot;push&quot;) { int tmp; cin &amp;gt;&amp;gt; tmp; q.push(tmp); } else if(temp == &quot;pop&quot;) { if(q.empty()) answer.push(-1); else { answer.push(q.front()); q.pop(); } } else if(temp == &quot;size&quot;) answer.push(q.size()); else if(temp == &quot;empty&quot;) answer.push(q.empty()); else if(temp == &quot;front&quot;) { if(q.empty()) answer.push(-1); else answer.push(q.front()); } else if(temp == &quot;back&quot;) { if(q.empty()) answer.push(-1); else answer.push(q.back()); } } // 출력 while (!answer.empty()) { cout &amp;lt;&amp;lt; answer.front() &amp;lt;&amp;lt; &#39;\\n&#39;; answer.pop(); } return 0;}SOL 큐의 명령을 수행할 큐 queue q 명령을 수행한 결과 값을 저장할 큐 queue answer Reference &amp;amp; 다른 PS 모음집https://github.com/ggh-png/PSSTACK &amp;amp; QUEUE" }, { "title": "프로그래머스 - level_2 - 기능개발", "url": "/posts/programmers-stack1/", "categories": "PS, 프로그래머스", "tags": "C++, PS, 프로그래머스, stack", "date": "2022-04-19 11:30:00 +0900", "snippet": "프로그래머스 - level_2 - 기능개발문제코딩테스트 연습 - 기능개발문제 개념 프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다. progresses [ 95, 90, 99, 99, 80, 99 ] - 진도 speeds [ 1, 1, 1, 1, 1, 1 ] - 개발속도 progresses[0] = 95, speed[0] = 1 일때 서비스 반영까지 5일 소요. 또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다. 서비스 반영 소요일을 day라고 할 때 day[ 5, 10, 1, 1, 20, 1 ] 이며 앞에 있는 기능보다 먼저 개발될 경우 함께 배포되어 소요일은 [ 5, 10, 20 ]일이 걸린다. 먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요. 따라서 소요일당 배포된 기능의 개수를 구하면 5일째 - 1개 배포 10일째 - 3개 배포 20일재 - 2개 배포 즉 answer[ 1, 3, 2]인 것이다. 구현#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;iostream&amp;gt;using namespace std;vector&amp;lt;int&amp;gt; solution(vector&amp;lt;int&amp;gt; progresses, vector&amp;lt;int&amp;gt; speeds) { vector&amp;lt;int&amp;gt; day(progresses.size(), 0); vector&amp;lt;int&amp;gt; answer; stack&amp;lt;int&amp;gt; s; // 소요일 for(int i=0; i &amp;lt; progresses.size(); i++) { // 작업이 완료가 될 때 까지 int days=0; while (!(progresses[i] &amp;gt;= 100)) { progresses[i] += speeds[i]; day[i]++; } } int tmp=0; int max = day[0]; for(int i=0; i &amp;lt; day.size(); i++) { // stack이 비어있거나 과거 &amp;gt;= 현재일 경우 if(s.empty() || max &amp;gt;= day[i]) { // stack에 push s.push(day[i]); // 마지막일 경우 pop and answer push if(i == day.size()-1) { while (!s.empty()) { s.pop(); tmp++; } answer.push_back(tmp); } } // stack이 비어있지 않고, 과거 &amp;lt; 현재일 경우 else { // maxDay init max = day[i]; // stack pop while (!s.empty()) { s.pop(); tmp++; } answer.push_back(tmp); // 현재 값 push s.push(day[i]); // tmp zero init tmp = 0; // 마지막일 경우 pop and answer push if(i == day.size()-1) { while (!s.empty()) { s.pop(); tmp++; } answer.push_back(tmp); } } } return answer;}SOL 소요일 탐색 for(int i=0; i &amp;lt; progresses.size(); i++) { // 작업이 완료가 될 때 까지 int days=0; while (!(progresses[i] &amp;gt;= 100)) { progresses[i] += speeds[i]; day[i]++; } } 앞에 있는 기능보다 먼저 개발될 경우 함께 배포. if(s.empty() || max &amp;gt;= day[i]) { // stack에 push s.push(day[i]); // 마지막일 경우 pop and answer push if(i == day.size()-1) { while (!s.empty()) { s.pop(); tmp++; } answer.push_back(tmp); } } 반례 else { // maxDay init max = day[i]; // stack pop while (!s.empty()) { s.pop(); tmp++; } answer.push_back(tmp); // 현재 값 push s.push(day[i]); // tmp zero init tmp = 0; // 마지막일 경우 pop and answer push if(i == day.size()-1) { while (!s.empty()) { s.pop(); tmp++; } answer.push_back(tmp); } } 구현 - 짤막코드..#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;iostream&amp;gt;using namespace std;vector&amp;lt;int&amp;gt; solution(vector&amp;lt;int&amp;gt; progresses, vector&amp;lt;int&amp;gt; speeds) { vector&amp;lt;int&amp;gt; answer; int day; int max_day = 0; for (int i = 0; i &amp;lt; progresses.size(); ++i) { day = (99 - progresses[i]) / speeds[i] + 1; if (answer.empty() || max_day &amp;lt; day) answer.push_back(1); // 앞에 있는 기능보다 먼저 개발될 경우 함께 배포. else ++answer.back(); if (max_day &amp;lt; day) max_day = day; } return answer;}Reference &amp;amp; 다른 PS 모음집https://github.com/ggh-png/PSSTACK &amp;amp; QUEUE" }, { "title": "ect - 일상 - 생프(창문 가방걸이)", "url": "/posts/ect-3dprinting/", "categories": "ect, 3DPrint", "tags": "ect, 3DPrint", "date": "2022-04-14 11:10:00 +0900", "snippet": "생프 - 창문 가방걸이항상 퇴근을 하고 집에 있을 때 항상 저 갈곳을 잃은 가방이 신경이 쓰였다. 따로 사면 되지만…. 집에 놀고있는 프린터도 있기에 겸사겸사.. 대충 눈대중으로 슉~ 피처를 슈슉.. 슬라이싱을 슉 슈슉…!! 출력! 끗.." }, { "title": "BOJ - 17298 - 오큰수", "url": "/posts/BOJ-17298/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, stack", "date": "2022-04-14 11:10:00 +0900", "snippet": "BOJ - 17298 - 오큰수문제17298번: 오큰수문제 개념 크기가 N인 수열 A = A1, A2, …, AN이 있다. 수열의 각 원소 Ai에 대해서 오큰수 NGE(i)를 구하려고 한다. Ai의 오큰수는 오른쪽에 있으면서 Ai보다 큰 수 중에서 가장 왼쪽에 있는 수를 의미한다. 그러한 수가 없는 경우에 오큰수는 -1이다. 예를 들어, A = [3, 5, 2, 7]인 경우 NGE(1) = 5, NGE(2) = 7, NGE(3) = 7, NGE(4) = -1이다. A = [9, 5, 4, 8]인 경우에는 NGE(1) = -1, NGE(2) = 8, NGE(3) = 8, NGE(4) = -1이다. 입력 [ 3 5 2 7 ] 출력 [ 5 7 7 -1 ] 구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;stack&amp;gt;using namespace std;// 오큰수가 의미하는 것 // NGE[1] ... 배열의 첫번째 인덱스의 오큰수를 의미함 // 즉, 배열의 첫번째 인덱스 값에 존재하는 요소보다 큰 가장 왼쪽의 요소를 의미함. // 정답 백터int main(){ ios_base :: sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int num; cin &amp;gt;&amp;gt; num; int OrderList[num]; // 입력값 저장 int answer[num]; // 출력값 저장 stack&amp;lt;int&amp;gt; TmpStack; for(int i=0; i &amp;lt; num; i++) cin &amp;gt;&amp;gt; OrderList[i]; for(int i=num-1; i &amp;gt;= 0; i--) { // 3 5 2 7 while (!TmpStack.empty() &amp;amp;&amp;amp; TmpStack.top() &amp;lt;= OrderList[i]) TmpStack.pop(); if(TmpStack.empty()) answer[i] = -1; else answer[i] = TmpStack.top();// -1 7 7 5 TmpStack.push(OrderList[i]); // 7 5 3 } for(auto &amp;amp;el : answer) cout &amp;lt;&amp;lt; el &amp;lt;&amp;lt; &quot; &quot;; cout &amp;lt;&amp;lt; endl;}SOL 입력된 수열을 배열로 받는다. for(int i=0; i &amp;lt; num; i++) cin &amp;gt;&amp;gt; OrderList[i]; 배열로 입력받은 수열의 끝부터 역순으로 하나씩 임시 스택에 넣는다. 역순으로 받아야 스택의 pop, push를 적절하게 사용할 수 있기 때문. TmpStack.push(OrderList[i]) 임시스택이 비어있지 않고, 임시스택의 top값과 역순의 입력 값을 비교 하였을 때 역순의 입력값이 크면 임시스택 … pop 임시스택이 비었으면 … (처음 루프문을 돌 경우에도 적용) answer[i] = -1; 임시스택이 비어있지 않으면 answer[i] = TmpStack.top() for(int i=num-1; i &amp;gt;= 0; i--) { // 임시스택이 비어있지 않고, 오큰수값 TmpStack.top()이 나올때 까지 while (!TmpStack.empty() &amp;amp;&amp;amp; TmpStack.top() &amp;lt;= OrderList[i]) TmpStack.pop(); if(TmpStack.empty()) answer[i] = -1; else answer[i] = TmpStack.top();// -1 7 7 5 TmpStack.push(OrderList[i]); // 7 5 3 } Work flown = 4임의의 수열 : [ 3 5 2 7 ]i = 0TmpStack [ ]OrderList [ 7 ]TmpStack.empty()answer[ i ] = -1TmpStack.push( 7 )i = 1TmpStack[ 7 ]OrderList [ 2 ]! TmpStack.empty()! TmpStack[ 7 ] ≤ OrderList[ 2 ]answer[ i ] = TmpStack[ 7 ]TmpStack.push( 2 );i = 2TmpStack[ 7 2 ]…알게된 점 스택문제는 스택으로 푸는 이유가 있다..Reference &amp;amp; 다른 PS 모음집https://github.com/ggh-png/PSSTACK &amp;amp; QUEUE" }, { "title": "BOJ - 1874 - 스택 수열", "url": "/posts/BOJ-1874/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, stack", "date": "2022-04-12 11:10:00 +0900", "snippet": "BOJ - 1874 - 스택 수열문제1874번: 스택 수열문제 개념 1부터 n까지의 수를 스택에 넣었다가 뽑아 늘어놓음으로써, 하나의 수열을 만들 수 있다. n = 8 기준 수열 : [ 1 2 3 4 5 6 7 8 ] 스택에 push하는 순서는 반드시 오름차순을 지킨다. 엇갈리면 안된다. 임의의 수열이 주어졌을 때 스택을 이용해 그 수열을 만들 수 있는지 없는지, 있다면 어떤 순서로 push와 pop 연산을 수행해야 하는지를 알아낼 수 있다. 임의의 수열 : [ 4 3 6 8 7 5 2 1 ] 계산결과 : + + + +, - -, + +, -, + +, - - - - - 구현 - vector 사용#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;stack&amp;gt;using namespace std; int main(){ int num; vector&amp;lt;int&amp;gt; OrderStack; // 입력스택 vector&amp;lt;int&amp;gt; NumQueue; // 기준 큐 stack&amp;lt;int&amp;gt; TmpStack; // 임시스택 vector&amp;lt;string&amp;gt; answer; // 정답스택 cin &amp;gt;&amp;gt; num; for(int i=1; i &amp;lt;= num; i++) { int tmp; cin &amp;gt;&amp;gt; tmp; // 4 3 6 8 7 5 2 1 OrderStack.push_back(tmp); // 1 2 3 4 5 6 7 8 NumQueue.push_back(i); } for(int i=0; i &amp;lt; OrderStack.size(); i++) { while(1) { // 스택의 상단과 인풋값이 맞을때 까지 if(TmpStack.empty() || TmpStack.top() != OrderStack[i]) { TmpStack.push(NumQueue[0]); if(!NumQueue.empty()) NumQueue.erase(NumQueue.begin()); else break; answer.push_back(&quot;+&quot;); } else if(TmpStack.top() == OrderStack[i]) { TmpStack.pop(); answer.push_back(&quot;-&quot;); break; } } } if(!TmpStack.empty()) { answer.clear(); answer.push_back(&quot;NO&quot;); } for(auto el : answer) cout &amp;lt;&amp;lt; el &amp;lt;&amp;lt; &#39;\\n&#39;; }구현 - stack queue lib 사용#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std; // 입력 저장 스택 // 기본 N까지의 수열스택// 임시로 담아둘 스택 // 정답에 입력할 스택 int main(){ int num; queue&amp;lt;int&amp;gt; OrderQueue; // 입력 큐 queue&amp;lt;int&amp;gt; NumQueue; // 기준 큐 stack&amp;lt;int&amp;gt; TmpStack; // 임시스택 vector&amp;lt;string&amp;gt; answer; // 정답스택 // 수열 스택 입력 cin &amp;gt;&amp;gt; num; for(int i=1; i &amp;lt;= num; i++) { int tmp; cin &amp;gt;&amp;gt; tmp; // 4 3 6 8 7 5 2 1 OrderQueue.push(tmp); // 1 2 3 4 5 6 7 8 NumQueue.push(i); } for(int i=0; i &amp;lt; num; i++) { while(!OrderQueue.empty()) { // 임시스택이 비어있을경우나 스택의 상단과 인풋값이 맞을때 까지 if(TmpStack.empty() || TmpStack.top() != OrderQueue.front()) { // TmpStack : 1 2 3 4 TmpStack.push(NumQueue.front()); // NumQueue : 5 6 7 8 if(!NumQueue.empty()) NumQueue.pop(); else break; answer.push_back(&quot;+&quot;); } else if(TmpStack.top() == OrderQueue.front()) { // TmpStack : 1 2 3 [4].. pop TmpStack.pop(); answer.push_back(&quot;-&quot;); OrderQueue.pop(); break; } } } if(!TmpStack.empty()) { answer.clear(); answer.push_back(&quot;NO&quot;); } for(auto el : answer) cout &amp;lt;&amp;lt; el &amp;lt;&amp;lt; &#39;\\n&#39;; }결과SOL 입력큐에 임의의 수열 입력 &amp;amp; 기준 큐 생성 입력 큐 : [ 4 3 6 8 7 5 2 1 ] 기준 큐 : [ 1 2 3 4 5 6 7 8 ] 임시스택의 top 입력큐의 front 값과 다르면 같을 때 까지 기준큐 pop &amp;amp; 임시 스택에 기준 큐 값 push 정답 스택 입력 … ‘ + ’ 임시스택의 top 입력큐의 front 값과 같으면 다를 때 까지 임시스택 pop &amp;amp; 입력 큐 pop 정답 스택 입력 … ‘ - ‘ 즉. ‘ - ‘ 는 임의의 수열의 원소가 처리 되었다는 뜻 ! Work flown = 8임의의 수열 : [ 4 3 6 8 7 5 2 1 ]기준 수열 : [ 1 2 3 4 5 6 7 8 ]임시 수열 : [ ] 임의의 수열의 원소 [ 4 ] 기준 수열 : [ 5 6 7 8 ] … 1 2 3 4 pop - queue 계산결과 ‘ + + + + ’ 임시 수열 : [ 1 2 3 4 ] … 1 2 3 4 push - stack 임의의 수열의 원소 [ 4 ]와 임시수열 top 값과 같음. 임시수열 : [ 1 2 3 ] … 4 pop - stack 계산결과 ‘ - ’ 알게된 점 vector로 stack이나 queue를 구현하는 것 보다 라이브러리를 이용하는게 훨씬 계산 속도가 빠르다.Reference &amp;amp; 다른 PS 모음집https://github.com/ggh-png/PSSTACK &amp;amp; QUEUE" }, { "title": "BOJ - 4949 - 균형잡힌 세상", "url": "/posts/BOJ-4949/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, stack", "date": "2022-04-11 11:10:00 +0900", "snippet": "BOJ - 4949 - 균형잡힌 세상문제4949번: 균형잡힌 세상문제 개념 모든 왼쪽 소괄호(“(“)는 오른쪽 소괄호(“)”)와만 짝을 이뤄야 한다. 모든 왼쪽 대괄호(“[“)는 오른쪽 대괄호(“]”)와만 짝을 이뤄야 한다. 모든 오른쪽 괄호들은 자신과 짝을 이룰 수 있는 왼쪽 괄호가 존재한다. 모든 괄호들의 짝은 1:1 매칭만 가능하다. 즉, 괄호 하나가 둘 이상의 괄호와 짝지어지지 않는다. 짝을 이루는 두 괄호가 있을 때, 그 사이에 있는 문자열도 균형이 잡혀야 한다. 즉. 올바른 VPS 괄호 여닫이여야만 한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;// 입력 : 공백이 있는 문자열 ... 오로지 &#39;.&#39;만이 문자열의 끝을 알림. // (), []만이 존재함. // ( or [ 둘이 ([)] 인 경우 어떻게 처리할까..? // ()[ || ([) 를 어캐 구분할까 int main(){ vector&amp;lt;string&amp;gt; answer; // output string str; answer.clear(); while (1) { // 문자열 입력 getline(cin, str); // stack init vector&amp;lt;char&amp;gt; VectorStack; if(str[0] == &#39;.&#39;) break; // 판별 () for(int i=0; i &amp;lt; str.size(); i++) { // 괄호를 입력 받으면 // 시작 괄호면 스택쌓기 if(str[i] == &#39;(&#39;) VectorStack.push_back(&#39;(&#39;); if(str[i] == &#39;[&#39;) VectorStack.push_back(&#39;[&#39;); if(str[i] == &#39;)&#39;) { // 스택이 비어있지 않고 스택의 최 상단에 시작괄호가 있다면 스택제거 // () 인 경우 : 빈 스택으로 만듬 if(!VectorStack.empty() &amp;amp;&amp;amp; *(VectorStack.end()-1) == &#39;(&#39;) VectorStack.pop_back(); // 빈 스택에 닫는괄호가 들어오면 no // ) 인 경우 : no else{ answer.push_back(&quot;no&quot;); break; } } if(str[i] == &#39;]&#39;) { // 스택이 비어있지 않고 스택의 최 상단에 시작괄호가 있다면 스택제거 // [] 인 경우 : 빈 스택으로 만듬 if(!VectorStack.empty() &amp;amp;&amp;amp; *(VectorStack.end()-1) == &#39;[&#39;) VectorStack.pop_back(); // 빈 스택에 닫는괄호가 들어오면 no // ) 인 경우 : no else{ answer.push_back(&quot;no&quot;); break; } } // 스택이 비어있고 .이 나오기 전까지 입력된 문자열을 확인했을 경우 if (VectorStack.empty() &amp;amp;&amp;amp; i == str.length() - 2) answer.push_back(&quot;yes&quot;); // 스택이 비어있지 않고 입력된 문자열을 확인했을 경우 else if (!VectorStack.empty() &amp;amp;&amp;amp; i == str.length() - 2) answer.push_back(&quot;no&quot;); } } for(auto el : answer) cout &amp;lt;&amp;lt; el &amp;lt;&amp;lt; &#39;\\n&#39;; }SOL 스택 구조의 조건을 만들어 VPS를 판단한다.짤막한 회고 스스로 푼 코드가 아니라.. 마음이 아프다.. 한 문제를 가지고 끝까지 물고 늘어지는게 맞을까.. 일정시간을 정해두고 서칭을 하며 푸는게 맞을까…(이번문제는 서칭해서 품 !)Reference &amp;amp; 다른 PS 모음집https://github.com/ggh-png/PS[C/C++] 백준 4949번 균형잡힌 세상(Stack)" }, { "title": "BOJ - 9012 - 괄호", "url": "/posts/BOJ-9012/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, stack", "date": "2022-04-10 11:10:00 +0900", "snippet": "BOJ - 9012 - 괄호문제9012번: 괄호문제 개념 입력 데이터는 표준 입력을 사용한다. 입력은 T개의 테스트 데이터로 주어진다. 입력의 첫 번째 줄에는 입력 데이터의 수를 나타내는 정수 T가 주어진다. 각 테스트 데이터의 첫째 줄에는 괄호 문자열이 한 줄에 주어진다. 하나의 괄호 문자열의 길이는 2 이상 50 이하이다. 즉. 올바른 VPS 괄호 여닫이여야만 한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;// (( )) (( ))// 왼 오른의 비율을 따져 결과값 표츌 int main(){ int num; vector&amp;lt;string&amp;gt; OrderList; // input vector&amp;lt;string&amp;gt; answer; // output cin &amp;gt;&amp;gt; num; for(int i=0; i &amp;lt; num; i++) { string temp; cin &amp;gt;&amp;gt; temp; OrderList.push_back(temp); } for(int i=0; i &amp;lt; OrderList.size(); i++) { int tmp = 0; for(int j=0; j &amp;lt; OrderList[i].size(); j++) { tmp += OrderList[i][j] == &#39;(&#39; ? 1 : -1; if(tmp &amp;lt; 0) break; } string result = tmp == 0 ? &quot;YES&quot; : &quot;NO&quot;; answer.push_back(result); } for(auto el : answer) cout &amp;lt;&amp;lt; el &amp;lt;&amp;lt; endl; }SOL 스택 구조의 조건을 만들어 VPS를 판단한다. tmp += OrderList[i][j] == &#39;(&#39; ? 1 : -1; 단. ‘ ) ‘의 수 즉 tmp &amp;lt; 0 이면 조건문을 멈춰 VPS가 아님을 알린다. Reference &amp;amp; 다른 PS 모음집https://github.com/ggh-png/PS" }, { "title": "BOJ - 10773 - 제로", "url": "/posts/BOJ-10773/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, stack", "date": "2022-04-09 11:10:00 +0900", "snippet": "BOJ - 10773 - 제로문제10773번: 제로문제 개념 첫 번째 줄에 정수 K가 주어진다. (1 ≤ K ≤ 100,000) 이후 K개의 줄에 정수가 1개씩 주어진다. 정수는 0에서 1,000,000 사이의 값을 가지며, 정수가 “0” 일 경우에는 가장 최근에 쓴 수를 지우고, 아닐 경우 해당 수를 쓴다. 정수가 “0”일 경우에 지울 수 있는 수가 있음을 보장할 수 있다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;// 0이 들어오면 최근에 입력한 수를 지운다. // answer은 스택에 쌇인 수를 모두 더한 것이다. int main(){ vector&amp;lt;int&amp;gt; VectorStack; int num; int answer = 0; cin &amp;gt;&amp;gt; num; for(int i=0; i &amp;lt; num; i++) { int temp; cin &amp;gt;&amp;gt; temp; if(temp == 0) VectorStack.pop_back(); else VectorStack.push_back(temp); } for(auto el : VectorStack) answer += el; cout &amp;lt;&amp;lt; answer &amp;lt;&amp;lt; endl; return 0;}SOL 입력을 받을 때 0인지 구분 조건에 따라 push &amp;amp; popReference &amp;amp; 다른 PS 모음집https://github.com/ggh-png/PS" }, { "title": "BOJ - 10828 - 스택", "url": "/posts/BOJ-10828/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, stack", "date": "2022-04-08 11:10:00 +0900", "snippet": "BOJ - 10828 - 스택문제10828번: 스택문제 개념 push X: 정수 X를 스택에 넣는 연산이다. pop: 스택에서 가장 위에 있는 정수를 빼고, 그 수를 출력한다. 만약 스택에 들어있는 정수가 없는 경우에는 -1을 출력한다. size: 스택에 들어있는 정수의 개수를 출력한다. empty: 스택이 비어있으면 1, 아니면 0을 출력한다. top: 스택의 가장 위에 있는 정수를 출력한다. 만약 스택에 들어있는 정수가 없는 경우에는 -1을 출력한다.구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;stack&amp;gt;using namespace std; //선입 선출 int main(){ vector&amp;lt;int&amp;gt; VectorStack; vector&amp;lt;int&amp;gt; answer; vector&amp;lt;string&amp;gt; OrderList; int num; cin &amp;gt;&amp;gt; num; for(int i=0; i &amp;lt; num; i++) { string temp; cin &amp;gt;&amp;gt; temp; if(temp == &quot;push&quot;) ++num; OrderList.push_back(temp); } for(int i=0; i &amp;lt; OrderList.size(); i++) { if(OrderList[i] == &quot;push&quot;) { VectorStack.push_back(stoi(OrderList[i+1])); } else if(OrderList[i] == &quot;pop&quot;) { if(VectorStack.empty()) answer.push_back(-1); else { answer.push_back(*(VectorStack.end() - 1)); VectorStack.pop_back(); } } else if(OrderList[i] == &quot;size&quot;) answer.push_back(VectorStack.size()); else if(OrderList[i] == &quot;empty&quot;) { if(VectorStack.empty()) answer.push_back(1); else answer.push_back(0); } else if(OrderList[i] == &quot;top&quot;) { if(VectorStack.empty()) answer.push_back(-1); else { int tmp = *(VectorStack.end() - 1); answer.push_back(tmp); } } else continue; } for(auto el : answer) cout &amp;lt;&amp;lt; el &amp;lt;&amp;lt; endl; return 0;}SOL 입력받은 명령어들을 OrderList에 저장 for문을 통해 각각의 명령어에 맞게 임무수행 임무수행 후 answer에 push_backReference &amp;amp; 다른 PS 모음집https://github.com/ggh-png/PS" }, { "title": "STACK &amp; QUEUE", "url": "/posts/queue-stack/", "categories": "algorithm, 자료구조", "tags": "algorithm, stack, queue", "date": "2022-04-07 11:10:00 +0900", "snippet": "STACK &amp;amp; QUEUE개yo이번 포스팅에선 컴퓨터 프로그램의 가장 기초가 되는 자료구조인 스택(stack)과 큐(queue)에 대해 알아보도록 하겠다.스택(stack) 스택(stack) 이것만 기억하자 ~&amp;gt; 택배의 상하차 - 선입 후출스택(stack)을 단순히 표현하자면 택배의 상하차와 같다고 볼 수 있는데 그 이유는 스택의 선입 후출이란 특징 때문이다.특징 선입 빈 리스트 [ ]에 임의의 요소 값(3, 1, 4, 1, 5, 9, 2) 추가. [ 3 ] .. [ 3, 1 ] .. [ 3, 1, 4] ……. [ 3, 1, 4, 1, 5, 9, 2 ] 후출 요소 값이 들어있는 리스트 [ 3, 1, 4, 1, 5, 9, 2 ]에서 마지막으로 들어온 요소를 1개씩 제거 [ 3, 1, 4, 1, 5, 9, 2 ] .. [ 3, 1, 4, 1, 5, 9 ] .. [ 3, 1, 4, 1, 5 ] …… [ ] stack 구현 - stl stack#include&amp;lt;iostream&amp;gt;#include&amp;lt;stack&amp;gt;using namespace std; int main(){ stack&amp;lt;int&amp;gt; Stack_List; // 선입 Stack_List.push(3); Stack_List.push(1); Stack_List.push(4); // 후출 Stack_List.pop(); Stack_List.push(1); Stack_List.push(5); // 후출 Stack_List.pop(); Stack_List.push(9); Stack_List.push(2); while (!Stack_List.empty()) { cout &amp;lt;&amp;lt; Stack_List.top() &amp;lt;&amp;lt; &quot; &quot;; Stack_List.pop(); } }stack 구현 - stl vector#include&amp;lt;iostream&amp;gt;#include&amp;lt;vector&amp;gt;using namespace std; int main(){ vector&amp;lt;int&amp;gt; VectorStack; // 선입 VectorStack.push_back(3); VectorStack.push_back(1); VectorStack.push_back(4); // 후출 VectorStack.pop_back(); VectorStack.push_back(1); VectorStack.push_back(5); // 후출 VectorStack.pop_back(); VectorStack.push_back(9); VectorStack.push_back(2); // 후출 VectorStack.pop_back(); for(int i = VectorStack.size(); i &amp;gt;= 0; i--) cout &amp;lt;&amp;lt; VectorStack[i] &amp;lt;&amp;lt; &quot; &quot;; }출력2 9 1 1 3Work Flow [ 3, 1, 4 ] push [ 3, 1 ] - [ 4 ] pop [ 3, 1, 1, 5 ] - [ 1, 5 ] push [ 3, 1, 1 ] - [ 5 ] pop [ 3, 1, 1, 9, 2 ] - [ 9, 2 ] push큐(queue) 큐(queue) 이것만 기억하자 ~&amp;gt; 은행 창구 - 선입 선출스택과 다르게 큐(queue)는 선입 후출의 형태가 아닌 은행 창구과 같이 선입 선출의 구조를 띄고 있다.특징 선입 빈 리스트 [ ]에 임의의 요소 값(3, 1, 4, 1, 5, 9, 2) 추가. [ 3 ] .. [ 3, 1 ] .. [ 3, 1, 4] ……. [ 3, 1, 4, 1, 5, 9, 2 ] 선출 요소 값이 들어있는 리스트 [ 3, 1, 4, 1, 5, 9, 2 ]에서 먼저 들어온 요소를 1개씩 제거 [ 1, 4, 1, 5, 9, 2 ] .. [ 4, 1, 5, 9, 2 ] .. [ 1, 5, 9, 2 ] …… [ ] Queue 구현 - stl queue#include&amp;lt;iostream&amp;gt;#include&amp;lt;queue&amp;gt;using namespace std; int main(){ queue&amp;lt;int&amp;gt; Queue_List; // 선입 Queue_List.push(3); Queue_List.push(1); Queue_List.push(4); // 선출 Queue_List.pop(); Queue_List.push(1); Queue_List.push(5); // 선출 Queue_List.pop(); Queue_List.push(9); Queue_List.push(2); while (!Queue_List.empty()) { cout &amp;lt;&amp;lt; Queue_List.front() &amp;lt;&amp;lt; &quot; &quot;; Queue_List.pop(); } return 0;}Queue 구현 - stl vector#include&amp;lt;iostream&amp;gt;#include&amp;lt;vector&amp;gt;using namespace std; int main(){ vector&amp;lt;int&amp;gt; VectorQueue; // 선입 VectorQueue.push_back(3); VectorQueue.push_back(1); VectorQueue.push_back(4); // 선출 VectorQueue.erase(VectorQueue.begin()); VectorQueue.push_back(1); VectorQueue.push_back(5); // 선출 VectorQueue.erase(VectorQueue.begin()); VectorQueue.push_back(9); VectorQueue.push_back(2); for(auto el : VectorQueue) cout &amp;lt;&amp;lt; el &amp;lt;&amp;lt; &quot; &quot;; cout &amp;lt;&amp;lt; endl; }출력4 1 5 9 2Work Flow [ 3, 1, 4 ] push [ 1 , 4] - [ 3 ] pop [ 1, 4, 1, 5] - [ 1, 5 ] push [ 4, 1, 5 ] - [ 1 ] pop [ 4, 1, 5, 9, 2 ] - [ 9, 2 ] pushReference14. 큐(Queue)" }, { "title": "BOJ - 2108 - 통계학", "url": "/posts/BOJ-2108/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, 정렬", "date": "2022-04-05 11:10:00 +0900", "snippet": "BOJ - 2108 - 통계학문제2108번: 통계학문제 개념 산술평균 : N개의 수들의 합을 N으로 나눈 값 나눈값에 반올림 함. 중앙값 : N개의 수들을 증가하는 순서로 나열했을 경우 그 중앙에 위치하는 값 최빈값 : N개의 수들 중 가장 많이 나타나는 값 여려개일 경우 최빈값 중 2번째로 작은 값을 최빈값으로 지정 범위 : N개의 수들 중 최댓값과 최솟값의 차이구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;math.h&amp;gt;using namespace std;int main(){ ios::sync_with_stdio(false); cin.tie(nullptr); int num, tmp; // 평균 double mean = 0; // 중앙, 최빈, 범위 int median, mode, range; vector&amp;lt;int&amp;gt; arr; vector&amp;lt;int&amp;gt; count(8001, 0); cin &amp;gt;&amp;gt; num; for(int i=0; i &amp;lt; num; i++) { cin &amp;gt;&amp;gt; tmp; arr.push_back(tmp); count[tmp + 4000] += 1; mean += tmp; } // 산술평균 mean = floor(mean/num + 0.5); // 중앙 값 sort(arr.begin(), arr.end()); median = arr[num/2]; // 범위 값 range = arr.back() - arr.front(); // 최빈값 int max = -999999; vector&amp;lt;int&amp;gt; temp; for(int i=0; i &amp;lt; count.size(); i++) if(count[i] &amp;gt; max) max = count[i]; for(int i=0; i &amp;lt; count.size(); i++) if(count[i] == max) temp.push_back(i - 4000); // 최빈값이 하나일 경우 if(temp.size() == 1) mode = temp[0]; // 여러개일 경우 // 최빈값 중 두번째로 작은 값을 최빈값으로 지정 else { sort(temp.begin(), temp.end()); temp.erase(unique(temp.begin(), temp.end()), temp.end()); mode = temp[1]; } cout &amp;lt;&amp;lt; mean &amp;lt;&amp;lt; &#39;\\n&#39;; cout &amp;lt;&amp;lt; median &amp;lt;&amp;lt; &#39;\\n&#39;; cout &amp;lt;&amp;lt; mode &amp;lt;&amp;lt; &#39;\\n&#39;; cout &amp;lt;&amp;lt; range &amp;lt;&amp;lt; &#39;\\n&#39;; return 0;}SOL 첫째 줄에 수의 개수 N(1 ≤ N ≤ 500,000)이 주어진다. 단, N은 홀수이다. 그 다음 N개의 줄에는 정수들이 주어진다. 입력되는 정수의 절댓값은 4,000을 넘지 않는다. 산술평균 요소값을 입력받음과 동시에 더한 후 N값으로 나눈다.(반올림 : std::floor 사용) // 산술평균 mean = floor(mean/num + 0.5); 중앙값 정렬 후 N/2의 인덱스 요소 값을 저장 // 중앙값 sort(arr.begin(), arr.end()); median = arr[num/2]; 범위 정렬된 배열의 첫단과 끝 단의 요소값을 뺀다. // 범위값 range = arr.back() - arr.front(); 최빈값 최빈값 즉 가장 많이 나타내는 값 max을 구한다. 최빈값을 담는 배열을 만들어 저장. 최빈값이 하나일 경우 0번째 index값 저장. 여러개일 경우 정렬 - 중복제거 - 1번째 index값 저장. int max = -999999; vector&amp;lt;int&amp;gt; temp; for(int i=0; i &amp;lt; count.size(); i++) if(count[i] &amp;gt; max) max = count[i]; for(int i=0; i &amp;lt; count.size(); i++) if(count[i] == max) temp.push_back(i - 4000); // 최빈값이 하나일 경우 if(temp.size() == 1) mode = temp[0]; // 여러개일 경우 // 최빈값 중 두번째로 작은 값을 최빈값으로 지정 else { sort(temp.begin(), temp.end()); temp.erase(unique(temp.begin(), temp.end()), temp.end()); mode = temp[1]; } 시간복잡도 O(N log N) 반올림을 구해주는 함수 floor( ) #include 선언 floor(반올림 대상 + 0.5) Reference &amp;amp; 다른 PS 모음집https://github.com/ggh-png/PSC++ STL sort ( )" }, { "title": "C++ STL lower_bound ( )", "url": "/posts/cpp-stl-lowerBound/", "categories": "C++, STL", "tags": "C++, 정렬, STL", "date": "2022-04-04 01:00:00 +0900", "snippet": "C++ STL lower_bound ( )개yo이번 포스팅에선 리스트에서 내가 원하는 key값의 인덱스 값을 구할 수 있는 STL lower_bound ( )에 대해 알아보고 구현도 해보도록 하겠다.Binary Search을 이용하여 lower_bound ( ) 구현 lower_bound ( )는 기본적으로 이진탐색(Binary Search)를 기반으로 만들어졌기에 아래와 같이 구현하였다.#include&amp;lt;iostream&amp;gt;#include&amp;lt;vector&amp;gt;using namespace std;int lower_bound(vector&amp;lt;int&amp;gt; &amp;amp;index, int k, int begin, int end){ if(begin &amp;gt; end) return - 1; int m = (begin + end) / 2; if(index[m] == k) return m; else if(index[m] &amp;gt; k) return lower_bound(index, k, begin, m-1); else return lower_bound(index, k, m+1, end);}int main(){ vector&amp;lt;int&amp;gt; arr = {1, 2, 4, 5, 6, 7, 9}; cout &amp;lt;&amp;lt; &quot;lower_bound(6) : &quot; &amp;lt;&amp;lt; lower_bound(arr, 6, 0, arr.size())&amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &quot;lower_bound(4) : &quot; &amp;lt;&amp;lt; lower_bound(arr, 4, 0, arr.size())&amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &quot;lower_bound(7) : &quot; &amp;lt;&amp;lt; lower_bound(arr, 7, 0, arr.size())&amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &quot;lower_bound(9) : &quot; &amp;lt;&amp;lt; lower_bound(arr, 9, 0, arr.size())&amp;lt;&amp;lt; endl; return 0;}출력lower_bound(6) : 4lower_bound(4) : 2lower_bound(7) : 5lower_bound(9) : 6사용법 lower_bound(검색할 리스트, key, 시작점, 끝점) 반환 값은 리스트의 key이 저장되어 있는 인덱스 값이다. STL lower_bound ( ) 기본적으로 lower_bound( )는 C++의 STL인 algorithm 헤더의 내잠함수이기에 담음과 같이 선언 후 사용한다. lower_bound( )는 찾으려는 key 값과 같거나 보다 큰 가장 작은 수의 index(주소)값을 찾는다. 때문에 오름차순으로 정렬된 리스트에서 사용된다. #include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;#include&amp;lt;vector&amp;gt;using namespace std;int main(){ vector&amp;lt;int&amp;gt; arr = {1, 2, 4, 5, 6, 7, 9}; cout &amp;lt;&amp;lt; &quot;lower_bound(6) : &quot; &amp;lt;&amp;lt; lower_bound(arr.begin(), arr.end(), 6) - arr.begin() &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &quot;lower_bound(4) : &quot; &amp;lt;&amp;lt; lower_bound(arr.begin(), arr.end(), 4) - arr.begin() &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &quot;lower_bound(7) : &quot; &amp;lt;&amp;lt; lower_bound(arr.begin(), arr.end(), 7) - arr.begin() &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &quot;lower_bound(9) : &quot; &amp;lt;&amp;lt; lower_bound(arr.begin(), arr.end(), 9) - arr.begin() &amp;lt;&amp;lt; endl; return 0;}출력lower_bound(6) : 4lower_bound(4) : 2lower_bound(7) : 5lower_bound(9) : 6lower_bound 사용법 용도 찾으려는 key 값보다 같거나 큰 수를 찾을 때 사용함. 사용 조건 탐색을 진행할 리스트가 오름차순으로 정렬되어 있어야 함. 같거나 큰 수를 찾기 때문. lower_bound(리스트의 시작점, 리스트의 끝점, 찾을 key) 반환형은 Iterator(주소 값) 이기에 리스트의 첫 번째 주소를 빼면 N번째 인덱스인지 알 수 있다. index = lower_bound(리스트의 시작점, 리스트의 끝점, 찾을 key) - 리스트의 시작점 STL upper_bound ( ) 사용 upper_bound( ) 역시 C++의 STL인 algorithm 헤더의 내잠함수이기에 담음과 같이 선언 후 사용한다. upper_bound( )는 찾으려는 key 값을 초과하는 첫번째 index를 구한다. 때문에 오름차순으로 정렬된 리스트에서 사용된다. #include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;#include&amp;lt;vector&amp;gt;using namespace std;int main(){ vector&amp;lt;int&amp;gt; arr = {1, 2, 4, 5, 6, 7, 9}; cout &amp;lt;&amp;lt; &quot;upper_bound(6) : &quot; &amp;lt;&amp;lt; upper_bound(arr.begin(), arr.end(), 6) - arr.begin() &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &quot;upper_bound(4) : &quot; &amp;lt;&amp;lt; upper_bound(arr.begin(), arr.end(), 4) - arr.begin() &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &quot;upper_bound(7) : &quot; &amp;lt;&amp;lt; upper_bound(arr.begin(), arr.end(), 7) - arr.begin() &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &quot;upper_bound(9) : &quot; &amp;lt;&amp;lt; upper_bound(arr.begin(), arr.end(), 9) - arr.begin() &amp;lt;&amp;lt; endl; return 0;}출력upper_bound(6) : 5upper_bound(4) : 3upper_bound(7) : 6upper_bound(9) : 7upper_bound 사용법 용도 찾으려는 key 값을 초과하는 최초의 값의 인덱스를 찾기 위해 사용한다. 사용 조건 탐색을 진행할 리스트가 오름차순으로 정렬되어 있어야 함. key 값을 초과하는 첫번째 인덱스 값을 찾기 때문. upper_bound(리스트의 시작점, 리스트의 끝점, 찾을 key) 반환형은 Iterator(주소 값) 이기에 리스트의 첫 번째 주소를 빼면 N번째 인덱스인지 알 수 있다. index = upper_bound(리스트의 시작점, 리스트의 끝점, 찾을 key) - 리스트의 시작점 Referencehttps://chanhuiseok.github.io/posts/algo-55/C++ Lower Bound-STL 사용하는 방법" }, { "title": "BOJ - 18870 - 좌표압축", "url": "/posts/BOJ-18870/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, 정렬", "date": "2022-04-03 11:10:00 +0900", "snippet": "BOJ - 18870 - 좌표압축문제18870번: 좌표 압축문제 개념문제를 풀기 앞서 좌표압축이 무엇인지부터 알아야 한다. 좌표압축이란 범위가 광범위한 좌표들이 존재할 때 임시적으로 index값을 매겨 새로운 압축된 좌표를 만드는 것이다.좌표압축의 처리과정은 다음과 같다. x_list [ 2 4 -10 4 -9 ] 의 x축 좌표가 존재할 때 이를 오름차순으로 정리 [ -10 -9 2 4 4 ] 오름차순으로 정리 후 중복값을 제거 index [ -10 -9 2 4 ] 중복값 제거 후 인덱스 리스트 생성 -10 ~&amp;gt; 0 -9 ~&amp;gt; 1 2 ~&amp;gt; 2 4 ~&amp;gt; 3 CompressList [ 2 3 0 3 1 ] 인덱스 리스트와 x_list를 비교 후 압축좌표 생성SOL 좌표 리스트를 오름차순 정리 &amp;amp; 중복 값 제거 좌표 압축 인덱스 부여 좌표 리스트와 비교 후 인덱스 값 입력 - BinarySearch 사용구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;// 오름차순 정리(중복 제거)// 좌표 압축 인덱스 부여 // 기존 배열과 비교 후 인덱스 값 입력 // index : 압축좌표 k : 기존 좌표 begin : 압축좌표의 앞단 end : 압축 좌표의 뒷단int BinarySearch(vector&amp;lt;int&amp;gt; &amp;amp;index, int k, int begin, int end){ if(begin &amp;gt; end) return - 1; int m = (begin + end) / 2; if(index[m] == k) return m; else if(index[m] &amp;gt; k) return BinarySearch(index, k, begin, m-1); else return BinarySearch(index, k, m+1, end);}int main(){ int num, temp; vector&amp;lt;int&amp;gt; index; vector&amp;lt;int&amp;gt; x_list; // 값 입력 scanf(&quot;%d&quot;, &amp;amp;num); for(int i=0; i &amp;lt; num; i++) { scanf(&quot;%d&quot;, &amp;amp;temp); index.push_back(temp); x_list.push_back(temp); } // 오름차순 정렬 sort(index.begin(), index.end()); // 중복제거 index.erase(unique(index.begin(), index.end()), index.end()); // index 부여 for(int i=0; i &amp;lt; x_list.size(); i++) x_list[i] = BinarySearch(index, x_list[i], 0, index.size()); for(auto el : x_list) printf(&quot;%d &quot;, el); printf(&quot;\\n&quot;); }해설 좌표 리스트를 오름차순 정리 &amp;amp; 중복 값 제거 오름차순 정렬 sort(index.begin(), index.end()); 중복제거 index.erase(unique(index.begin(), index.end()), index.end()); 좌표 리스트와 비교 후 인덱스 값 입력 - BinarySearch 사용 int BinarySearch(vector&amp;lt;int&amp;gt; &amp;amp;index, int k, int begin, int end) { if(begin &amp;gt; end) return - 1; int m = (begin + end) / 2; if(index[m] == k) return m; else if(index[m] &amp;gt; k) return BinarySearch(index, k, begin, m-1); else return BinarySearch(index, k, m+1, end); } for(int i=0; i &amp;lt; x_list.size(); i++) x_list[i] = BinarySearch(index, x_list[i], 0, index.size()); 시간복잡도 O(N log N) 다른 풀이과정은 위에 구현해둔 코드와 같으나 이진탐색을 라이브러리로 구현해 둔 lower_bound 를 사용하여 구현 하였다.#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;// 오름차순 정리(중복 제거)// 좌표 압축 인덱스 부여 // 기존 배열과 비교 후 인덱스 값 입력 // index : 압축좌표 k : 기존 좌표 begin : 압축좌표의 앞단 end : 압축 좌표의 뒷단int main(){ int num, temp; vector&amp;lt;int&amp;gt; index; vector&amp;lt;int&amp;gt; x_list; // 값 입력 scanf(&quot;%d&quot;, &amp;amp;num); for(int i=0; i &amp;lt; num; i++) { scanf(&quot;%d&quot;, &amp;amp;temp); index.push_back(temp); x_list.push_back(temp); } // 오름차순 정렬 sort(index.begin(), index.end()); // 중복제거 index.erase(unique(index.begin(), index.end()), index.end()); // index 부여 for(int i=0; i &amp;lt; x_list.size(); i++) printf(&quot;%ld &quot;, (lower_bound(index.begin(), index.end(), x_list[i]) - index.begin())); }lower_bound 사용법 용도 찾으려는 key 값보다 같거나 큰 수를 찾을 때 사용함. 사용 조건 탐색을 진행할 리스트가 오름차순으로 정렬되어 있어야 함. 같거나 큰 수를 찾기 때문. lower_bound(리스트의 시작점, 리스트의 끝점, 찾을 key) 반환형은 Iterator(주소 값) 이기에 리스트의 첫 번째 주소를 빼면 N번째 인덱스인지 알 수 있다. index = lower_bound(리스트의 시작점, 리스트의 끝점, 찾을 key) - 리스트의 시작점 Reference &amp;amp; 다른 PS 모음집https://github.com/ggh-png/PSlower_boundhttps://ggh-png.github.io/posts/cpp-stl-lowerBound/" }, { "title": "BOJ - 10814 - 나이순 정렬", "url": "/posts/BOJ-10814/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, 정렬", "date": "2022-04-02 11:15:00 +0900", "snippet": "BOJ - 10814 - 나이순 정렬문제SOL 나이순으로 정렬 후 나이가 같으면 가입순으로 정렬 2중 pair를 사용하여 &amp;lt;가입번호(int), 나이(int), 이름(int)&amp;gt; 커스텀 자료형 생성 vector&amp;lt;pair&amp;lt;int, pair&amp;lt;int, string»&amp;gt; m_list; compare를 사용하여 나이순 정렬 후 가입순 정렬 bool compare(pair&amp;lt;int, pair&amp;lt;int, string&amp;gt;&amp;gt; a, pair&amp;lt;int, pair&amp;lt;int, string&amp;gt;&amp;gt; b) { if(a.second.first == b.second.first) return a.first &amp;lt; b.first; return a.second.first &amp;lt; b.second.first; } 정답 소스#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;bool compare(pair&amp;lt;int, pair&amp;lt;int, string&amp;gt;&amp;gt; a, pair&amp;lt;int, pair&amp;lt;int, string&amp;gt;&amp;gt; b){ if(a.second.first == b.second.first) return a.first &amp;lt; b.first; return a.second.first &amp;lt; b.second.first; }int main(){ int num; int old; char name[101]; vector&amp;lt;pair&amp;lt;int, pair&amp;lt;int, string&amp;gt;&amp;gt;&amp;gt; m_list; scanf(&quot;%d&quot;, &amp;amp;num); for(int i=0; i &amp;lt; num; i++) { scanf(&quot;%d%s&quot;,&amp;amp;old ,name); m_list.push_back(pair&amp;lt;int, pair&amp;lt;int, string&amp;gt;&amp;gt;(i, make_pair(old, name))); } sort(m_list.begin(), m_list.end(), compare); for(int i=0; i &amp;lt; m_list.size(); i++) printf(&quot;%d %s\\n&quot;, m_list[i].second.first, m_list[i].second.second.c_str());}출력321 Junkyu21 Dohyun20 Sunyoung-----20 Sunyoung21 Junkyu21 DohyunReference &amp;amp; 다른 PS 모음집C++ STL sort ( )https://github.com/ggh-png/PS" }, { "title": "BOJ - 1181 - 단어정렬", "url": "/posts/BOJ-1181/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, 정렬", "date": "2022-04-02 11:10:00 +0900", "snippet": "BOJ - 1181 - 단어정렬문제SOL 문자열의 길이순으로 정렬 후 사전순으로 정렬 sort의 compare를 사용하여 조건문을 만들어 줌. bool compare(string a, string b) { if(a.size() == b.size()) return a &amp;lt; b; return a.size() &amp;lt; b.size(); } 중복 제거 st_list.erase(unique(st_list.begin(), st_list.end()), st_list.end()); 정답 소스#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;bool compare(string a, string b){ if(a.size() == b.size()) return a &amp;lt; b; return a.size() &amp;lt; b.size(); }int main(){ int num; string str; vector&amp;lt;string&amp;gt; st_list; scanf(&quot;%d&quot;, &amp;amp;num); for(int i=0; i &amp;lt; num; i++) { cin &amp;gt;&amp;gt; str; st_list.push_back(str); } sort(st_list.begin(), st_list.end(), compare); st_list.erase(unique(st_list.begin(), st_list.end()), st_list.end()); for(int i=0; i &amp;lt; st_list.size(); i++) cout &amp;lt;&amp;lt; st_list[i] &amp;lt;&amp;lt; endl;}출력13butiwonthesitatenomorenomoreitcannotwaitimyours------------iimitnobutmorewaitwontyourscannothesitateReference &amp;amp; 다른 PS 모음집C++ STL sort ( )https://github.com/ggh-png/PS" }, { "title": "BOJ - 11650 - 좌표 정렬하기", "url": "/posts/BOJ-11650/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, 정렬", "date": "2022-04-01 11:10:00 +0900", "snippet": "BOJ - 11651 - 좌표 정렬하기 2문제11650번: 좌표 정렬하기SOL x 좌표 끼리 정렬 후 중복 발생시 y 좌표를 기준으로 정렬 pair을 사용하여 2개의 자료형을 받을 수 있는 자료형 생성 pair&amp;lt;int, int&amp;gt; sort의 compare를 사용하여 조건문을 만들어 줌 bool compare(pair&amp;lt;int,int&amp;gt; a, pair&amp;lt;int,int&amp;gt; b) { if(a.first == b.first) return a.second &amp;lt; b.second; return a.first &amp;lt; b.first; } 구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;bool compare(pair&amp;lt;int,int&amp;gt; a, pair&amp;lt;int,int&amp;gt; b){ if(a.first == b.first) return a.second &amp;lt; b.second; return a.first &amp;lt; b.first; }int main(){ int num; int x, y; vector&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt; xy_list; cin &amp;gt;&amp;gt; num; for(int i=0; i &amp;lt; num; i++) { cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y; xy_list.push_back(pair&amp;lt;int, int&amp;gt;(x, y)); } sort(xy_list.begin(), xy_list.end(), compare); for(int i=0; i &amp;lt; xy_list.size(); i++) cout &amp;lt;&amp;lt; xy_list[i].first &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; xy_list[i].second &amp;lt;&amp;lt; endl;} 출력은 정상적으로 되지만… 시간초과라 하니 std::cin, cout을 scanf, printf함수로 바꿔보자…구현 - scanf, printf#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;bool compare(pair&amp;lt;int,int&amp;gt; a, pair&amp;lt;int,int&amp;gt; b){ if(a.first == b.first) return a.second &amp;lt; b.second; return a.first &amp;lt; b.first; }int main(){ int num; int x, y; vector&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt; xy_list; scanf(&quot;%d&quot;, &amp;amp;num); for(int i=0; i &amp;lt; num; i++) { scanf(&quot;%d%d&quot;, &amp;amp;x, &amp;amp;y); xy_list.push_back(pair&amp;lt;int, int&amp;gt;(x, y)); } sort(xy_list.begin(), xy_list.end(), compare); for(int i=0; i &amp;lt; xy_list.size(); i++) printf(&quot;%d %d\\n&quot;, xy_list[i].first, xy_list[i].second);}출력53 41 11 -12 23 3--------1 -11 12 23 33 4비슷한 문제 : 11651 - 좌표 정렬하기 2 위와 같은 방법으로 구현함.11651 - 좌표 정렬하기 2 - 구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;bool compare(pair&amp;lt;int,int&amp;gt; a, pair&amp;lt;int,int&amp;gt; b){ if(a.second == b.second) return a.first &amp;lt; b.first; return a.second &amp;lt; b.second; }int main(){ int num; int x, y; vector&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt; xy_list; scanf(&quot;%d&quot;, &amp;amp;num); for(int i=0; i &amp;lt; num; i++) { scanf(&quot;%d%d&quot;, &amp;amp;x, &amp;amp;y); xy_list.push_back(pair&amp;lt;int, int&amp;gt;(x, y)); } sort(xy_list.begin(), xy_list.end(), compare); for(int i=0; i &amp;lt; xy_list.size(); i++) printf(&quot;%d %d\\n&quot;, xy_list[i].first, xy_list[i].second);}출력50 41 21 -12 23 3------1 -11 22 23 30 4Reference &amp;amp; 다른 PS 모음집C++ STL sort ( )https://github.com/ggh-png/PS" }, { "title": "BOJ - 1427 - 소트인사이드", "url": "/posts/BOJ-1427/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, 정렬", "date": "2022-03-31 11:10:00 +0900", "snippet": "BOJ - 1427 - 소트인사이드문제1427번: 소트인사이드SOL 문자열 변환 std::string - to_string(num) 내림차순 정렬 sort(temp.rbegin(), temp.rend()); 구현#include&amp;lt;iostream&amp;gt;#include&amp;lt;string&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std; string solution(int num){ string temp = to_string(num); sort(temp.rbegin(), temp.rend()); return temp;}int main(){ int num; cin &amp;gt;&amp;gt; num; cout &amp;lt;&amp;lt; solution(num) &amp;lt;&amp;lt; endl; return 0; }Reference &amp;amp; 다른 PS 모음집https://github.com/ggh-png/PS" }, { "title": "BOJ - 11399 - ATM", "url": "/posts/BOJ-11399/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, 정렬", "date": "2022-03-29 11:10:00 +0900", "snippet": "BOJ - 11399 - ATM문제11399번: ATMSOL 최솟값 구하기 오름차순 정렬 후 조건에 맞춰 덧셈 조건에 맞춰 덧셈 동정할당 배열인 vector에 저장 후 덧셈 구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int solution(vector&amp;lt;int&amp;gt; arr){ int answer = 0; vector&amp;lt;int&amp;gt; temp; sort(arr.begin(), arr.end()); for(int i=0; i &amp;lt; arr.size(); i++) { temp.push_back(arr[i]); for(auto el : temp) answer += el; } return answer;}int main(){ int num, temp; cin &amp;gt;&amp;gt; num; vector&amp;lt;int&amp;gt; arr; for(int i=0; i &amp;lt; num; i++) { cin &amp;gt;&amp;gt; temp; arr.push_back(temp); } cout &amp;lt;&amp;lt; solution(arr) &amp;lt;&amp;lt; endl; return 0; }Reference음써" }, { "title": "프로그래머스 - level_2 - H-index", "url": "/posts/programmers-h-index/", "categories": "PS, 프로그래머스", "tags": "C++, PS, 프로그래머스, 정렬", "date": "2022-03-27 11:40:00 +0900", "snippet": "프로그래머스 - level_2 - H-index문제코딩테스트 연습 - H-IndexSOL 내림차순 정렬 ex) [ 3,1,4,1,5] [ 5,3,2,1,1 ] 인자 값과 인덱스 값이 엇갈리는 지점 탐색 5 ~&amp;gt; 1 3 ~&amp;gt; 2 - H index 2 ~&amp;gt; 3 - 엇갈림 반례 ex) [ 12, 9, 9, 9 ] - 동일한 수가 연속적으로 나오거나, 인덱스 값이 엇갈리지 않는경우 H - index : citations.size() 구현#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;// H index를 구하는법 // 아마 어떤 요소를 기준으로 요소 이상의 값의 개수가 최댓값이 될 수 있는 기준요소를 구하는거겠지? int solution(vector&amp;lt;int&amp;gt; citations) { int answer = 0; int i; sort(citations.rbegin(), citations.rend()); for(i=0; i &amp;lt; citations.size(); i++) { if(citations[i] &amp;lt; i+1) return answer = i; else if(citations[i] == i+1) return answer = i+1; } answer = i; return answer;}ReferenceGuides: 1-6. h-Index: Home" }, { "title": "프로그래머스 - level_2 - 가장 큰 수", "url": "/posts/programmers-sort/", "categories": "PS, 프로그래머스", "tags": "C++, PS, 프로그래머스, 정렬", "date": "2022-03-27 11:30:00 +0900", "snippet": "프로그래머스 - level_2 - 가장 큰 수문제코딩테스트 연습 - 가장 큰 수SOL to_string으로 변환한 두 정수를 합한 값이 큰 값을 기준으로 정렬하기 ex) sum (”3”, “11”) ~&amp;gt; 311 sum (”11”, “3”) ~&amp;gt; 113 구현#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;using namespace std;// 앞자리 기준으로 // 내림차순 정렬 // 문자열에 저장 bool compare(int a, int b){ string tmp_1 = to_string(a) + to_string(b); string tmp_2 = to_string(b) + to_string(a); return tmp_1 &amp;gt; tmp_2;}string solution(vector&amp;lt;int&amp;gt; numbers) { string answer = &quot;&quot;; sort(numbers.begin(), numbers.end(), compare); for(auto el : numbers) answer += to_string(el); if(answer[0] == &#39;0&#39;) answer = &quot;0&quot;; return answer;}ReferenceC++ STL sort ( )" }, { "title": "BOJ - 10989 - 수 정렬하기 3", "url": "/posts/BOJ-10989/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ, 정렬", "date": "2022-03-27 11:10:00 +0900", "snippet": "BOJ - 10989 - 수 정렬하기 3문제10989번: 수 정렬하기 3SOL 데이터의 개수가 1 ~10,000,000개 주어진다. O(N * log N) 사용 - 데이터가 방대하다. 데이터의 범위는 10,000 보다 작거나 같은수다. 계수정렬(Counting Sort) - 범위가 다소 작다. 구현#include&amp;lt;iostream&amp;gt;using namespace std; // 데이터의 개수 입력 후 데이터 입력 하기 // 카운팅할 배열 선언 // 카운팅 하기 // 카운팅 한 배열 출력 int main(){ // counting arr int arr[10001]={0}; int num; int tmp; // 데이터 입력 cin &amp;gt;&amp;gt; num; for(int i=1; i &amp;lt;= num; i++) { scanf(&quot;%d&quot;, &amp;amp;tmp); arr[tmp]++; } // 결과 출력 for(int i=1; i &amp;lt; 10001; i++) while(arr[i] != 0) { cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &#39;\\n&#39;; arr[i]--; } return 0;} 입력을 받을 때 std::cin, cout 보다 scanf, printf가 더 빠르다. 사람들이 C 형식으로 푸는것은 다 이유가 있구나라는 생각이 든다.std::cin, cout 사용#include&amp;lt;iostream&amp;gt;using namespace std; // 데이터의 개수 입력 후 데이터 입력 하기 // 카운팅할 배열 선언 // 카운팅 하기 // 카운팅 한 배열 출력 int main(){ ios_base :: sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); // counting arr int arr[10001]={0}; int num; int tmp; // 데이터 입력 cin &amp;gt;&amp;gt; num; for(int i=1; i &amp;lt;= num; i++) { cin &amp;gt;&amp;gt; tmp; arr[tmp]++; } // 결과 출력 for(int i=1; i &amp;lt; 10001; i++) while(arr[i] != 0) { cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &#39;\\n&#39;; arr[i]--; } return 0;} 물론 위와 같은 방법으로 std::cin, cout을 가속화 하여 쓸 순 있지만 일종의 편법이라 하니 되도록 효율성을 높일 땐 C스타일의 코딩법을 생각해보자.Reference글 읽기 - 추가 설명 및 다른 언어 빠른 입출력 방법" }, { "title": "정렬 알고리즘(힙 정렬)", "url": "/posts/%EC%A0%95%EB%A0%AC7-%ED%9E%99%EC%A0%95%EB%A0%AC/", "categories": "algorithm, 정렬", "tags": "algorithm, 정렬, C++", "date": "2022-03-26 11:10:00 +0900", "snippet": "힙 정렬 (Heap Sort)개yo이번 포스팅에선 힙 정렬 (Heap Sort)에 대해 알아볼 것이다. 힙 정렬은 이전 포스트에서 다뤘던 퀵 , 병합 정렬 과 마찬가지로 시간복잡도가 O(N *log N) 인 빠른 정렬 알고리즘이다. 힙 정렬을 이해하기 위해선 이진트리, 힙을 이해해야 하기에 이번 포스트에서 함께 알아볼 것이다.문제 문제 : 다음 숫자들을 오름차순으로 정렬하는 프로그램을 작성 하여라 7 5 9 0 3 1 6 2 9 1 4 8 0 5 2SOL문제를 해결하기 위해 “힙(Heap)을 이용하여 데이터를 정렬하기”를 생각해 볼 수 있다.이를 이용한 방법을 힙 정렬 이라고 부른다. 힙정렬은 힙 트리 구조로 이루어저 있어 각각 힙, 트리가 무엇인지 알아야 한다.완전 이진 트리(Complete Binary Tree) 아래와 같은 구조를 이진 트리라고 한다. 말 그대로 2개의 트리 모양인데 줄기와 가지를 생각하면 된다. 따라서 위 구조는 하나의 줄기에 2개의 가지를 가진 상태다.특징 노드 (1) : 노드(2) (3)의 부모노드 루트(Root) 노드 노드(2) (3) : 노드 (1)의 자식노드 노드(4) (5), 노드(6) : 노드(2) (3)의 자식 노드 리프(Leaf) 노드 좀 더 자세하게 말하자면 위 구조는 이진트리 중에서도 완전 이진트리다.완전 이진 트리는 위와 같이 6개의 데이터가 존재 할때 루트 노드를 시작으로 왼쪽부터 빈 노드없이 채워지는 트리를 말한다.힙(Heap) 완전 이진 트리에 대해 알아보았으니 이제 힙(Heap)에 대해 알아보도록 하겠다. 힙은 완전이진 트리를 사용하여 최대, 최소힙으로 두가지로 나눠지고 이는 최솟값이나 최댓값을 빠르게 찾아내기 위해 쓰인다.특징위와 같은 구조를 힙이라고 하며, 힙 중에서도 최대 힙이다. 최대힙은 부모 노드의 값이 자식 노드의 값보다 커야한다.두번째 예제처럼 최대힙이 붕괴되는 경우에는 자식 노드와 부모 노드를 바꿔야 한다. swap(자식 노드(7), 부모 노드(5))위와 같은 경우를 힙생성 알고리즘이라고 한다.만약 바꾼 뒤에도 붕괴되는 경우라면 아랫단의 자식과 바꿔야 한다. 언제까지??? 붕괴되는 경우가 일어나지 않을 때 까지 위와 같은 힙 생성 알고리즘은 전체 트리의 힙 구조를 가진다. 또한 트리를 보면 알 수 있듯이 자식 노드로 내려갈수록 노드의 개수가 2배씩 증가한다. 이러한 특징은 시간복잡도의 측면에서 봤을 때 O(log N)이 수행된다.문제 문제 : 다음 숫자들을 오름차순으로 정렬하는 프로그램을 작성 하여라 [ 7 6 5 8 3 5 9 1 6 ]구현 힙을 구성한다. 크기를 줄여가며 반복적으로 힙을 구성한다. 자식 중에 더 큰 값을 찾는다. 루트보다 자식이 크면 교환한다.#include&amp;lt;iostream&amp;gt;using namespace std; int num = 9;int heap[9] = {7,6,5,8,3,5,9,1,6}; // 완전 이진 트리 구조 int main(){ cout &amp;lt;&amp;lt; &quot;정렬 전 : &quot;; for(auto el : heap) cout &amp;lt;&amp;lt; el &amp;lt;&amp;lt; &quot; &quot;; cout &amp;lt;&amp;lt; endl; // 전체 트리 구조를 최대 힙 구조로 바꾼다. for(int i=1; i &amp;lt; num; i++) { int c = i; // 자식노드 do { int root = (c-1) / 2; // 0 index 1회 실행 if(heap[root] &amp;lt; heap[c]) // 0 1 swap(heap[root], heap[c]); c = root; // index init 1 ~&amp;gt; 0 } while(c != 0); // c는 0이 되기 때문에 1회만 실행하고 꺼짐 } cout &amp;lt;&amp;lt; &quot;힙 구성 : &quot;; for(auto el : heap) cout &amp;lt;&amp;lt; el &amp;lt;&amp;lt; &quot; &quot;; cout &amp;lt;&amp;lt; endl; // 크기를 줄여가며 반복적으로 힙을 구성한다. // root노드의 요소 값을 맨 뒤 리프노드와 바꾼다. for(int i = num-1; i &amp;gt;= 0; i--) { // root 노드와 맨 뒤 leaf노드 스왑 swap(heap[0], heap[i]); int root = 0; //root 노드 int c = 1; // n 번째 자식노드 do { c = 2 * root + 1; // 자식노드 1 // 자식 노드 중 더 큰 값을 찾는다. 왼 오 비교 // 언제까지? 마지막 leaf노드까지~ if(c &amp;lt; i-1 &amp;amp;&amp;amp; heap[c] &amp;lt; heap[c + 1]) c++; // 2 // root 노드보다 자식 노드가 크면 스왑 if(c &amp;lt; i &amp;amp;&amp;amp; heap[root] &amp;lt; heap[c]) swap(heap[root], heap[c]); // 재귀적 구조 root = c; // 0으로 초기화 } while(c &amp;lt; i); } cout &amp;lt;&amp;lt; &quot;힙 정렬 : &quot;; for(auto el : heap) cout &amp;lt;&amp;lt; el &amp;lt;&amp;lt; &quot; &quot;; cout &amp;lt;&amp;lt; endl;}출력정렬 전 : 7 6 5 8 3 5 9 1 6 힙 구성 : 9 7 8 6 3 5 5 1 6 힙 정렬 : 1 3 5 5 6 6 7 8 9해설위 코드를 실행하면 오름차순으로 배열이 정리된 모습을 확인 할 수 있다. 힙 구조 구현 for(int i=1; i &amp;lt; num; i++) { int c = i; // 자식노드 do { int root = (c-1) / 2; // 0 index 1회 실행 if(heap[root] &amp;lt; heap[c]) // 0 1 swap(heap[root], heap[c]); c = root; // index init 1 ~&amp;gt; 0 } while(c != 0); // c는 0이 되기에 1회만 실행하고 꺼짐 } 자식 중에 루트보다 더 큰 값을 찾는다. 루트보다 자식이 크면 교환한다. for(int i = num-1; i &amp;gt;= 0; i--) { // root 노드와 맨 뒤 leaf노드 스왑 swap(heap[0], heap[i]); int root = 0; //root 노드 int c = 1; // n 번째 자식노드 do { c = 2 * root + 1; // 자식노드 1 // 자식 노드 중 더 큰 값을 찾는다. 왼 오 비교 // 언제까지? 마지막 leaf노드까지~ if(c &amp;lt; i-1 &amp;amp;&amp;amp; heap[c] &amp;lt; heap[c + 1]) c++; // 2 // root 노드보다 자식 노드가 크면 스왑 if(c &amp;lt; i &amp;amp;&amp;amp; heap[root] &amp;lt; heap[c]) swap(heap[root], heap[c]); // 재귀적 구조 root = c; // 0으로 초기화 } while(c &amp;lt; i); } 마무리 힙 정렬은 이전에 다뤘던 병합정렬과 다르게 별도의 추가적인 배열이 필요없어 공간 복잡도 측병에서 효율적이다. 시간복잡도가 항상 O(N * log N)을 보장한다. 이론적으로 퀸, 병합 정렬보다 더 효율성이 좋다. 허나 평균 속도를 보자면 퀵 정렬이 더욱 빠르기에 잘 사용하지 않는다. 루프 내의 코드가 길고, 비효율적인 개시메모리 사용을 하기에 따라 특히 대용량의 데이터를 정렬하기엔 부적절하다.추가 문제 입력 [ 7 ] [ 3 1 4 1 5 9 2 ] 힙 정렬의 과정을 출력하는 코드를 작성하여라. 단 하향식 힙 정렬을 사용하여라 구현#include&amp;lt;iostream&amp;gt;#include&amp;lt;vector&amp;gt;using namespace std; // 힙 구조 만들기 // 자식 노드와 비교 후 스왑 // 단 자식 노드에서만 int num = 10;int heap[] = {26,5,37,1,61,11,59,15,48,19};void heapify(int i){ // 왼쪽 자식노드 int c = 2 *i + 1; // 오른쪽 자식노드가 있고 왼쪽 자식노드보다 크면 if(c &amp;lt; num &amp;amp;&amp;amp; heap[c] &amp;lt; heap[c+1]) c++; // 부모 노드보다 자식노드가 크면 스왑 if(heap[i] &amp;lt; heap[c]) swap(heap[i], heap[c]); // num / 2 까지만 왜? why? // 실질적으로 봐야되는 데이터는 절반으로 나누기 때문 if(c &amp;lt;= num / 2) heapify(c);}int main(){ // 힙 구조 생성 for(int i=num/2; i &amp;gt;= 0; i--) heapify(i); // 힙 정렬 for(int i=num; i &amp;gt;=0; i--) { cout &amp;lt;&amp;lt; &quot;정렬중 &quot;; for(int j=0; j &amp;lt; num; j++) { cout &amp;lt;&amp;lt; heap[j] &amp;lt;&amp;lt; &quot; &quot;; } cout &amp;lt;&amp;lt; &#39;\\n&#39;; swap(heap[0], heap[i]); int root = 0; int c = 1; do { c = 2 * root + 1; // index 1부터 // 범위안에 해당되고 오른쪽 값보다 작으면 if(c &amp;lt; i-1 &amp;amp;&amp;amp; heap[c] &amp;lt; heap[c + 1]) c++; // 하향식으로 스왑 if(c &amp;lt; i &amp;amp;&amp;amp; heap[root] &amp;lt; heap[c]) swap(heap[root], heap[c]); root = c; } while(c &amp;lt; i); } }Reference10. 힙 정렬(Heap Sort)" }, { "title": "BOJ - 2588 - 곱셈", "url": "/posts/BOJ-2588/", "categories": "PS, BOJ", "tags": "C++, PS, BOJ", "date": "2022-03-25 11:10:00 +0900", "snippet": "BOJ - 2588 - 곱셈문제2588번: 곱셈슉슈슉#include&amp;lt;iostream&amp;gt; #include&amp;lt;string&amp;gt;#include&amp;lt;vector&amp;gt;#include&amp;lt;math.h&amp;gt;using namespace std;int main(){ string a, b; // 숫자 입력 vector&amp;lt;int&amp;gt; temp; int tmp; int answer=0; cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; for(int i=0; i &amp;lt;= b.size(); i++) { tmp = stoi(a) * (int)(b[b.size() - i]-48); temp.push_back(tmp); } for(int i=1; i &amp;lt; temp.size(); i++) { cout &amp;lt;&amp;lt; temp[i] &amp;lt;&amp;lt; endl; temp[i] *= pow(10, (i-1)); } for(int i=1; i &amp;lt; temp.size(); i++) answer += temp[i]; cout &amp;lt;&amp;lt; answer &amp;lt;&amp;lt; endl; }" }, { "title": "C++ STL sort ( )", "url": "/posts/cpp-stl-sort/", "categories": "C++, STL", "tags": "C++, 정렬, STL", "date": "2022-03-23 11:10:00 +0900", "snippet": "C++ STL sort ( )개yo지금까지의 포스팅에선 여러가지 정렬 알고리즘에 대해 알아 보았다. 정렬 알고리즘은 CS의 오래된 연구분야로 이미 뛰어난 관련 라이브러리가 각 언어마다 존재 하기에 직접 구현을 할 필요가 없다. 해서 이번 포스팅에선 C++ STL의 정렬 함수인 sort( ) 에 대해 알아보도록 하겠다.STL sort ( ) 사용법 - 두개의 인자만 사용 기본적으로 sort ( )는 C++의 STL인 algorithm 헤더에 포함되어 있어 아래와 같이 선언 후 사용하면 된다.#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;int main(){ int arr[] = {3,1,4,1,5,9,2}; sort(arr, arr+7); for(int i=0; i &amp;lt; 7; i++) cout &amp;lt;&amp;lt; arr[i] &amp;lt;&amp;lt; &quot; &quot;; cout &amp;lt;&amp;lt; endl; } sort( )는 최소 두개의 인자 값을 받는데 이는 즉 정렬을 할 리스트(배열)의 메모리 주소를 뜻한다.sort(시작 메모리 주소, 끝 메모리 주소) 와 같이 작성해주면 아래와 같이 오름차순으로 배열이 정렬이 된다.출력1 1 2 3 4 5 9STL sort ( ) 사용법 - 세개의 인자 사용위에서도 나타냈듯이 sort( )는 sort(시작점, 끝점) 이렇게 두개의 인자 값을 가지고도 오름차순으로 배열을 정렬할 수 있다. sort( )은 세번째 인자값을 넣을 수 있는데 이 세번 째 인자 값은 배열을 정렬하는 과정에서 조건을 뜻하는데 아래와 같이 사용 가능하다.sort(시작점, 끝점, 조건)#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;// 조건 내림차순으로 정렬 하여라 bool compare(int a, int b){ return a &amp;gt; b; }int main(){ int arr[] = {3,1,4,1,5,9,2}; sort(arr, arr+7, compare); for(int i=0; i &amp;lt; 7; i++) cout &amp;lt;&amp;lt; arr[i] &amp;lt;&amp;lt; &quot; &quot;; cout &amp;lt;&amp;lt; endl; }위 코드를 보면 알 수 있듯이 sort( )의 세번째 인자는 bool값으로 받게된다. 위 compare함수는 사용자가 원하는 조건에 따라 변형될 수 있고, 위 코드는 내림차순으로 배열을 정렬하도록 변형한 형태다.따라서 2개의 인자값을 넣어준다면 기본 디폴트 값으로 오름차순으로 정렬되는 것이고, 사용자 정의에 따라서 여러 조건으로 정렬이 가능한 것이다.STL sort ( ) 사용법 - 실무에서의 사용 (Class)어떤 경우에 우리가 실무에서 정렬이 필요할까??예를들어 데이터가 객체로 정리되어 있어 사용자 정의로 여러개의 변수를 포함하는 경우에는 단순히 데이터의 정렬 기법으론 정렬할 수 없다. ex) (학생, 점수)의 객체에서 점수별로 정리하는 것따라서 이런 경우에는 아래와 같이 특정한 변수를 기준으로 정렬하는 방식으로 해결할 수 있다.#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;class Student{public: string m_name; int m_score; Student(string name, int score) { this-&amp;gt;m_name = name; // 멤버 변수 반환 this-&amp;gt;m_score = score; // 멤버 변수 반환 } // 비교 연산자 오버로딩 bool operator &amp;lt; (Student &amp;amp;student) { return this-&amp;gt;m_score &amp;lt; student.m_score; }};int main(){ Student student[] = { Student(&quot;A 쿤&quot;, 90), Student(&quot;B 쿤&quot;, 60), Student(&quot;C 쿤&quot;, 93), Student(&quot;D 쿤&quot;, 40), Student(&quot;E 쿤&quot;, 70), }; sort(student, student+5); for(int i=0; i &amp;lt; 5; i++) cout &amp;lt;&amp;lt; student[i].m_name &amp;lt;&amp;lt; &quot; &quot;; cout &amp;lt;&amp;lt; endl; }위 코드는 class로 사용자 정의 자료형을 만들어 학생의 점수를 기준으로 학생의 이름을 출력하는 코드다. 때문에 자료형이 Student(string, int)형으로 순서대로 이름과 점수가 들어가게 된다.이처럼 하나의 변수만을 정렬하는것이 아닌 사용자의 정의에 때라서 정렬하는 경우에 위와 같은 방법을 쓴다.STL sort ( ) 사용법 - 숏 코딩 빠른개발 (Pair)위에서 설명한 클래스(Class)를 사용하여 사용자 정의 자료형을 만들어 특정한 변수를 기준으로 정렬을 할 순 있지만 클래스를 하나하나 정의를 해 주어야 하는 방식은 장기적으로 관리를 하는 차원에선 좋지만 프로그래밍 속도 측면에선 마냥 좋다곤 볼 수 없다. 따라서 이런 경우에는 Vector 라이브러리의 Pair를 사용하여 아래와 같이 해결할 수 있다.#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;#include&amp;lt;vector&amp;gt;using namespace std;int main(){ vector&amp;lt;pair&amp;lt;int, string&amp;gt;&amp;gt; Student_ScoreList; Student_ScoreList.push_back(pair&amp;lt;int, string&amp;gt;(90, &quot;A 쿤&quot;)); Student_ScoreList.push_back(pair&amp;lt;int, string&amp;gt;(50, &quot;B 쿤&quot;)); Student_ScoreList.push_back(pair&amp;lt;int, string&amp;gt;(60, &quot;C 쿤&quot;)); Student_ScoreList.push_back(pair&amp;lt;int, string&amp;gt;(20, &quot;D 쿤&quot;)); Student_ScoreList.push_back(pair&amp;lt;int, string&amp;gt;(94, &quot;E 쿤&quot;)); sort(Student_ScoreList.begin(), Student_ScoreList.end()); for(int i=0; i &amp;lt; Student_ScoreList.size(); i++) cout &amp;lt;&amp;lt; Student_ScoreList[i].second &amp;lt;&amp;lt; &quot; &quot;; cout &amp;lt;&amp;lt; endl;} vector의 pair는 한 쌍의 데이터를 처리할 수 있도록 해주는 자료구조라고 할 수 있다. 사용법은 아래와 같다.선언 vector&amp;lt;pair&amp;lt;자료형_1, 자료형_2» Vector;입력 Vector.push_back(pair&amp;lt;자료형_1, 자료형_2&amp;gt;(요소_1, 요소_2));출력 요소_1 출력 Vector[N].first 요소_2 출력 Vector[N].second 예시문제 학생명단의 구조가 (이름, 점수, 생년월일) 일때 점수를 기준으로 순서대로 정렬하여라 단. 점수가 같은 경우에는 나이가 더 높은 순위로 정렬 하여라. 학생 1: A 쿤/90점/1996-12-22 학생 2: B 쿤/97점/1993-05-18 학생 3: C 쿤/95점/1993-03-03 학생 4: D 쿤/90점/1997-12/07 학생 5: E 쿤/88점/1999-03-02위 문제를 보면 기준이 두개라는 것을 알 수 있다. 이를 해결하기 위해선 먼저 성적을 기준으로 정렬한 뒤 동일한 점수를 가진 학생은 나이순으로 한번 더 정렬을 하면 된다.#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;#include&amp;lt;vector&amp;gt;using namespace std;bool compare(pair&amp;lt;string, pair&amp;lt;int, int&amp;gt;&amp;gt; a, pair&amp;lt;string, pair&amp;lt;int, int&amp;gt;&amp;gt; b){ // 학생의 점수가 같은 경우 나이가 많은 순으로 if(a.second.first == b.second.first) return a.second.second &amp;lt; b.second.second; else return a.second.first &amp;gt; b.second.first;}int main(){ vector&amp;lt;pair&amp;lt;string, pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt; sl; sl.push_back(pair&amp;lt;string, pair&amp;lt;int, int&amp;gt;&amp;gt;(&quot;A 쿤&quot;, make_pair(90, 19961222))); sl.push_back(pair&amp;lt;string, pair&amp;lt;int, int&amp;gt;&amp;gt;(&quot;B 쿤&quot;, make_pair(97, 19930518))); sl.push_back(pair&amp;lt;string, pair&amp;lt;int, int&amp;gt;&amp;gt;(&quot;C 쿤&quot;, make_pair(95, 19930303))); sl.push_back(pair&amp;lt;string, pair&amp;lt;int, int&amp;gt;&amp;gt;(&quot;D 쿤&quot;, make_pair(90, 19971207))); sl.push_back(pair&amp;lt;string, pair&amp;lt;int, int&amp;gt;&amp;gt;(&quot;E 쿤&quot;, make_pair(88, 19990302))); sort(sl.begin(), sl.end(), compare); for(int i=0; i &amp;lt; sl.size(); i++) cout &amp;lt;&amp;lt; sl[i].first &amp;lt;&amp;lt; &quot; &quot;; cout &amp;lt;&amp;lt; endl;} vector의 pair는 2중으로 위와 같이 사용할 수 있다.선언 vector&amp;lt;pair&amp;lt;자료형_1, pair&amp;lt;자료형_2, 자료형_3»&amp;gt; V;입력 V.push_back(pair&amp;lt;자료형_1, &amp;lt;자료형_2, 자료형_3» (요소_1, make_pair&amp;lt;요소_2, 요소_3)));출력 요소_1 출력 Vector[N].first 요소_2 출력 Vector[N].second.first 요소_3 출력 Vector[N].second.second Reference9. C++ STL sort() 함수 다루기 ②" }, { "title": "정렬 알고리즘(병합 정렬)", "url": "/posts/%EC%A0%95%EB%A0%AC6-%EB%B3%91%ED%95%A9%EC%A0%95%EB%A0%AC/", "categories": "algorithm, 정렬", "tags": "algorithm, 정렬, C++", "date": "2022-03-21 11:10:00 +0900", "snippet": "병합 정렬(Merge Sort)개yo앞선 포스팅에서는 앞도적으로 빠른 속도를 자랑하는 퀵 정렬에 대해 알아보았다. 하지만 이런 퀵 정렬 또한 최악의 상황 (거의 정렬이 되어있는 데이터)에서의 시간복잡도가 O(N * log N)을 보장하지 못한다는 단점을 가지고 있었다. 이런 단점을 보완하여 어떠한 경우에도 시간복잡도O(N * log N)을 보장하는 알고리즘이 있는데 그것이 바로 이번 포스팅에서 알아볼 병합정렬(Merge Sort)이다. 문제 : 다음 숫자들을 오름차순으로 정렬하는 프로그램을 작성 하여라 [ 6, 4, 3 ]SOL문제를 해결하기 위해 퀵정렬을 쓴다면 “일단 반으로 나누고 나중에 합쳐서 정렬하기” 를 생각해 볼 수 있다.위와 같은 방식을 병합정렬 이라고 한다. 특징 어떠한 상황이든 시간 복잡도는 O(N * log N)을 보장한다. 분할, 정복 방법을 채택한 알고리즘이다. 구현#include&amp;lt;iostream&amp;gt;#define MAX 3using namespace std; // 정렬공간 int sorted[MAX];/* 2개의 인접한 배열 list[left...mid]와 list[mid+1...right]의 합병 과정 *//* (실제로 숫자들이 정렬되는 과정) */void merge(int arr[], int left, int mid, int right){ int i = left; // left list first index int j = mid+1; // right list first index int k = left; // sorted list first index int l; //왼쪽에서 정렬된 배열과 오른쪽에서 정렬된 배열을 합침 //둘중 하나가 끝까지 올때 까지 합침 while (i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;= right) { if(arr[i] &amp;lt;= arr[j]) sorted[k++] = arr[i++]; // L[4 6] R[3] else sorted[k++] = arr[j++]; // sorted[3] } // 6 4 비교 후 sorted에 저장 // sorted [4] 그럼 나머지 [6]은??? 아래에서 처리된다. if(i &amp;gt; mid)// right list for(l=j; l &amp;lt;= right; l++) sorted[k++] = arr[l]; // 남아 있는 값들을 일괄 복사 // 이건 left list의 남은 짬들의 복사 else for(l=i; l&amp;lt;=mid; l++) sorted[k++] = arr[l]; // sorted[3, 4] sorted[3, 4, 6] // sorted [4 6] // 배열 sorted[](임시 배열)의 리스트를 배열 list[]로 재복사 for(l=left; l&amp;lt;=right; l++) arr[l] = sorted[l]; // left[6 4] ~&amp;gt; left[4 6]}void MergeSort(int arr[], int left, int right){ int mid; if(left &amp;lt; right) { mid = (left + right)/2; // left list conquer [6 4] MergeSort(arr, left, mid); // right list conquer 대기 [3] MergeSort(arr, mid+1, right); // left &amp;amp; right combine L[6] R[4]먼저 삽입 후 L[4 6] R[3] 삽입 merge(arr, left, mid, right); }}int main(){ int n = MAX; int list[n] = {6, 4, 3}; MergeSort(list, 0, n-1); for(auto el : list) cout &amp;lt;&amp;lt; el &amp;lt;&amp;lt; &quot; &quot;; cout &amp;lt;&amp;lt; endl;}출력3 4 6해설위 코드를 실행하면 오름차순으로 배열이 정리된 모습을 확인 할 수 있다. 크기가 1인 개별 배열로 나눈다.(재귀적 호출 이용) L_1 [6, 4] R_1[3] L_2[6] R_2[4] void MergeSort(int arr[], int left, int right){ int mid; if(left &amp;lt; right) { mid = (left + right)/2; // left list conquer [6 4] MergeSort(arr, left, mid); // right list conquer 대기 [3] MergeSort(arr, mid+1, right); // left &amp;amp; right combine L[6] R[4]먼저 삽입 후 L[4 6] R[3] 삽입 merge(arr, left, mid, right); }} 크기가 1인 개별배열로 나누어 지면 스택마냥 두 리스트들을 정복(정렬)한다. 또는 정렬된 두 배열의 크기를 비교후 삽입한다. L_2[6] , R_2[4] 크기 비교 후 sorted[4] 에 삽입… L_2[6] 이 남게됨 //왼쪽에서 정렬된 배열과 오른쪽에서 정렬된 배열을 합침 //둘중 하나가 끝까지 올때 까지 합침 while (i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;= right) { if(arr[i] &amp;lt;= arr[j]) sorted[k++] = arr[i++]; // L[4 6] R[3] else sorted[k++] = arr[j++]; // sorted[3] } 두 배열의 크기를 비교하고 남은 리스트의 요소를 sorted에 삽입한다. // 6 4 비교 후 sorted에 저장 // sorted [4] 그럼 나머지 [6]은??? 아래에서 처리된다. if(i &amp;gt; mid)// right list for(l=j; l &amp;lt;= right; l++) sorted[k++] = arr[l]; // 남아 있는 값들을 일괄 복사// 이건 left list의 남은 짬들의 복사else for(l=i; l&amp;lt;=mid; l++) sorted[k++] = arr[l]; // sorted[3, 4] sorted[3, 4, 6] sorted에 삽입된 값을 두 배열에 합친 값 안에 넣어 초기화 시켜준다. sorted arr : 4 6 before arr : 6 4 after arr : 4 6 // sorted [4 6] // 배열 sorted[](임시 배열)의 리스트를 배열 arr[]로 재복사 for(l=left; l&amp;lt;=right; l++) arr[l] = sorted[l]; // left[6 4] ~&amp;gt; left[4 6] 정렬된 배열값을 대기중이던 배열과 함께 다시 실행된다. L_1 [6, 4] R_1[3] ~&amp;gt; L_1 [4, 6] R_1[3] arr[4, 6, 3] void MergeSort(int arr[], int left, int right) { int mid; if(left &amp;lt; right) { mid = (left + right)/2; // left list conquer [6 4] MergeSort(arr, left, mid); // right list conquer 대기 [3] MergeSort(arr, mid+1, right); // left &amp;amp; right combine L[6] R[4]먼저 삽입 후 L[4 6] R[3] 삽입 merge(arr, left, mid, right); } } 마무리 이해하기 쉽도록 6 4 3의 3개의 요소를 가진 배열로 설명하지만 어떤 데이터든 위 과정의 반복이라고 생각하면 될것 같다. 추가적으로 병합정렬은 임시 배열을 전역 변수로 사용하는 이유는 메모리 자원의 낭비를 막기 위해서다. 메모리 낭비가 되는 이유는 만약 전역 변수가 아닌 함수 안에서 배열을 사용한다면 매번 배열이 선언됨으로 심각한 메모리 낭비가 발생하기 때문이다. 이후 포스팅에서 설명할 힙 정렬은 이 메모리의 비효율성을 해결해 준다.Reference[알고리즘] 합병 정렬(merge sort)이란 - Heee’s Development Blog(이코테 2021 강의 몰아보기) 4. 정렬 알고리즘" }, { "title": "정렬 알고리즘(계수 정렬)", "url": "/posts/%EC%A0%95%EB%A0%AC5-%EA%B3%84%EC%88%98%EC%A0%95%EB%A0%AC/", "categories": "algorithm, 정렬", "tags": "algorithm, 정렬, C++", "date": "2022-03-20 11:10:00 +0900", "snippet": "계수 정렬 (Counting Sort)개yo이번 포스팅에선 계수정렬 (Counting Sort)에 대해 알아볼 것이다. 계수 정렬은 지난 정렬 알고리즘과 다르게 특정 조건에서 매우 빠르게 작동하는 정렬 알고리즘이다. 앞선 정렬 알고리즘의 시간 복잡도는 대개 O(N^2), O(N * log N) 의 형태를 띄었지만 오늘 알아볼 계수정렬의 시간 복잡도는 O(N + K)를 보장한다. 물론 데이터의 상태가 최악이여도 말이다 : )문제 문제 : 다음 숫자들을 오름차순으로 정렬하는 프로그램을 작성 하여라 7 5 9 0 3 1 6 2 9 1 4 8 0 5 2SOL 가장 작은 ~ 큰 데이터가 담길 리스트를 생성 데이터를 하나씩 확인하며 데이터의 값과 동일한 인덱스에 데이터를 1씩 증가 최종 리스트에 담긴 횟수만큼 기록하고 리스트의 첫번째 데이터부터 그 값만큼 인덱스를 출력 구현#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std; void solution(vector&amp;lt;int&amp;gt; arr, int max){ // 모든 범위의 배열 선언 vector&amp;lt;int&amp;gt; temp(max); vector&amp;lt;int&amp;gt; answer; // 각 데이터에 해당하는 인덱스값 증가 for(int i=0; i &amp;lt; arr.size(); i++) temp[arr[i]] += 1; for(int i=0; i &amp;lt;= max; i++) if(temp[i] != 0) for(int j=0; j &amp;lt; temp[i]; j++) answer.push_back(i); for(auto el : answer) cout &amp;lt;&amp;lt; el &amp;lt;&amp;lt; &quot; &quot;; cout &amp;lt;&amp;lt; endl;}int main(){ vector&amp;lt;int&amp;gt; arr{7,5,9,0,3,1,6,2,9,1,4,8,0,5,2}; int max(9); solution(arr, max); return 0;}출력0 0 1 1 2 2 3 4 5 5 6 7 8 9 9해설위 코드를 실행하면 오름차순으로 배열이 정리된 모습을 확인 할 수 있다. 가장 작은 ~ 큰 데이터가 담길 리스트를 생성 vector&amp;lt;int&amp;gt; temp(max); 데이터를 하나씩 확인하며 데이터의 값과 동일한 인덱스에 데이터를 1씩 증가 for(int i=0; i &amp;lt; arr.size(); i++) temp[arr[i]] += 1; 최종 리스트에 담긴 횟수만큼 기록하고 리스트의 첫번째 데이터부터 그 값만큼 인덱스를 출력 for(int i=0; i &amp;lt;= max; i++) if(temp[i] != 0) for(int j=0; j &amp;lt; temp[i]; j++) answer.push_back(i); 마무리 계수 정렬의 시간 복잡도와 공간 복잡도는 모두 O(N + K)이다. 계수 정렬은 특정 데이터에 극심하게 비효율성을 띈다 ex) 데이터가 0 ~ 999.999의 범위를 가진 단 2개만 존재 할 경우 계수 정렬은 동일한 값을 가지는 데이터가 여러 개 등장 할 때 효과적으로 사용할 수 있다. ex) 성적의 경우 100점을 맞은 학생이 여러명이 있을 수 있기 때문에 계수 정렬이 효과적이다. Reference(이코테 2021 강의 몰아보기) 4. 정렬 알고리즘" }, { "title": "정렬 알고리즘(퀵 정렬)", "url": "/posts/%EC%A0%95%EB%A0%AC4-%ED%80%B5%EC%A0%95%EB%A0%AC/", "categories": "algorithm, 정렬", "tags": "algorithm, 정렬, C++", "date": "2022-03-20 11:10:00 +0900", "snippet": "퀵 정렬(Quick Sort)개yo앞선 포스팅에서는 선택정렬 , 버블정렬 , 삽입정렬에 대해 알아보았다. 3개의, 정렬 알고리즘의 시간 복잡도는 주어진 데이터에 따라 달라지지만 보통 O(N^2) 의 형태를 띄고 있다. 하지만 이번 포스팅에서 설명할 퀵 정렬 의 시간복잡도는 O(N^2)가 아닌 O(N * log N) 를 가지고 있다. 이런 특징 때문에 여러 언어의 정렬 알고리즘의 기반이 되는 알고리즘으로 쓰이고 있다. ex) C++의 sort( ) 등등문제 문제 : 다음 숫자들을 오름차순으로 정렬하는 프로그램을 작성 하여라 [ 7, 5, 9, 0, 3, 1, 6, 2, 4, 8 ]SOL문제를 해결하기 위해 퀵정렬을 쓴다면 “특정한 값을 기준으로 큰 숫자와 작은 숫자를 나누어 배치하기” 를 생각해 볼 수 있다.위와 같은 방식을 퀵정렬 이라고 한다. 특징 평균 시간 복잡도는 O(N * log N)이다. 최악(데이터가 거의 정렬되어 있는)의 경우의 시간 복잡도는 O(N^2)이다. 효율성이 좋아 각 언어의 sort lib의 기반이 되는 알고리즘으로 사용된다. 구현#include &amp;lt;iostream&amp;gt;using namespace std; void QuickSort(int *arr, int begin, int end){ if(begin &amp;gt;= end) return; // 원소가 1개인 경우 종료 int pivot = begin; // 기준값(pivot)은 첫번째 인덱스 int left = begin + 1; int right = end; while (left &amp;lt;= right) { // Left값이 Pivot값 보다 작은경우 반복 while (left &amp;lt;= end &amp;amp;&amp;amp; arr[left] &amp;lt;= arr[pivot]) left++; // Right값이 Pivot값 보다 큰경우 반복 while (right &amp;gt; begin &amp;amp;&amp;amp; arr[right] &amp;gt;= arr[pivot]) right--; // Left, Right의 인덱스 즉 순서가 엇갈리면, Pivot, Right swap if(left &amp;gt; right) swap(arr[pivot], arr[right]); // Pivot값보다 L, R의 조건이 모두 맞지 않는 경우 swap(L, R) else swap(arr[left], arr[right]); } // 재귀적 호출 (log N)번 실행 // pivot 보다 작은 값들의 리스트 (pivot 포함 O) QuickSort(arr, begin, right - 1); // pivot 보다 큰 값들의 리스트 (picot 포함 X) QuickSort(arr, right + 1, end);}int main(){ int arr[10] = {7, 5, 9, 0, 3, 1, 6, 2, 4, 8}; int n = 10; QuickSort(arr, 0, n-1); for(auto el : arr) cout &amp;lt;&amp;lt; el &amp;lt;&amp;lt; &quot; &quot;; cout &amp;lt;&amp;lt; endl; return 0;}출력0 1 2 3 4 5 6 7 8 9 해설위 코드를 실행하면 오름차순으로 배열이 정리된 모습을 확인 할 수 있다. 리스트 안의 요소 한개를 선택한다. - 기준값(Pivot) 설정 int pivot = begin; // 기준값(pivot)은 첫번째 인덱스 설정한 기준값(Pivot)을 기준으로 보다 작은 요소는 왼쪽 보다 큰 요소들은 모두 오른쪽으로 반복적으로 옮긴다. // Left값이 Pivot값 보다 작은경우 반복 while (left &amp;lt;= end &amp;amp;&amp;amp; arr[left] &amp;lt;= arr[pivot]) left++; // Right값이 Pivot값 보다 큰경우 반복 while (right &amp;gt; begin &amp;amp;&amp;amp; arr[right] &amp;gt;= arr[pivot]) right--; 기준값(Pivot)을 제외한 왼쪽, 오른쪽 리스트를 정렬한다. // Left, Right의 인덱스 즉 순서가 엇갈리면, Pivot, Right swapif(left &amp;gt; right) swap(arr[pivot], arr[right]);// Pivot값보다 L, R의 조건이 모두 맞지 않는 경우 swap(L, R)else swap(arr[left], arr[right]); 분할된 부분의 리스트를 다시 호출 - 정렬한다. 분할 된 리스트도 마찬가지고 기준값(Pivot)을 기준으로 2개의 리스트로 나누는 과정을 재귀적으로 반복한다. // 재귀적 호출 (log N)번 실행 // pivot 보다 작은 값들의 리스트 (pivot 포함 O) QuickSort(arr, begin, right - 1); // pivot 보다 큰 값들의 리스트 (picot 포함 X) QuickSort(arr, right + 1, end); 언제까지?? ~~&amp;gt; 리스트의 크기가 0이나 1이 될때까지 if(begin &amp;gt;= end) return; // 원소가 1개인 경우 종료 예시문제 두개의 배열 A, B가 존재한다. 이 두 배열은 N개의 원소로 구성되어 있으며, 배열의 원소는 모두 자연수이다. 두 배열 A, B를 서로 K 번의 스왑을 할 수 있을 때 배열 A의 모든 원소의 합이 최대가 되어야 한다.SOL#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std; void solution(vector&amp;lt;int&amp;gt; arr_1, vector&amp;lt;int&amp;gt; arr_2, int k){ int answer = 0; sort(arr_1.begin(), arr_1.end()); sort(arr_2.rbegin(), arr_2.rend()); for(int i=0; i &amp;lt; k; i++) if(arr_1[i] &amp;lt; arr_2[i]) swap(arr_1[i], arr_2[i]); for(auto el : arr_1) answer += el; cout &amp;lt;&amp;lt; answer &amp;lt;&amp;lt; endl;}int main(){ vector&amp;lt;int&amp;gt; arr_1{1,2,5,4,3}; vector&amp;lt;int&amp;gt; arr_2{5,5,6,6,5}; int k = 3; solution(arr_1, arr_2, k); return 0;}Reference자바 [JAVA] - 퀵 정렬 (Quick Sort)(이코테 2021 강의 몰아보기) 4. 정렬 알고리즘" }, { "title": "정렬 알고리즘(삽입 정렬)", "url": "/posts/%EC%A0%95%EB%A0%AC3-%EC%82%BD%EC%9E%85%EC%A0%95%EB%A0%AC/", "categories": "algorithm, 정렬", "tags": "algorithm, 정렬, C++", "date": "2022-03-15 17:10:00 +0900", "snippet": "삽입 정렬(Insertion Sort)개yo앞선 포스팅에서는 선택정렬 , 버블정렬 에 대해 알아보았고, 이번 포스팅에서는 삽입정렬을 구현하고 시간 복잡도를 알아 보도록 하겠다.문제 문제 : 다음 숫자들을 오름차순으로 정렬하는 프로그램을 작성 하여라 1 10 5 8 7 6 4 3 2 9SOL문제를 해결하기 위해 “각 숫자를 적절한 위치에 삽입”을 이용할 수 있다.위와 같은 방법을 삽입정렬 이라고 부른다. 특징 다른 정렬 알고리즘보다 비교적 느린 알고리즘에 속한다. 조금 복잡한 구조를 가지고 있다. 특정한 경우에 굉장히 빠른 속도를 갖는다. 구현#include &amp;lt;iostream&amp;gt;using namespace std; int main(void) { int i, j, temp; int array[10] = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9}; for(i = 0; i &amp;lt; 9; i++) { j = i; while(j &amp;gt;= 0 &amp;amp;&amp;amp; array[j] &amp;gt; array[j + 1]) { temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; j--; } } for(i = 0; i &amp;lt; 10; i++) { printf(&quot;%d &quot;, array[i]); } return 0;}출력 값1 2 3 4 5 6 7 8 9 10해설위 코드를 실행하면 오름차순으로 배열이 정리된 모습을 확인 할 수 있다. 2 3 4 5 6 7 8 9 10 1 데이터가 위와 같이 거의 정렬된 상태일 때는 필요한 경우에만 삽입이 이루어지는 삽입정렬 은 데이터가 거의 정렬된 경우에는 시간복잡도가 O(N)와 유사함으로 어떤 알고리즘보다도 빠른 특징을 가지고 있다. 하지만 정렬이 거의 되어있지 않은 상태에서의 시간 복잡도는 선택정렬 , 버블정렬 과 동일하게 O(N^2) 로 표현할 수 있다. 삽입정렬 : 멈출 타이밍(위치, index)을 스스로 판단하는 정렬 알고리즘 #### 추가설명/* &amp;lt; 예시 입력 &amp;gt;1026 5 37 1 61 11 59 15 48 19&amp;lt; 예시 출력 &amp;gt;26 5 26 5 26 37 1 5 26 37 1 5 26 37 61 1 5 11 26 37 61 1 5 11 26 37 59 61 1 5 11 15 26 37 59 61 1 5 11 15 26 37 48 59 61 1 5 11 15 19 26 37 48 59 61&amp;lt; 출력 &amp;gt; */위와 같은 삽입정렬의 과정을 출력하는 코드를 살펴 본다면#include &amp;lt;stdio.h&amp;gt;int n;int array[101];int main(void) { int i, j, temp, n; scanf(&quot;%d&quot;, &amp;amp;n); for(i = 0; i &amp;lt; n; i++) { scanf(&quot;%d&quot;, &amp;amp;array[i]); } for(i = 0; i &amp;lt; n; i++) { j = i; while(j &amp;gt; 0 &amp;amp;&amp;amp; array[j - 1] &amp;gt; array[j]) { temp = array[j - 1]; array[j - 1] = array[j]; array[j] = temp; j--; } for(j = 0; j &amp;lt;= i; j++) { printf(&quot;%d &quot;, array[j]); } printf(&quot;\\n&quot;); } return 0;}위 코드는 시작부터 특정 위치에서 시작하여 왼쪽으로 이동하여 자신보다 작은 것을 만날 때 그 위치에 원소를 삽입하는 과정을 따른다. 본 포스팅은 동빈나님의 블로그를 참고하여 작성하였습니다." }, { "title": "정렬 알고리즘(버블 정렬)", "url": "/posts/%EC%A0%95%EB%A0%AC2-%EB%B2%84%EB%B8%94%EC%A0%95%EB%A0%AC/", "categories": "algorithm, 정렬", "tags": "algorithm, 정렬, C++", "date": "2022-03-15 16:10:00 +0900", "snippet": "버블 정렬(Bubble Sort)개yo저번 포스팅에서는 선택정렬 알고리즘에 대해 알아 보았고, 이번 포스팅에서는 버블정렬 을 구현하고 시간 복잡도를 알아 보도록 하겠다.문제 문제 : 다음 숫자들을 오름차순으로 정렬하는 프로그램을 작성 하여라 1 10 5 8 7 6 4 3 2 9SOL문제를 해결하기 위해 “옆에 있는 값과 비교하여 작은값을 앞으로 보내기”를 이용할 수 있다.위와 같은 방법을 우린 버블정렬 이라고 부른다.특징정렬 알고리즘 중 가장 구현하기 쉽다.가장 비효율적인 방법이다.구현#include &amp;lt;iostream&amp;gt;using namespace std; int main(void) { int i, j, temp; int array[10] = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9}; for(i = 0; i &amp;lt; 10; i++) { for(j = 0; j &amp;lt; 9 - i; j++) { // index j, j+1과 비교하여 조건에 맞으면 두 index를 바꾼다. if(array[j] &amp;gt; array[j + 1]) { temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; } } } for(i = 0; i &amp;lt; 10; i++) { printf(&quot;%d &quot;, array[i]); } return 0;}출력 값1 2 3 4 5 6 7 8 9 10해설위 코드를 실행하면 오름차순으로 배열이 정리된 모습을 확인 할 수 있다. 단순 반복적으로 두 숫자를 비교하여 앞으로 보낸다. 각 사이클 마다 가장 큰 값이 맨 뒤로 보내지게 된다.위 두 과정은 컴퓨터의 내부적인 연산이 가장 비효율적으로 일어나게 되어 실제 수행시간이 가장 느린 안좋은 알고리즘이라고 할 수 있다.시간 복잡도는 선택정렬 과 동일하게 O(N^2) 로 표현할 수 있다. 본 포스팅은 동빈나님의 블로그를 참고하여 작성하였습니다." }, { "title": "정렬 알고리즘(선택 정렬)", "url": "/posts/%EC%A0%95%EB%A0%AC1-%EC%84%A0%ED%83%9D%EC%A0%95%EB%A0%AC/", "categories": "algorithm, 정렬", "tags": "algorithm, 정렬, C++", "date": "2022-03-15 15:10:00 +0900", "snippet": "개요일반적으로 알고리즘을 공부 할 때 가장 쉽게 먼저 접하는 문제는 ‘정렬(Sort)’문제라고 할 수 있다.본 포스팅에서는 정렬 알고리즘 중에서도 선택정렬 을 구현하고 시간 복잡도를 알아 보도록 하겠다.문제 문제 : 다음 숫자들을 오름차순으로 정렬하는 프로그램을 작성 하여라 1 10 5 8 7 6 4 3 2 9SOL문제를 해결하기 위해 “가장 작은 것을 선택하여 앞으로 보내기”를 이용할 수 있다.위와 같은 방법을 우린 선택정렬 이라고 부르고, 한번 cpp 로 구현해보도록 하겠다.구현#include &amp;lt;iostream&amp;gt;using namespace std; int main(void) { int i, j, min, index, temp; int array[10] = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9}; for(i = 0; i &amp;lt; 10; i++) { min = 9999; for(j = i; j &amp;lt; 10; j++) { if(min &amp;gt; array[j]) { min = array[j]; index = j; } } temp = array[i]; array[i] = array[index]; array[index] = temp; } for(i = 0; i &amp;lt; 10; i++) { printf(&quot;%d &quot;, array[i]); } return 0;}출력 값1 2 3 4 5 6 7 8 9 10해설위 코드를 실행하면 오름차순으로 배열이 정리된 모습을 확인 할 수 있다.여기서 중요한 것은 데이터의 개수가 N개일 때 총 몇 번의 비교연산이 이루어 지고 있는지 확인하는 것이다. 따라서 이를 식으로 표현한다면N * (N + 1) 로 표현할 수 있으며, 이을 빅오 표기법으로 표현하면O(N^2) 로 표현할 수 있다. 본 포스팅을 동빈나님의 블로그를 참고하여 작성되었습니다." }, { "title": "big(O) notation", "url": "/posts/bigO-notation/", "categories": "algorithm, 자료구조", "tags": "algorithm", "date": "2022-03-14 15:10:00 +0900", "snippet": "big (O) notation개yo프로그래밍에 있어 가장 고려해야되는 점이 있다고 하자면, 우린 프로그램의 효율성… 즉 프로그램이 처리되는 속도와, 메모리를 사용하는 공간 정도라고 할 수 있다. 이런 속도, 공간의 정도를 비교하는 수식으로 표현하는 방식이 있는데 이것을 우린 big(O) 표기법이라고 한다. 이번 포스팅에선 big(O) 에 대해 알아보도록 하겠다.big(O) notation big(O) notation 빅오 표기법이라고 하는걸 우린 왜 사용할까…?빅오 표기법을 단순하게 표현 하자면 코드의 효율성을 수식으로 나타내어 주는 표기법이다.알고리즘의 효율성은 input값의 개수 N 이라고 할 때 연산을 하는 횟수를 가지고 판별한다.따라서 이를 가지고 시간과 공간의 효율성을 따질 수 있는데 이를 각각 시간 복잡도 , 공간 복잡도 라고 하며, big(O)의 크기가 클 수록 효율성이 떨어진다는것을 알 수 있다.특징 상수 무시 빅오 표기법에서 데이터 입력값(N)이 충분히 크다고 가정을 하고 있다. 따라서 알고리즘의 효율성 또한 데이터 입력값(N)의 크기에 따라 영향 받기에 상수 부분은 무시한다. ex) O(2N) → O(N) 영향력이 없는 항 무시 빅오 표기법은 데이터 입력값(N)의 크기에 따라 영향을 받기 때문에 가장 영향력이 큰 항에 이외에 영향력이 없는 항들은 무시한다. ex) O(N^2 + 3N + 2) → O(N^2) big(O) Functions 아래의 그래프는 주로 쓰이는 빅 오 표기들의 그래프를 나타낸 것이다.슉 슈슉위 그래프에 있는 식들은 big(O)를 가지고 주로 쓰이는 함수들이며, 순서대로 알아보도록 하겠다.1. O(1) : Constant Time 입력 데이터의 크기와 상관없이 언제나 일정한 시간이 걸린다. 아래의 코드는 O(1)을 구현한 것이다.Function(int arr[N]){ return (arr[0] == 0) ? true : false;}2. O(N) : Linear Search 입력 데이터의 크기와 비례한 만큼 시간이 늘어난다. 아래의 코드는 O(N)을 구현한 것이다.Function(int arr[N]){ for(int i=0; i &amp;lt; N; i++) cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl;}3. O(N^2) : Quardratic Time 입력 데이터의 크기에 따라 시간이 지수 그래프를 그리며 증가함 아래의 코드는 O(N^2)을 구현한 것이다.Function(int arr[N]){ for(int i=0; i &amp;lt; N; i++) for(int j=0; i &amp;lt; N; i++) cout &amp;lt;&amp;lt; i + j &amp;lt;&amp;lt; endl;}4. O(N*M) 특징은 3의 식과 비슷하지만 다르며, 대체적으로 O(N^2)보단 시간이 덜 증가한다. 아래의 코드는 O(N*M)을 구현한 것이다.Function(int arr[N], M){ for(int i=0; i &amp;lt; N; i++) for(int j=0; i &amp;lt; M; i++) cout &amp;lt;&amp;lt; i + j &amp;lt;&amp;lt; endl;}5. O(N^3) O(N^2)와 특징은 같으며, 처리시간이 보다 더 급격하게 늘어난다. 아래 코드는 O(N^3)을 구현한 것이다.Function(int arr[N]){ for(int i=0; i &amp;lt; N; i++) for(int j=0; j &amp;lt; N; j++) for(int k=0; k &amp;lt; N; j++) cout &amp;lt;&amp;lt; i + j + k &amp;lt;&amp;lt; endl;}6. O(2^N) 보통 일반적으로 재귀 함수를 이용해 피보나치 수열을 만드는데 사용된다. 특징으로는 매번 함수가 호출될 때마다 두번씩 호출하며, 트리의 높이만큼 반복한다. 아래의 코드는 재귀함수를 이용하여 피보나치 수열을 구현한 것이다.Function(int r[n]) { if(n &amp;lt;= 0) return 0; else if(n == 1) return r[n] = 1; return r[n] = Function(n - 1, r[n]) + Function(n - 2, r[n]); }7. O(log N) : Logarithmic Time 주로 이진검색(binary search) 알고리즘에 사용되며, 검색되는 데이터가 절반씩 줄어드는 특징을 가지고 있으며, 앞서 설명한 알고리즘 중 가장 시간 복잡도가 적다. 단. 정렬되지 않은 배열에는 사용할 수 없다. 아래의 코드는 O(log N)를 이용하여 이진검색을 구현한 것이다.Function(int k, arr[], begin, end)// k : 피봇값이 아닐까...?{ if(begin &amp;gt; end) return -1; int m = (begin + end) / 2; // m : 배열의 중앙 index if(arr[m] == k) return m; // key값이 중간 값 보다 작은 경우 : 처음부터 중간까지 else if(arr[m] &amp;gt; k) return Function(k, arr[], brgin, m-1); // key값이 중간 값 보다 큰 경우 : 중간부터 끝까지 else return Function(k, arr, m+1, end);} 아래는 정렬되지 않은 9개의 요소를 가지고 있는 데이터를 이진검색(binary search)을 사용한 위 코드의 과정이라 볼 수 있다. 2진트리의 모습을 띄고 있으며, 이진검색이기 때문에 시간복잡도는 O(log N)이다. 따라서 데이터 N의 값은 9이기 때문에 시간 복잡도의 값은 O(log 8) ~&amp;gt; O(3)이라 할 수 있다. 1 2 3 4 5 6 7 1 2 3 4 | 5 6 7 ~&amp;gt; 1단계 1 2 | 3 4 | 5 6 | 7 ~&amp;gt; 2단계 1 | 2 | 3 | 4 | 5 | 6 | 7 ~&amp;gt; 3단계 Reference 본 포스팅은 엔지니어 대한민국님의 유튜브를 참고하여 작성하였습니다." } ]
