---
title: DFS 깊이 우선 탐색
author: ggh-png
date: 2022-08-11 10:10:00 +0800
categories: [algorithm]
tags: [algorithm, graph, dfs]
render_with_liquid: false
---
# DFS 깊이 우선 탐색

### 개요

---

DFS, 깊이우선탐색

깊이 우선탐색은 그래프를 탐색할 때 쓰이는 알고리즘으로, 특정한 노드에서 가장 멀리 있는 노드를 우선적으로 탐색하는 알고리즘이다.

주어진 맵 전체를 탐색하며, 한번 방문한 노드는 재 방문하지 않기에 인접한 리스트로 이루어진 맵이면

O(V + E)

인접 행렬로 이루어진 맵이면 

O(V^2)

### 깊이 우선 탐색 (DFS)

---

> 특정 노드에서 가장 먼 곳의 노드부터 순차적으로 탐색한다.
> 

**수도코드**

아래는 DFS의 수도코드다. 

```cpp
DFS(G, u)
    u.visited = true
    for each v ∈ G.Adj[u]
        if v.visited == false
            DFS(G,v)
```

#### 특징 

방문할 수 있는 좌표이며, 이전에 방문하지 않았더라면 

DFS함수를 재귀적으로 호출하는 방법을 쓰며, 만약 이전에 방문을 했더라면 함수를 종료 시킨다.

### 예시문제

---

[1012번: 유기농 배추](https://www.acmicpc.net/problem/1012)

문제

차세대 영농인 한나는 강원도 고랭지에서 유기농 배추를 재배하기로 하였다. 농약을 쓰지 않고 배추를 재배하려면 배추를 해충으로부터 보호하는 것이 중요하기 때문에, 한나는 해충 방지에 효과적인 배추흰지렁이를 구입하기로 결심한다. 이 지렁이는 배추근처에 서식하며 해충을 잡아 먹음으로써 배추를 보호한다. 특히, 어떤 배추에 배추흰지렁이가 한 마리라도 살고 있으면 이 지렁이는 인접한 다른 배추로 이동할 수 있어, 그 배추들 역시 해충으로부터 보호받을 수 있다. 한 배추의 상하좌우 네 방향에 다른 배추가 위치한 경우에 서로 인접해있는 것이다.

한나가 배추를 재배하는 땅은 고르지 못해서 배추를 군데군데 심어 놓았다. 배추들이 모여있는 곳에는 배추흰지렁이가 한 마리만 있으면 되므로 서로 인접해있는 배추들이 몇 군데에 퍼져있는지 조사하면 총 몇 마리의 지렁이가 필요한지 알 수 있다. 예를 들어 배추밭이 아래와 같이 구성되어 있으면 최소 5마리의 배추흰지렁이가 필요하다. 0은 배추가 심어져 있지 않은 땅이고, 1은 배추가 심어져 있는 땅을 나타낸다.

입력

입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트 케이스에 대해 첫째 줄에는 배추를 심은 배추밭의 가로길이 M(1 ≤ M ≤ 50)과 세로길이 N(1 ≤ N ≤ 50), 그리고 배추가 심어져 있는 위치의 개수 K(1 ≤ K ≤ 2500)이 주어진다. 그 다음 K줄에는 배추의 위치 X(0 ≤ X ≤ M-1), Y(0 ≤ Y ≤ N-1)가 주어진다. 두 배추의 위치가 같은 경우는 없다.

출력

각 테스트 케이스에 대해 필요한 최소의 배추흰지렁이 마리 수를 출력한다.

---

#### SOL
주어진 맵의 인접한 곳들은 모두 하나의 ans값으로 취급한다.
1. 맵 생성 후 주어진 좌표에 배추를 심는다. 
2. 맵 전체를 순회 하면서 dfs를 실행시킨다.

### 구현

---

```cpp
#include <iostream>
using namespace std;

// 배추밭, 방문여부, 배추밭의 크기
int n, m;
bool map[51][51];
bool visited[51][51];
// 좌표
int x, y;
// joy
int dy[] = {-1, 0, 1, 0};
int dx[] = {0, 1, 0, -1};

void dfs(int y, int x)
{
    // 방문 
    visited[y][x] = 1;
    // 동서남북 탐색 
    for(int i=0; i < 4; i++)
    {
        int ny = y + dy[i];
        int nx = x + dx[i];
        // 주어진 배추밭의 크기를 넘기면 콘티뉴
        if(ny < 0 || ny >= n || nx < 0 || nx >= m)
            continue;
        // 배추가 존재하고, 방문하지 않을 경우
        // 즉, 인접해 있을 경우 방문
        if(map[ny][nx] == 1 && !visited[ny][nx])
            dfs(ny, nx);
    }
    // 인접하지 않을 경우 함수 종료
    return;
}

int main()
{
    int num;
    cin >> num;
    for(int i=0; i < num; i++)
    {
        // 지렁이의 필요 개수
        int ans = 0;
        // 배추밭의 크기, 배추의 개수 입력
        int N;
        cin >> m >> n >> N;
        // 배추 심기
        for(int j=0; j < N; j++)
        {
            int tmpx, tmpy;
            cin >> tmpx >> tmpy;
            map[tmpy][tmpx] = 1;
        }
        // 배추밭 탐색
        for(int j=0; j < n; j++)
            for(int k=0; k < m; k++)
                // 배추가 존재하고, 방문하지 않았다면
                if(map[j][k] == 1 && !visited[j][k])
                {
                    ans++;
                    dfs(j, k);
                }
                
        // 필요 지렁이 개수 출력
        cout << ans << '\n';
        //배추밭 출력
        // for(int j=0; j < n; j++)
        // {
        //     for(int k=0; k < m; k++)
        //         cout << map[j][k] << " ";
        //     cout << endl;   
        // }
        
        // 배추밭 초기화 
        for(int j=0; j < 51; j++)
            for(int k=0; k < 51; k++)
            {
                map[j][k] = 0;
                visited[j][k] = 0;
            }
    }

    return 0;
}
```

### **Reference**

---

[큰돌의 터전 : 네이버 블로그](https://blog.naver.com/jhc9639/222289089015)